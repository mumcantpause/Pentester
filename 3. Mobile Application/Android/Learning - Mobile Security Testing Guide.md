

```

#. Analisi Statica
Esame del codice sorgente o del binario dell'applicazione per identificare potenziali problemi di sicurezza, senza l'esecuzione dell'applicazione 


#. Analisi Dinamica
Testare l'applicazione o il dispositivo in tempo reale-tempo per individuare vulnerabilità e punti deboli. 


#. Penetration Testing:  
Simula attacchi applicativi 

 

#. Reverse Engineering:  



###. Tools
1. ADB 
2. JADX-Gui
3. Apktool 
4. Frida-server
5. Genymotion 
6. Mobsf
7. Drozer  


#. ADB - Android Debug Bridge Tool:
Permette di comunicare/debugging con dispositivi Android o Emulatori
#adb shell
#adb devices  
#adb -s DEVICE_ID shell
ADB without USB: #adb tcpip 5555  
#adb connect DEVICE_IP_ADDRESS:5555 #adb shell   


#. Jadx-GUI 
apt-get install jadx 
apt install default-jdk   


#. Apktool:
Apktool reverse engineering, decompile, disassemble, decode   


#. Frida:
Frida is a dynamic instrumentation framework used for analysing, reverse engineering, and manipulating the behaviour of mobile and desktop applications.  

pip3 install frida-tools 
Frida Server: Run all'interno del device o emulatore (carico il frida-server in data/local/tmp) 
Frida Client: Run sull'host e comunica con il server  
Running Process: 
#frida-ps -U  Running Applications: 
#frida-ps -Ua   Installed Application: 
#frida-ps -Uai


#. Objection Interact with Android apps at runtime and perform various types of security testing such as bypassing certificate pinning.  
Functionality:     
• SSL pinning bypassing and SSL validation manipulation 
• Dynamic method hooking and manipulation 
• Exploration of SQLite databases 
• Manipulation of Shared Preferences and other data stores 
• Injection of custom code and payloads 


#. Mobsf Tool per effettuare scansioni dell'APK.    
> docker pull opensecurity/mobile-security-framework-mobsf:latest
> docker run -it --rm -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest   


pip install --upgrade setuptools



7. Drozer Tools per automatizzare e ricercare exploit vulnerabilities in Android applications. Funzionalità:     
• Interact with the Android operating system using a powerful command-line interface 
• Modify the behaviour of an application at runtime using custom scripts 
• Perform code injection and hooking to monitor and manipulate application behaviour 
• Identify potential vulnerabilities through automated testing and fuzzing techniques 
• Reproduce and exploit discovered vulnerabilities in a controlled environment  
#docker pull fsecurelabs/drozer 
#docker run -it fsecurelabs/drozer  
#adb forward tcp:31415 tcp:31415  
#drozer console connect --server 
#run app.package.list -f <nomePackage>
#run app.package.info -a com.mwr.example.sieve
#run app.package.attacksurface com.mwr.example.sieve 
#run app.actively.info -a package name(com.mwr….)






###. Android Structure:
#. Applications (Home, Gallery, Contact, etc) 
#. Application Framework (Activity Manager, Notitifcation Manager, Content Provider, Package Manager, View System) 
#. Android Runtime (Dalvik VM, Zygote, Core libreries)
#. Platform Libraries (Media, Graphics, SSL) 
#. Linux Kernel (Wifi Driver, Display Driver, Audio Driver, Usb Driver, Camera Driver, Bluetooth Driver)




#. Application framework 
Application Framework provides several important classes which are used to create an Android application .It 

Provides a generic abstraction for hardware access and also helps in managing the user interface with 

Application resources. Generally, it provides the services with the help of which we can create a particular class and make that class helpful for the Applications creation. It includes different types of services activity  



#. Android Runtime
Android Runtime DVM (Dalvik Virtual Machine), run istance of application writtten using standard Java or Kotlin. Android Runtime (ART) predecessore di Dalvik, sono entrambi compatibili con Dex (Dalvik executable) Bytecode.   Platform libraries Media, SQLite, Web Kit  Android Boot process: 

In informatica, l'avvio è la messa in funzione di un computer o di un dispositivo informatico fino al suo utilizzo. Può essere avviato da 

hardware, come la pressione di un pulsante, o da un comando software. Dopo l'accensione, il computer è relativamente muto e può leggere solo una parte della sua memoria, chiamata memoria di sola lettura. Qui è memorizzato un piccolo programma chiamato firmware.  Esegue gli autotest all'accensione e, soprattutto, consente di accedere ad altri tipi di memoria, come il disco rigido e la memoria principale.  Il firmware carica programmi più grandi nella memoria principale del computer e li esegue. 

Nei computer generici, ma anche negli smartphone e nei tablet, viene eseguito facoltativamente un boot manager. 

Android Boot Process includes the following six steps: 
• Boot ROM 
• BootLoader 
• Kernel 
• Init 
• Zygote and Dalvik VM

Boot ROM:  questa fase è nota come accensione e avvio del sistema. Ciò significa che ogni volta che si preme il pulsante di pulsante di accensione, il codice della ROM di avvio inizia a essere eseguito da una posizione predefinita che è cablata nella ROM. 

La ROM di avvio carica il BootLoader nella RAM e inizia l'esecuzione. 

BootLoader: Il bootloader è un codice di basso livello che contiene le istruzioni che indicano a un dispositivo come avviarsi e trovare il kernel del sistema. 

Il bootloader è un luogo in cui i produttori inseriscono i loro blocchi e le loro restrizioni. 

Il bootloader è un codice che viene eseguito prima dell'avvio di qualsiasi sistema operativo. Il BootLoader viene eseguito in 2 fasi: 

a) Nella prima fase, rileva la RAM esterna e carica un programma che aiuta nella seconda fase. 

b) Nella seconda fase, il bootloader configura la rete, la memoria, ecc. necessarie per l'esecuzione del kernel. 

Kernel: Una volta che il kernel si avvia, inizia a configurare la cache, la memoria protetta, la pianificazione, carica i driver, avvia i demoni del kernel, monta il file root e si occupa della gestione della rete. 

daemon, monta il file system root, inizializza Input/Output, avvia gli interrupt, inizializza la tabella dei processi. Un kernel è il livello più basso di software facilmente sostituibile che si interfaccia con l'hardware del dispositivo. Quando il kernel termina la configurazione del sistema, per prima cosa cerca "init" nei file di sistema e lancia il processo root o il primo processo di un sistema.  Init: Init è il primo processo o, per meglio dire, il nonno di tutti i processi. 

Il processo Init ha due responsabilità: 

- Monta le directory come /sys, /dev o - Esegue lo script /init.rc. Lo script init.rc è responsabile della configurazione iniziale del sistema. 

 Zygote e Dalvik VM: Zygote è un processo VM che si avvia all'avvio del sistema. Quando app_process 

lancia Zygote, crea prima la Dalvik VM e poi chiama il metodo main() di Zygote. Zygote riceve una richiesta di lanciare un'applicazione attraverso/dev/socket/zygote. Una volta che ciò avviene, si attiva una chiamata a fork (). 

- Quando un processo è un fork, crea un clone di se stesso. Si replica in un altro spazio di memoria. Questa operazione è fatto in modo abbastanza efficiente. Quando questo accade a Zygote, crea una nuova macchina virtuale Dalvik esattamente pulita come un come thread, precaricata con tutte le classi e le risorse necessarie di cui ogni applicazione avrà bisogno. Questo rende il processo di creazione di una VM e di caricamento delle risorse in modo piuttosto efficiente. 
    
- Consente la condivisione del codice nella macchina virtuale Dalvik, contribuendo a ridurre al minimo i tempi di avvio. 
    

 Permissions: Ogni app gira su una VM differente ed isolata, si può accedere ai file dello specifica app solo se lo uid è lo stesso che identifica l'app.  Static Analysis APK zip del codice compilato dei vari file .DEX. Solitamente un APK contiene un unico file .dex, che contiene tutte le classi e metodi usati dall'app  APK Structure: Manifest file: AndroidManifest.xml, file XML contenenti i metadati dell'applicazione, versione, permessi, activities, servizi  MinSDK Version:  Permissions: Definisce i dati e le componenti hardware al quale le app hanno necessità di accedervi  Activity: Rappresenta una finestra dell'app, utilizzata per mostrare la UI grafica (bottoni, testo immagini) extends android.app.Activity method:  onCreate() -> metodo richiamato quando l'Activity viene creata che permette di inizializzare tutte le componenti ed altre risorse onStart() -> metodo che viene richiamato l'Activity diventa visibile all'utente. onResume() -> metodo che viene richiamato quando l'Activity è in primo piano e viene richiamata onStop() -> metodo richiamato quando l'activity perde il focus (salvataggio dei dati, e rilascio delle risorse) onDestroy() -> metodo richiamato quando l'activity non è piu in esecuzione e/o visibile all'utente  

 Intent: Activities comunicano tra loro utilizzando gli Intent, che sono messaggi scambiati tra le differenti componenti dell'app. Ogni Intent, può creare nuove Activities o passare dati ad attuali.  

Intent-Filter: Is a way for an app to declare what types of intents it can receive or respond to. An intent filter is defined in an app's AndroidManifest.xml file and specifies the types of actions, data, and categories that an app can handle. E' un modo efficace di gestire la comunicazione, andando a specificare attraverso intent filter, delle azioni ed il tipo di dati trasmessi. <category> ----> .DEFAULT <data> ----> android:schema="HTTP" ---> Handle web links with http 

<action> ----> android.intent.action.VIEW ---> View data  

Flag exported=true; default se intent filter definito all'interno di un componente. 

 Content Provider: Componente utilizzata per condividere dati con altre app, utilizzata come una sorta di DB interno. Extends android.content.ContentProvider  Method: onCreate(), query(), insert(), update(), delete(), getType() 

Viene utilizzato un ContentResolver object per inviare una richiesta di accesso ai dati posseduti dal Content Provider  Lib: Contain native libreries (.so files)  Assets: Folder that contain file utilizzati dall'app in runtime (Html, images, sounds, video).  Meta-INF: Manifest.mf Cert.sf  Smali: linguaggio low level utilizzato per rappresentare Dalvik bytecode. E' utilizzato per modificare il bytecode DEX e ricompattare e fare reverse.  

 Reversing App with Apktool 

Decompilation: In this phase, the penetration tester decompiles the APK (Android Package) file of the target 

application to obtain the source code. Decompilation can be done using tools such as Apktool, dex2jar, or 

JADX. jadx-gui  

Ogni applicazione per andare sullo store deve essere firmata. apksigner: Utility from Android SDK and signing the APK with the private key   Reversing App MobSf: Utile per effettuare ed analizzare l'APK. Install and Upload l'APK  Service: Peform long running operations in the background without requiring user interaction.   

Riceivers: Servono per segnalare e gestire gli eventi che possono accadere con Android System Receivers: es. Batteria scarica Custom Receivers: es. Sono custom, utilizzati per gestire altri tipi di eventi es. un nuovo messaggio ricevuto, aggiornare un widget e sono anche detti BroadcastReceiver. Per registrare un receiver, è necessario inserire nell'app manifest file un tag <receiver> element con an <intent-filter> element, che specifica il tipo del broacast intent.  Provider: In Android, a Content Provider è una componente che gestisce un set di dati condivisi accessibili dalle componenti delle app o di altre app. Dati sono stored in SQLite db or fileSystem.  Component Core: Activities Broadcast Receivers Content Providers Services  Common Insecure Component: Se è presente un flag exported=true, is a misconfiguration. Se è presente un intent filter without a exported flag , viene settato a true ed è comunque una misconfiguration.   Drozen Tools Search vulnerabilities    DataStorage on Android:  SQLite Databases: SQL db engine that stores data in .db files, i dati non vengono criptati sqlite3 <nomeDB> ids2 

Shared Preferences: File che colleziona e salva le informazioni utilizzando un key-value pairs.  Firebase Databases: NoSql CloudHosted Database istance per storare data  Internal Storage:  External Storage:  Log:    Download APK from APP:  

26      pm list packages -f -3 | grep it.quadronica 

27      pm path t.quadronica.leghe 

28      pm path it.quadronica.leghe 

Adb pull <path> . 

adb pull /data/app/~~8PH363O4oTWfPyQ7DUrdqw==/it.quadronica.leghe-O4Q4jBQW5BMbWeK1w3XaaA==/base.apk  

Firebase Enumeration: Tool - firebase enum - github Sambal0x/firebaseEnum  Objection: objection patchapk -s <nameApk>.apk objection explore  #objection --gadget com.app.damnvulnerablebank explore -s "android root disable".   #objection --gadget b3nac.injuredandroid explore -s "android sslpinning disable"   

Posso usare pezzi di codice da iniettare nell'apk esistente per importare librerie di frida all'interno dell'APK, in modo da poter utilizzare objection e disabilitare il pinning dell'apk. Vado a decompilare l'apk con apktool, inietto il pezzo di codice nello smali code, lo ricompilo, lo firmo con keygen e jarsigner. Avvio l'APK e uso objection.




```