

```

###. Android:

#1. Certificate Pinning:
#2. Root Detection
#3. Request caching
#4. Plaintext SharedPreferences (/data/data/{ID}/shared_prefs/{FILE}.xml)
#5. Bypass accesso biometrico
#6. WebView Debug Mode Enabled (marketwall 2021) (setWebContentsDebuggingEnabled)
#7. Backup mode enabled (marketwall 2021)
#8. Task hijacking
#9. Missing Code Obfuscation
#10. Attribute usesCleartextTraffic set to True
#11. Hard-coded clear-text Cryptographic Secrets
#12. Bypass Pin Authentication
#13. Keystore Alias Misconfiguration
#14. Missing Rootkit Detection
#15. Weak PIN Policy
#16. Verbose Logs
#17. Insecure Data Storage


###. IOS
#1. Cert pinning
#2. root detection
#3. request caching
#4. plaintext userDefaults (/var/mobile/Containers/Data/Application/{ID}/Library/Preferences/{FILE}.plist)
#5. bypass accesso biometrico



```




```
#. Android - Depth



#1. Certificate Pinning:
L'applicazione non riesce a verificare l'identità del server prima di stabilire la connessione.
Tale verifica dovrà essere eseguita confrontando il certificato fornito dal server con una copia locale inclusa nel pacchetto di installazione.
È possibile eseguire attacchi man-in-the-middle fornendo certificati personalizzati ai client. Tale configurazione consente agli aggressori di intercettare e alterare il traffico scambiato tra client e server.
Confronta il certificato del server con una copia locale prima di stabilire la connessione.

Il certificate pinning è un meccanismo di sicurezza che consente di verificare che un canale di comunicazione basato su protocollo HTTPS sia sicuro. Vedremo, infatti, come sia piuttosto semplice intercettare una comunicazione instaurata da un'applicazione mobile a meno che questa non implementi tale meccanismo di sicurezza.  
Quando un client si connette ad un server tramite protocollo HTTPS verifica che il certificato HTTPS, fornito dal server, sia valido per il dominio contattato. Per far ciò i dispositivi (mobile e desktop) hanno preinstallati una lista di certificati attendibili riconosciuti a livello mondiale. Un certificato, viene ritenuto valido, se fa parte della lista (CA), oppure se è stato firmato a sua volta con un certificato attendibile, quindi se è stato firmato da una CA, oppure se è stato autofirmato ed inserito nei certificati di autentiticità.  
Sull'APP all'interno dell'APK nel file res/xml/network-security-config.xml, dovrebbe essere presente l'hash della chiave pubblica del certificato con cui l'APP lato client prova a validare la chiave privata del server durante il TLS Handshake.  
Attraverso Frida, si cerca di mockare i controlli delle classi e funzioni che effettuano il certificate pinning (es. Android Library -  OkHttp with CertificatePinner class e IOS NSURLConnectionDelegate using NSURLConnection).

https://antreem.com/it/blog/certificate-pinning-aumentare-il-livello-di-sicurezza-delle-connessioni
Una volta stabilita l'associazione tra host e certificato, la relazione tra i due viene formalizzata, fissando il certificato a quell'host. Una connessione sicura con un client o una chiamata API viene approvata solo nei casi in cui il certificato offerto esiste all'interno di quel set di certificati aggiunti.

Posso usare pezzi di codice da iniettare nell'apk esistente per importare librerie di frida all'interno dell'APK, in modo da poter utilizzare objection e disabilitare il pinning dell'apk.

il pinning SSL è una tecnica implementata dalla maggior parte dei proprietari di applicazioni in modo che qualsiasi richiesta inviata dall'applicazione mobile non venga intercettata. Il pinning SSL è considerato il primo e il passo più importante nel meccanismo di sicurezza di un'applicazione. Ma a causa di mezzi impropri, il pinning SSL di solito può essere aggirato. Ancora una volta Frida e Objection sono i migliori strumenti che ci aiuteranno qui.

1. Client Hello
2. Server Hello with Server Certificate (public key)
3. Client: Calculate hashing + Check Matching Hashing + Pinning or Not (Match or not Match)

APP scarica un hash del certificato dallo store all'interno dell' APK Quando comunico dall'APP verifico il certificato, se ho burp però io non riesco a certificare quindi vengo bloccato, devo fare in modo che quando le funzioni che effettuano il certificate pinning vengono richiamate, vengono mockate, bypassando il check reale. Faccio questo utilizzando Frida.

network_security_config.xml: 
file dove è presente il certificato, posso fare overrridare quel file, decompilare in smali e firmare l'apk

Il certificate pinning (o "pinning" del certificato) è una tecnica che mitiga gli attacchi di tipo "Man-in-the-middle" contro la comunicazione HTTPS sicura. In sostanza, il pinning assicura che la connessione sia valida solo se contiene almeno una delle chiavi pubbliche "pinnate".

Ecco come funziona il certificate pinning sulle app Android:

1. Definizione del Network Security Configuration: Android offre una funzionalità chiamata Network Security Configuration che ti permette di personalizzare le impostazioni di sicurezza di rete dell'app in un file di configurazione dichiarativo, senza dover modificare il codice dell'app¹. Questo file XML specifica le impostazioni per il tuo app.

2. Personalizzazione delle CA fidate: Di default, tutte le connessioni sicure (utilizzando protocolli come TLS e HTTPS) da tutte le app fidano delle CA preinstallate nel sistema. Tuttavia, potresti voler personalizzare le connessioni dell'app per fidarsi solo di un insieme specifico di CA. Puoi farlo utilizzando la configurazione di base (per personalizzazioni a livello di app) o la configurazione di dominio (per personalizzazioni specifiche per un dominio).

3. Configurazione di una CA personalizzata: Ad esempio, potresti voler connetterti a un host che utilizza un certificato SSL auto-firmato o un certificato SSL emesso da una CA non pubblica di cui ti fidi (ad esempio, la CA interna della tua azienda). Puoi configurare l'app per fidarsi di questa CA personalizzata nel file `res/xml/network_security_config.xml`:

    ```xml
    <?xml version="1.0" encoding="utf-8"?>
    <network-security-config>
        <domain-config>
            <domain includeSubdomains="true">example.com</domain>
            <trust-anchors>
                <certificates src="@raw/my_ca"/>
            </trust-anchors>
        </domain-config>
    </network-security-config>
    ```

In questo esempio, `example.com` rappresenta il dominio per cui vuoi applicare il pinning del certificato. Il certificato auto-firmato o della CA interna personalizzata deve essere aggiunto al file `res/raw/my_ca` in formato PEM o DER¹.

4. Validazione tramite X509TrustManager: Durante la connessione, Android verifica il certificato dell'host utilizzando il `X509TrustManager`. Se il certificato corrisponde a uno dei certificati "pinnati", la connessione viene considerata valida².

Tieni presente che il certificate pinning può essere potente, ma richiede attenzione. Le modifiche future alla configurazione del server, come il cambio di CA, potrebbero rendere le app con certificati "pinnati" impossibilitate a connettersi al server senza ulteriori interventi.

Origine: conversazione con Bing, 17/3/2024
(1) Network security configuration | App quality | Android Developers. https://developer.android.com/privacy-and-security/security-config.
(2) Dynamic SSL pinning for Android | Wultra Developer Portal. https://developers.wultra.com/components/ssl-pinning-android/develop/documentation/.
(3) Security with network protocols | App quality | Android Developers. https://developer.android.com/privacy-and-security/security-ssl.
(4) How to Implement Certificate Pinning in Android - Medium. https://medium.com/globant/how-to-implement-certificate-pinning-in-android-398b4b6cb5d.
(5) Android SSL Certificate pinning with retrofit - Medium. https://medium.com/@dhananjay_yaa/android-ssl-certificate-pinning-with-retrofit-39fb69e61a69.
(6) github.com. https://github.com/ljhlxd1221/notes/tree/4e8db8f9c70a7382f3536c2bbd8cf1dae77ecdcb/Joplin%2Fdesktop%2Fffda5d92c6f54ccc8d2fed1452082ee5.md.
(7) github.com. https://github.com/Pinned/pinned.github.io/tree/e44647bcd568f8c7ff80f05b8611e4ae8667df20/_posts%2F2019-08-10-Android-network-security-configuration.md.
(8) github.com. https://github.com/9Hyeonwoo/self_study/tree/9107860e7e0568aa179f5fc58c23721de6d6850a/android%2Fnetwork_security_configuration.md.








#2. Root Detection:
il rooting è il processo che consente agli utenti del sistema operativo mobile Android di ottenere un controllo privilegiato (noto come accesso root) su vari sottosistemi Android. Non dovrebbe essere consentita l'esecuzione delle applicazioni su dispositivi rooted. E quindi proviamo vari Root Detection Bypass usando Frida e Objection .



#3. Bypass accesso biometrico:
Agganciando e manomettendo alcune funzioni dell'applicazione in fase di esecuzione con il toolkit di strumentazione (come Frida), è possibile aggirare l'autenticazione biometrica a causa della debole implementazione della gestione delle credenziali.
fingerprintManager.authenticate(null, cancellationSignal, 0, authenticationCallback, null)

Android:
Il "CryptoObject" non viene utilizzato nel metodo "autentica" della classe "BiometricPrompt". L'implementazione dell'autenticazione si basa sul callback "onAuthenticationSucceded" che viene chiamato e potrebbe essere aggirato utilizzando un cryptoObject NULL in tale funzione.


Solution:
-	create the keystore key with setUserAuthenticationRequired and setInvalidatedByBiometricEnrollment set to true. Additionally, setUserAuthenticationValidityDurationSeconds should be set to -1
-	initialize cipher object with keystore key created above
-	create BiometricPrompt.CryptoObject using cipher object from previous step
-	implement BiometricPrompt.AuthenticationCallback.onAuthenticationSucceeded callback which will retrieve cipher object from the parameter and use this cipher object to decrypt some other crucial data such as session key, or a secondary symmetric key which will be used to decrypt application data
-	call BiometricPrompt.authenticate function with crypto object and callbacks created in steps 3 and 4







#4. Request caching:
Come comportamento predefinito, diversi framework iOS e Android sono configurati per memorizzare nella cache le richieste/risposte HTTP. Quest'ultimo può includere informazioni sensibili in chiaro come le credenziali di accesso.
Nello specifico, l'app memorizza nella cache tutte le risposte inclusi i dati PII dell'utente come nome, cognome, email, numero di telefono, indirizzo, ecc.
Un utente malintenzionato con accesso a tali file può estrarre informazioni personali e altri dati relativi all'account.
Solitamente cercare variabili statiche es. "CACHE_DIR"

Android example:
/data/data/{package.app.com}/cache/app_cache/*

iOS example:
/var/mobile/Containers/Data/Application/BEC86795-FBF4-454F-83E3-A2C00B6548FD/Library/Caches/{package.app.com}/Cache.db-wal




#5. Plaintext SharedPreferences (/data/data/{ID}/shared_prefs/{FILE}.xml):
Il file SharedPreferences (archiviazione XML con struttura chiave/valore) include token di accesso e aggiornamento in testo normale, nonché token di memorizzazione e token biometrici.
Un utente malintenzionato con privilegi di root potrebbe accedere a questi dati ed eseguire ulteriori attacchi.

/data/data/com.example.app/shared_prefs/FlutterSharedPreferences.xml






#6. WebView Debug Mode Enabled (marketwall 2021) (setWebContentsDebuggingEnabled):




#7. Backup mode enabled:
Android esegue per impostazione predefinita un backup completo delle applicazioni, inclusi i file privati ​​archiviati nella partizione /data. L'attributoallowBackup, se non impostato, ha il vero valore predefinito. Il servizio Gestione backup carica tali dati sull'account Google Drive dell'utente.
Se l'applicazione contiene dati sensibili che non devono essere ripristinati, la modalità di backup può essere disabilitata impostando l'attributo "android:allowBackup" su false nel tag dell'applicazione: <application android:allowBackup="false">
Altrimenti fa sì che tutti i dati dell'applicazione vengano salvati utilizzando `adb`. Il valore predefinito di questo attributo è `"true`



#8. Debug Mode Enabled:



#9. Task hijacking:
Task hijacking è una vulnerabilità che colpisce le applicazioni in esecuzione su dispositivi Android (<=10) a causa di un'errata configurazione nel file AndroidManifest.xml con le funzionalità di controllo delle attività.
Ciò potrebbe consentire agli aggressori/malware di prendere il controllo di app legittime, rubare i dati dell'utente ed eseguire una serie di attacchi.

Imposta "task affinity" delle attività dell'applicazione su "" (stringa vuota) nel tag <activity> di AndroidManifest.xml per forzare le attività a utilizzare un'affinità attività generata casualmente oppure impostala nel tag <application> su applicare su tutte le attività nell'applicazione.
Non specificare la modalità di avvio impostata su singleTask né aggiungere il supporto per un servizio di monitoraggio per rilevare la presenza di attività dannose in primo piano. Il problema è stato risolto da Android 11 e versioni successive.
Es. Task affinity not declared and activities launch mode is set to singleTask.

Si tratta di un attacco in cui un'app dannosa prende il controllo dello "stack back" dell'app vulnerabile e ogni volta che l'utente tenta di accedere all'app vulnerabile, verrà invece colpito dall'attività dell'app dannosa. Se alcuni parametri non sono valorizzati e Android <11, è possibile che un'altra applicazione in esecuzione in parallelo alla mia app vulnerabile possa intercettare il traffico nel momento in cui si esegue un task specifico.

E' utilizzato per andare ad indicare che il mio activity, ha un affinità con un'altra activity contenuta in un task (es. Se ho delle activity ripetute all'interno di un task ho un affinity). E' vulnerabile al task Hijacking. All'interno delle APP ho un task, al quale possono essere associate piu activity (es. Apro la posta, posso entrare all'interno di una mail e tornare indietro e quindi ritornare ad una nuova activity, che però ha un affinity con la prima ). Tornando indietro io utilizzo una stessa activity all'interno di un task, posso specificare che tale activity è la stessa o una nuova attraverso degli attributi (android: launch Mode: SingleTask /SignleIstance). Se SingleTask, posso avere un activity per ogni task, ed è vulnerabile perché posso avere una APP aperta in contemporanea che ha lo stesso id dell'activity associato ad un differente task, quindi quando devo andare ad utilizzare quell'activity vado a richiamare quella della mia APP malevola anziché quella dell'APP vulnerabile. Le activity hanno differenti attributi: LaunchMode, TaskAffinity, AllowTaskReparenting. Se LaunchMode è SingleTask e TaskAffinity non è randomico (quindi è valorizzato staticamente), allora è vulnerabile a quanto riportato sopra.  LaunchMode consentono di definire il modo in cui una nuova istanza di un'attività è associata all'attività corrente. L' attributo specifica un'istruzione su come l'attività dovrebbe essere avviata in un'attività. TaskAffinity Descrive a quale attività un'attività preferisce partecipare. Per impostazione predefinita, ogni activity ha la stessa affinità del nome del pacchetto. Specifico che un'attività ha affinità con un task. La mia activity ha un affinità con la seguente activity, quindi quando ho un task e sto creando un istanza contenente le mie activity, ricado in una delle seguenti casistiche.  La modalità LaunchMode è vulnerabile perché: - Se è già presente una istanza, Android riprende l'activity - Se non è presente l'istanza dell'activity, Android cerca di crearla selezionando un'attività per ospitare l'istanza appena creata trovandone una " corrispondente " in tutte le attività esistenti - Senza trovare un'attività "corrispondente" : L'AMS crea una nuova attività e rende la nuova istanza dell'attività l'attività root dell'attività appena creata. Un'attività "corrisponde" a un'attività se hanno la stessa affinità di attività .  Prevenzione: LaunchMode: singleIstance: se l'app non desidera che altre attività si uniscano alle attività ad essa appartenenti.









#. Missing Code Obfuscation:
Using open-source tools freely available to anyone, it has been possible to extract the application and to decompile the bytecode inside the .dex files, producing a source code that is nearly identical to the one written by the developers during the creation of the application.
Some of the Java classes available in the analyzed application are not properly obfuscated.
An attacker is facilitated in the application reverse engineering process both during static and dynamic analysis.

In order to make the reverse engineering process harder to conduct, obfuscate the source code including classes and variables using software solutions such as ProGuard or DexGuard, that can be integrated in the build process and that are able to automatically obfuscate the source code.













#. Attribute usesCleartextTraffic set to True:
L'attributo android:usesCleartextTraffic indica se l'app intende utilizzare il traffico di rete in chiaro, come HTTP in chiaro.
Il valore predefinito per le app destinate al livello API 27 o inferiore è "true". Le app destinate al livello API 28 o superiore hanno per impostazione predefinita "false"."

"flag" presente nell'APK se false è ok perchè specifica che  l'app non gestice http. Può essere overridato dai settings preseneti nel file network security  e config.xml AndroidManifest.xml.



#. Hard-coded clear-text Cryptographic Secrets:




#12. Bypass Pin Authentication:
By hooking and tampering some application's functions at runtime with instrumentation toolkit (such as Frida), it is possible to bypass the PIN authentication due to weak credentials management implementation.  
An attacker with local access to a victim device could use the application.

In fact, the PIN is encrypted with the KeyStore key _androidx_security_master_key_, and saved into the Android SharedPreferences file (/data/data/com.example.app/shared_prefs/shared_preferences_app.xml), but could be extracted during app execution since the SharedPreferences is decrypted with the master key as soon as the app started, getting the plaintext value as shown in the following example (as well as username and password), that could then be used as input into the application or as direct authentication method argument.

Example of function that returns the plaintext SharedPreferences:
o.setCrossfade.getAll()




It is recommended to store the PIN into the KeyStore in order to avoid reading the plaintext value during the app execution. 
Eventually use the SharedPreferences to store the encrypted value of the salted-PIN hash.








#13. Keystore Alias Misconfiguration:
The Android application uses the KeyStore to save a key, identified by the alias name "_androidx_security_master_key_". Such key, used to decrypt the SharedPreferences data, does not enforce the "isUserAuthenticationRequired" security attribute, which requires the device to be unlocked in order to access the key (the client is authenticated to the device).
A threat actor can access the KeyStore alias even if the device has not been unlocked (client not authenticated).

[Keystore.load (LoadStoreParameter)]
setCrossfade.getAll is called


It is recommended to set the attribute _isUserAuthenticationRequired_ to true value for all the aliases. In addition, set the attribute _isInvalidatedByBiometricEnrolment_ to true value for all the aliases involved in biometric usage.







#14. Missing Rootkit Detection
The application does not detect the state of rootkit / jailbreak of the device.
An attacker is able to read and write arbitrary binaries, analyse memory with debug tools and alter applications' behaviours by hooking to processes. These possibilities largely facilitate the reverse engineering process.

Limit functionalities on devices where root privileges were obtained or inform the user with a warning message.







#15. Weak PIN Policy
The application does not enforce a PIN policy: it is possible to set weak PINs using only one number or consecutive numbers (for example 00000, 11111, 12345 etc). An attacker is facilitated in the execution of PIN brute forcing attacks.	

Enforce a PIN policy requiring different and non-consecutive numbers.





#16. Verbose Logs:
Application logs contain verbose debug strings that include requests and responses data (json). An attacker is facilitated in the execution of further attacks.

Avoid logging requests and responses in production environment.





#17. Insecure Data Storage:
In Android, i file archiviati nella memoria interna sono progettati per essere accessibili esclusivamente dall'app che li ha creati . Questa misura di sicurezza viene applicata dal sistema operativo Android ed è generalmente adeguata alle esigenze di sicurezza della maggior parte delle applicazioni. Tuttavia, gli sviluppatori a volte utilizzano modalità come MODE_WORLD_READABLE e MODE_WORLD_WRITABLEper consentire la condivisione dei file tra diverse applicazioni. Tuttavia, queste modalità non limitano l'accesso a questi file da parte di altre applicazioni, comprese quelle potenzialmente dannose.







```

