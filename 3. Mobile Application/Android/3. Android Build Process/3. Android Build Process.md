
```
 

Android Asset Packaging Tool (aapt) 
 
 


 
Java Code -> .class files ->  

.class files + any third party libraries-> classes.dex file (DEX - Dalvik Executable) 
classes.dex -> apkBuilder to produce .apk file 
 
 
APK Structure 
.apk change in .zip and decompress it 
 
Directory APK Structure: 
1. AndroidManifest.xml 
2. /lib 
3. /assets 
4. /res 
5. /META-INF 
6. third_party libraries 
7. classes.dex 
8. resource.arsc 

 

 

AndroidManifest.xml 

core Android 
version of Android supported 
which app can talk with the component 
permissions require 
package -> name app 
uses-sdk -> minSdkVersion / targetSdkVersion 

<uses-permissions> 
<activity> 
<action> 
<category> 

<intent-filter> 
 
Classes.dex 
Limit of 65.535 method stored in a single dex file beacouse Dalvk VM support one single file .dex 
 
/Assets folder 
Store Anything in the assets folderm fonts, images, text, html 
 
/lib folder 
Storing libreries and precompiled code 

Can find Linux shared object (.so file) created by developer. If an attacker found a way to modify or replace these file, these result in arbitrary code execution. 
 
Meta-INF 
- MANIFEST.MF: Listing of all resource files and their SHA1 
- CERT.RSA: Developer signing certificate 
- CERT.SF: A list of the resources and their hashes, corresponding to the MANIFEST.MF 
 
/res 
directory with all the resources, such as images 
These files are less impactful from security perspective 
 

 

 

 

Code Signing 
Device Android non runnano .apk non firmati 
La chiave pubblica viene salvata in un file digitale, know as x.509 certificate usato per verificare l'identità. 
keytool utile per generare una private key 
 
>> keytool -genkey -v -keystore foo.keystore -alias myalias -keyalg RSA -keysize 2048 -validity 10000 
 
Genera file foo.keystore contenente single key valida per 10000 days 
 
 
jarsigner Tool: 
Used to Sign or verify a signature 
 
>> jarsigner -sigalg SHA1withRSA -digestalg SHA1 - keystore foo.keystore test.apk myalias 
 
sigalg: Specifies the signature algorithm used 
digestalg: Specifies the digest algorithm, used when digesting the file entries 
keystore: Specifies a keystore file, where the certificate files are stored 
myalias: Line in the keystore file 
 
Inspect signing status of an APK 
>> jarsigner -verify -verbose -certs com.fo.android.activity.apk 

 

Zipalign l'APK : Zipalign è un processo di ottimizzazione eseguito in un'applicazione. Questo processo consente ad Android di interagire in modo più efficiente con il file APK in runtime. Xamarin.Android esegue un controllo in runtime e consente l'esecuzione dell'applicazione solo se il file APK è stato sottoposto a Zipalign 

 

 
 
MANIFEST.MF file list and his of hashes(base64), uso openssl tools per verificare la correttezza e verificare il match 
>> openssl sha1 -binary res/drawable-hdpi/asd.png | openssl base64 

 

 
Cert.RSA file 
Uso il seguente comando per convertire il formato da DER a PEM ed ottenere il file cert.pem 
>> openssl pkcs7 -inform DER -print_certis -out cert.pem -in CERT.RSA 

 

 
See the details ofr the public key in certificate 
>> openssl x509 -in cert.pem -noout -text 
 
 
 
Android runna solo APP che sono firmate, per firmare un app è necessario creare una chiave privata con keytool e memorizzarla in un keystore, e firmare con jarisgner che andrà a creare il certificato con la chiave pubblica presente nel file CERT.SF. 
Da verificare: Quando si carica un app sul Play Store, si passa anche la chiave privata che verrà utilizzata da Google per autentificare l'app e identificare il proprietario. 
Quando si tenta di scaricare l'APK viene verificato solo se sia presente un certificato con chiave pubblica (non ho capito però come si verifica l'autenticità del certificato, cioè se sono in locale lo verifico con il mio keystore dove ho la chiave privata, ma se scarico l'app come faccio a verificare il certificato? Con chi verifico chiave pubblica-privata?) 
 
 
 
 
 
 
 


```