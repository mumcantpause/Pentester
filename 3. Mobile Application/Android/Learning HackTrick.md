

https://book.hacktricks.xyz/mobile-pentesting/android-checklist
https://book.hacktricks.xyz/mobile-pentesting/android-app-pentesting



```
###. Android Applications Basics:

Condivisione UID:
Applicazioni nel manifest devono avere lo stesso android:sharedUserId


Ambiente sicuro utilizzando Sandboxing per ciascuna applicazione.
Ad ogni applicazione viene applicato SELinux, che nega l'interazione tra processi non previste.


APK Contents (Not exhaustive)
- AndroidManifest.xml
- resources.arsc/strings.xml
- resources.arsc: contains precompiled resources, like binary XML.
	res/xml/files_paths.xml
- META-INF/This is where the Certificate is located!
- classes.dex: Contains Dalvik bytecode, representing the compiled Java (or Kotlin) code that the application executes by default.
- lib/
	Houses native libraries, segregated by CPU architecture in subdirectories.
	- armeabi: code for ARM based processors
	- armeabi-v7a: code for ARMv7 and higher based processors
	- x86: code for X86 processors
	- mips: code for MIPS processors only
- assets/
	- Stores miscellaneous files needed by the app, potentially including additional native libraries or DEX files, sometimes used by malware authors to conceal additional code.
- res/
Contains resources that are not compiled into resources.arsc


```



### Learn Android Fundamentals
```
###. ADB


Windows:
C:\Users\<username>\AppData\Local\Android\sdk\platform-tools\adb.exe

> adb devices
> adb -s "emulator" shell
> adb connect <IP>:<PORT>
> adb install -s test.apk   #install application on sdcard
> adb push test.apk /storage/emulated/0/Download
> adb push test.apk /sdcard
> adb uninstall <com.test.app>
> adb shell pm list packages <FILTER-STR>



Print the path to the APK:
> adb shell pm path <com.android.phone>
> adb shell pm clear <com.android.phone>


Taking a screenshot of a device display:
> adb shell screencap /sdcard/screen.png


PM - Command:
#List installed packages:
> pm list packages 

#Get the path to the apk file of tha package
> pm path <package name> 

#Start an activity. Whiout options you can see the help menu
> am start [<options>]

#Start a service. Whiout options you can see the help menu:
> am startservice [<options>] 

#Send a broadcast. Whiout options you can see the help menu:
am broadcast [<options>]

#Send keystrokes to device:
input [text|keyevent] 


ADB - Processes:
> adb shell pidof com.your.application [PID]
> adb shell ps [PID]




ADB - Logcat:
> adb logcat | grep 4526 (pid)
> adb logcat | findstr 4526 (pid)



> adb logcat *:V   #Lowest priority, filter to only show Verbose level
> adb logcat *:W   #Filter to only show Warning level
> adb logcat *:E   #Filter to only show Error level
> adb logcat *:F   #Filter to only show Fatal level
> adb logcat *:S   #Silent, highest priority, on which nothing is ever printed

> adb logcat *:E -f /data/local/tmp/log.txt
> adb locat -c    #Clear Log

> adb backup [-apk] [-shared] [-system] [-all] -f file.backup
> adb backup -f myapp_backup.ab -apk com.myapp

```

```
###. Smali

#. Fast Way:
Visual Studio Code + APKLab extensions u can automaticallyu decompile, modify, recompile, sign & install the application without executing any command.
Change Smali Code:
Using VS Code, install smalise extension with debugging editor enabled
After u must compile and sign APK

- Other Scripts: 
https://github.com/ax/apk.sh


#. Manual - Decompiling:
> apktool d APP.apk  (if error try with -r and dont decode resources - update lastest version)
[res/values/strings.xml]
[AndroidManifest.xml]
[.sqlite or .db]


#. Recompile the APK:
> apktool b . #In the folder generated when you decompiled the application


#. Sign the new APK:
La firma delle APK (Android Package) con una chiave è un passaggio cruciale per garantire l'integrità e la sicurezza delle applicazioni Android. Ecco alcuni motivi per cui è necessario firmare le APK con una chiave:

1. Verifica dell'autenticità: La firma con una chiave privata garantisce che l'APK provenga da una fonte attendibile. Quando un utente installa o aggiorna un'app, il sistema Android verifica la firma dell'APK utilizzando il certificato pubblico associato alla chiave privata. Se la firma corrisponde, l'aggiornamento viene accettato.

2. Prevenzione di modifiche non autorizzate: La firma impedisce modifiche non autorizzate all'APK. Se qualcuno tenta di alterare il codice o i contenuti dell'APK, la firma non corrisponderà e l'installazione verrà bloccata.

3. Gestione delle versioni: Per consentire l'aggiornamento di un'app, deve essere firmata con la stessa chiave utilizzata per la versione precedente. Questo garantisce che gli utenti ricevano solo aggiornamenti da fonti attendibili.

4. Distribuzione su Google Play: Per pubblicare un'app su Google Play, è obbligatorio firmarla con una chiave. Google Play gestisce automaticamente la chiave di firma dell'app e la utilizza per firmare gli APK di distribuzione ottimizzati generati dagli app bundle. Questo processo migliora la sicurezza e semplifica la gestione delle chiavi.



Then, you need to generate a key:
> keytool -genkey -v -keystore key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias <your-alias>

Sign the APK:
> jarsigner -keystore key.jks path/to/dist/* <your-alias>


#. Optimize new application:
Zipalign is an archive alignment tool that provides important optimisation to Android application (APK) files.
> zipalign [-f] [-v] <alignment> infile.apk outfile.apk
> zipalign -v 4 infile.apk

Estract APK from device:
> adb shell pm list packages
> adb shell pm path com.android.insecurebankv2
> adb pull /data/app/com.android.insecurebankv2- Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

Utils - Download APK Download:
Or APK Extractor from APP

https://apkcombo.com/es-es/apk-downloader/
https://apps.evozi.com/apk-downloader/
https://apkpure.com/es
https://www.apkmirror.com

```


```
###. Static Analysis:

# Tools:
# Mobsf:
> docker pull opensecurity/mobile-security-framework-mobsf:latest
> docker run -it --rm -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest 


# Drozer:



> Semgrep:


> Qark

# APKleaks:
> apkleaks -f name.apk -o output.txt


# Mariana Trench:
> 


# Ostorlab:
> Upload APK from file.apk or Store

# Static Analysis Code:
> 



#. APK Decompilers
- JD-GUI
- JADX:
To specify an output directory or adjust decompilation options: jadx app.apk -d <path to output dir> --no-res --no-src --no-imports
- ByteCode-Viewer


#. Tools - Leak Info:
Apkurlgrep:
Search for api keys, encryption, bluetooth uuids, tokens

Firebase - Bad Configuration:

###. Common Vulnerabilities:

#. Debuggable Applications:
le applicazioni impostate come debuggabili ( `debuggable="true"`) nel file _Manifest.xml_ rappresentano un rischio poiché consentono connessioni che possono portare allo sfruttamento. Per ulteriori informazioni su come sfruttare le applicazioni di cui è possibile eseguire il debug, fare riferimento a un tutorial su come trovare e sfruttare le applicazioni di cui è possibile eseguire il debug su un dispositivo.



#. Backup Configuration:
l' `android:allowBackup="false"`attributo deve essere impostato esplicitamente per le applicazioni che trattano informazioni sensibili per impedire backup di dati non autorizzati tramite adb, in particolare quando è abilitato il debug USB


#. Security Netowrk
le configurazioni di sicurezza di rete personalizzate ( android:networkSecurityConfig="@xml/network_security_config") in res/xml/ possono specificare dettagli di sicurezza come pin del certificato e impostazioni del traffico HTTP. Un esempio è consentire il traffico HTTP per domini specifici.


#. Activity - Service Exported:
identificare le attività e i servizi esportati nel manifest può evidenziare componenti che potrebbero essere utilizzati in modo improprio. Ulteriori analisi durante i test dinamici possono rivelare come sfruttare questi componenti.


#. Content Provider - File:
i fornitori di contenuti esposti potrebbero consentire l'accesso non autorizzato o la modifica dei dati. Anche la configurazione di FileProviders dovrebbe essere esaminata attentamente.


#. Broadcast Sender / Receiver
questi componenti potrebbero essere sfruttati per lo sfruttamento, con particolare attenzione al modo in cui gli schemi URL vengono gestiti per le vulnerabilità di input.


#. Version SDK:
gli attributi minSdkVersion, targetSDKVersione maxSdkVersionindicano le versioni Android supportate, evidenziando l'importanza di non supportare versioni Android obsolete e vulnerabili per motivi di sicurezza.


#. TapJacking:
Il tapjacking è un attacco in cui un'applicazione dannosa viene  lanciata e si posiziona sopra un'applicazione vittima . Una volta oscurata visibilmente l'app vittima, la sua interfaccia utente è progettata in modo tale da indurre l'utente a interagire con essa, mentre trasmette l'interazione all'app vittima. In effetti, impedisce all'utente di sapere che sta effettivamente eseguendo azioni sull'app vittima.

Per rilevare le app vulnerabili a questo attacco dovresti cercare le attività esportate nel manifest di Android (nota che un'attività con un filtro intent viene automaticamente esportata per impostazione predefinita). Una volta trovate le attività esportate, controlla se richiedono qualche autorizzazione . Questo perché anche l'applicazione dannosa avrà bisogno di tale autorizzazione .


Se sul button `android:filterTouchesWhenObscured`è impostato su `true, `View`non riceverà tocchi ogni volta che la finestra della vista è oscurata da un'altra finestra visibile. Se impostato su `true`, ad esempio, un pulsante può essere automaticamente disabilitato se è oscurato.

<Button android:text="Button"
android:id="@+id/button1"
android:layout_width="wrap_content"
android:layout_height="wrap_content" 
android:filterTouchesWhenObscured="true">
</Button>

https://github.com/carlospolop/Tapjacking-ExportedActivity

Puoi utilizzare qark con i parametri --exploit-apk--sdk-path /Users/username/Library/Android/sdkper creare un'applicazione dannosa per verificare possibili vulnerabilità di Tapjacking .\






#. Task Hijacking
In Android, un'attività è essenzialmente un insieme di attività con cui gli utenti interagiscono per completare un lavoro specifico, organizzato all'interno di uno stack . Questo stack ordina le attività in base a quando sono state aperte, con l'attività più recente visualizzata in alto come attività in primo piano . In qualsiasi momento, solo questa attività è visibile sullo schermo, rendendola parte dell'attività in primo piano .

Ecco una rapida ripartizione delle transizioni delle attività:

1. L'attività 1 inizia come unica attività in primo piano.

2. L'avvio dell'attività 2 spinge l'attività 1 nello stack posteriore, portando l'attività 2 in primo piano.

3. Iniziare l'Attività 3 sposta l'Attività 1 e l'Attività 2 più indietro nella pila, con l'Attività 3 ora in primo piano.

4. La chiusura dell'attività 3 riporta l'attività 2 in primo piano, mostrando il meccanismo semplificato di navigazione delle attività di Android.



Modalità di avvio
L' launchMode attributo dirige la gestione delle istanze di attività all'interno delle attività. La modalità singleTask è fondamentale per questo attacco, dettando tre scenari basati sulle istanze di attività esistenti e sulle corrispondenze di affinità delle attività. L'exploit dipende dalla capacità dell'app dell'aggressore di imitare l'affinità delle attività dell'app bersaglio, inducendo con l'inganno il sistema Android a lanciare l'app dell'aggressore invece del bersaglio previsto.


#. Passaggi di attacco dettagliati
- Installazione di app dannose : la vittima installa l'app dell'aggressore sul proprio dispositivo.

- Attivazione iniziale : la vittima apre innanzitutto l'app dannosa, configurando il dispositivo per l'attacco.

- Tentativo di avvio dell'app di destinazione : la vittima tenta di aprire l'app di destinazione.

- Esecuzione del dirottamento : a causa dell'affinità delle attività corrispondenti, l'app dannosa viene avviata al posto dell'app di destinazione.

- Inganno : l'app dannosa presenta una schermata di accesso falsa simile all'app di destinazione, inducendo l'utente a inserire informazioni sensibili.


https://github.com/az0mb13/Task_Hijacking_Strandhogg

Per prevenire tali attacchi, gli sviluppatori possono impostare taskAffinity una stringa vuota e optare per la singleInstance launchMode, garantendo l'isolamento della propria app dagli altri. La personalizzazione della onBackPressed()funzione offre una protezione aggiuntiva contro il dirottamento delle attività.




#. Archiviazione dei dati non sicura.
In Android, i file archiviati nella memoria interna sono progettati per essere accessibili esclusivamente dall'app che li ha creati . Questa misura di sicurezza viene applicata dal sistema operativo Android ed è generalmente adeguata alle esigenze di sicurezza della maggior parte delle applicazioni. Tuttavia, gli sviluppatori a volte utilizzano modalità come MODE_WORLD_READABLE e MODE_WORLD_WRITABLEper consentire la condivisione dei file tra diverse applicazioni. Tuttavia, queste modalità non limitano l'accesso a questi file da parte di altre applicazioni, comprese quelle potenzialmente dannose.

- Analisi statica:
Assicurarsi che l'uso di MODE_WORLD_READABLEe MODE_WORLD_WRITABLEsia attentamente esaminato . Queste modalità possono potenzialmente esporre i file ad accessi involontari o non autorizzati .

- Analisi dinamica:
Verifica le autorizzazioni impostate sui file creati dall'app. In particolare, controlla se alcuni file sono impostati per essere leggibili o scrivibili in tutto il mondo . Ciò può rappresentare un rischio significativo per la sicurezza, poiché consentirebbe a qualsiasi applicazione installata sul dispositivo, indipendentemente dalla sua origine o intenzione, di leggere o modificare questi file.





#. Data Sensitive Storage in text without cryptography

- SharedPrefs: 
Android consente a ciascuna applicazione di salvare facilmente file xml nel percorso /data/data/<packagename>/shared_prefs/e talvolta è possibile trovare informazioni sensibili in testo non crittografato in quella cartella.

- Database: 
Android consente a ciascuna applicazione di salvare facilmente i database SQLite nel percorso /data/data/<packagename>/databases/e talvolta è possibile trovare informazioni sensibili in testo non crittografato in quella cartella.




#. Broken TLS:
Per qualche motivo a volte gli sviluppatori accettano tutti i certificati anche se ad esempio il nome host non corrisponde a righe di codice come quella seguente:

SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);



#. Broken Cryptography:
Alcuni sviluppatori salvano i dati sensibili nella memoria locale e li crittografano con una chiave codificata/prevedibile nel codice. Ciò non dovrebbe essere fatto poiché alcune inversioni potrebbero consentire agli aggressori di estrarre informazioni riservate.

Utilizzo di algoritmi non sicuri e/o deprecati

Gli sviluppatori non devono utilizzare algoritmi deprecati per eseguire controlli di autorizzazione , archiviare o inviare dati. Alcuni di questi algoritmi sono: RC4, MD4, MD5, SHA1... Se gli hash vengono utilizzati per archiviare le password, ad esempio, gli hash resistenti alla forza bruta dovrebbero essere utilizzati con salt.





#. Altri controlli:
- Offuscare l'APK
- Verificare se il cell è rootato
- Verificare se viene utilizzato un emulatore
- Verificare la propria integrità usando pinning
- Utilizza APKid per verificare quale compilatore/offuscatore è stato utilizzato per creare l'APK

gives you information about how an APK was made. It identifies many compilers, packers, obfuscators, and other weird stuff




# React Native:
Per verificare se l'applicazione è stata creata sul framework React Native, attenersi alla seguente procedura:

Rinomina il file APK con estensione zip ed estrailo in una nuova cartella utilizzando il comando cp com.example.apk example-apk.zipe unzip -qq example-apk.zip -d ReactNative.

Passare alla cartella ReactNative appena creata e individuare la cartella delle risorse. All'interno di questa cartella dovresti trovare il file index.android.bundle, che contiene React JavaScript in un formato ridotto.

Utilizza il comando find . -print | grep -i ".bundle$"per cercare il file JavaScript.

Per analizzare ulteriormente il codice JavaScript, crea un file denominato index.htmlnella stessa directory con il seguente codice:


<script src="./index.android.bundle"></script>
Puoi caricare il file su https://spaceraccoon.github.io/webpack-exploder/ o seguire questi passaggi:

Apri il index.htmlfile in Google Chrome.

Apri la barra degli strumenti per sviluppatori premendo Comando+Opzione+J per OS X o Control+Maiusc+J per Windows .

Fai clic su "Sorgenti" nella barra degli strumenti per sviluppatori. Dovresti vedere un file JavaScript suddiviso in cartelle e file, che costituiscono il pacchetto principale.

Se trovi un file chiamato index.android.bundle.map, sarai in grado di analizzare il codice sorgente in un formato non minimizzato. I file di mappa contengono la mappatura dell'origine, che consente di mappare identificatori minimizzati.

Per cercare credenziali ed endpoint sensibili, attenersi alla seguente procedura:

Identificare le parole chiave sensibili per analizzare il codice JavaScript. Le applicazioni React Native utilizzano spesso servizi di terze parti come Firebase, endpoint del servizio AWS S3, chiavi private, ecc.

In questo caso specifico, è stato osservato che l'applicazione utilizzava il servizio Dialogflow. Cerca un modello relativo alla sua configurazione.

È stata una fortuna che durante il processo di ricognizione siano state trovate credenziali hardcoded sensibili nel codice JavaScript.








#. Bypassing Biometric Authentication:
Collegandosi ai metodi onAuthenticationSucceeded, onAuthenticationFailed, o onAuthenticationErrordi BiometricPrompt.AuthenticationCallback, è possibile controllare l'esito del processo di autenticazione dell'impronta digitale.


#. Metodo 1 – Bypass senza utilizzo di oggetti crittografici
L'attenzione qui è sul callback onAuthenticationSucceeded , che è cruciale nel processo di autenticazione. I ricercatori di WithSecure hanno sviluppato uno script Frida , consentendo il bypass del NULL CryptoObject in onAuthenticationSucceeded(...) . Lo script impone un bypass automatico dell'autenticazione tramite impronta digitale all'invocazione del metodo. Di seguito è riportato uno snippet semplificato che mostra il bypass in un contesto Android Fingerprint


frida -U -f com.generic.insecurebankingfingerprint --no-pause -l fingerprint-bypass.js



#. Metodo 2 - Approccio alla gestione delle eccezioni:
Un altro script Frida di WithSecure risolve il problema dell'utilizzo non sicuro di oggetti crittografici. Lo script invoca onAuthenticationSucceeded con un CryptoObject che non è stato autorizzato da un'impronta digitale. Se l'applicazione tenta di utilizzare un oggetto di crittografia diverso, attiverà un'eccezione. Lo script si prepara a richiamare onAuthenticationSucceeded e a gestire javax.crypto.IllegalBlockSizeException nella classe Cipher , garantendo che gli oggetti successivi utilizzati dall'applicazione vengano crittografati con la nuova chiave.

frida -U -f com.generic.insecurebankingfingerprint --no-pause -l fingerprint-bypass-via-exception-handling.js


#. Metodo 3 - Strumentazione Strumentazione:
I framework di strumentazione come Xposed o Frida possono essere utilizzati per collegarsi ai metodi dell'applicazione in fase di runtime. Per l'autenticazione delle impronte digitali, questi framework possono:
Simulazione delle richiamate di autenticazione - Bypass SSL Pinning
frida -U -l script-to-bypass-authentication.js --no-pause -f com.generic.in


#. Metodo 4 - Reverse Engineering:
- Decompilazione APK
- Analisi del codice
- Ricompilazione APK


#. Metodo 5 - Strumenti autenticazione personalizati:
- Modulo MAGISK per roottare il dispositivo e modificare informazioni a livello hardware, comprese impronte digitali
- Script personalizzati


###. Altre funzioni utili interessanti:
- Esecuzione del codice :Runtime.exec(), ProcessBuilder(), native code:system()
- Invia SMS :sendTextMessage, sendMultipartTestMessage
- Funzioni native dichiarate come native:public native, System.loadLibrary, System.load

```



```
###. Dynamic Analysis:


#. Appetize.io
Tools utilizzato per caricare ed eseguire un APK e leggere i log dell'appliazione sul web e connetterti tramite ADB (ADB + Drozer - ADB + Frida)

#. Android Studio:
Utilizzare direttamente Android Studio

#. Genymotion o Nox



#. Monitoring Application:
Pidcat + ADB Logcat per visualizzare i log applicativi


#. DB SQLite:
Verificare presenza di database SQLite interni per salvare informazioni.
/data/data/the.package.name/databases




# Drozer:
Drozer ti consente di assumere il ruolo di un'app Android e interagire con altre app. Può fare tutto ciò che può fare un'applicazione installata , come utilizzare il meccanismo IPC (Inter-Process Communication) di Android e interagire con il sistema operativo sottostante. . Drozer è uno strumento utile per sfruttare attività esportate, servizi esportati e fornitori di contenuti come imparerai nelle sezioni seguenti.



#. Activity Exported:
Quando un'attività viene esportata, puoi richiamare il suo schermo da un'app esterna. Pertanto, se viene esportata un'attività con informazioni sensibili , potresti bypassare i meccanismi di autenticazione per accedervi.

Avviare activity exported from adb:
> adb shell am start -n com.example.package/com.example.test.MainActivity

Le attività possono anche restituire risultati . Se riesci a trovare un'attività esportata e non protetta che chiama il setResult metodo e restituisce informazioni sensibili , si verifica una perdita di informazioni sensibili.

#. TapJacking - Activity:
Se il tapjacking non viene impedito, potresti abusare dell'attività esportata per indurre l' utente a eseguire azioni inaspettate.





###. Content Provider:
Testing SQLInjection e Path Traversal sui Content Provider.




#. Service Exported
Ricorda che le azioni di un Service iniziano nel metodo onStartCommand.
Inside the code check for the handleMessage function which will receive the message:

Interaction with Services - Drozer:
<service android:name=".AuthService" android:exported="true" android:process=":remote"/>



###. Drozer


# List Packages:
dz> run app.package.list -f app.package
[com.app.package]

# Basic Information of the package:
dz> run app.package.info -a com.app.package


# Attack Surface of the package:
dz> run app.package.attacksurface com.app.package
[ Attack Surface:
 3 activities exported
 0 broadcast receivers exported
 2 content providers exported
 2 services exported
 is debuggable ]

Activity? Maybe u can start an activity and bypass authorization
Content Providers? Maybe u can access private data or exploit some vulnerabilities
Service?
Is Debuggable?



#. Drozer - Activity
<activity android:name="com.my.app.Initial" android:exported="true">
</activity>

dz> run app.activity.info -a com.mwr.example.sieve
[ Package: com.mwr.example.sieve
 com.mwr.example.sieve.FileSelectActivity
 com.mwr.example.sieve.MainLoginActivity
 com.mwr.example.sieve.PWList ]

#Start Activity
dz> run app.activity.start --component com.mwr.example.sieve com.mwr.example.sieve.PWList
#or from ADB:
adb shell am start -n com.example.demo/com.example.test.MainActivity
adb am start -n #app package/component
-a android.intent.action.MAIN #Action details
-c android.intent.category.LAUNCHER #Category





#. Drozer - Service:
<service android:name=".AuthService" android:exported="true" android:process=":remote"/>
Inside the code check for the **handleMessage**function which will receive the message:

app.service.info            Info Service
app.service.send            Send a Message to a service, and display the reply  
app.service.start           Start Service                                       
app.service.stop            Stop Service


Drozer - List Service Info:
dz> run app.service.info -a com.mwr.example.sieve 
Package: com.mwr.example.sieve
  com.mwr.example.sieve.AuthService
    Permission: null
  com.mwr.example.sieve.CryptoService
    Permission: null




Drozer - Send Message to Service:
Nota che invierai prima i dati all'interno di " msg.what ", poi " msg.arg1 " e " msg.arg2 ", dovresti controllare all'interno del codice quali informazioni vengono utilizzate e dove. Usando l' --extraopzione puoi inviare qualcosa interpretato da " msg.replyTo" e usando --bundle-as-objpuoi creare e obiettare con i dettagli forniti.

Nell'esempio seguente:
what == 2354
arg1 == 9234
arg2 == 1
replyTo == object(string com.mwr.example.sieve.PIN 1337)


run app.service.send com.mwr.example.sieve com.mwr.example.sieve.AuthService --msg 2354 9234 1 --extra string com.mwr.example.sieve.PIN 1337 --bundle-as-obj





###. Drozer - Broadcast Receiver:
Dopo aver scoperto questi ricevitori di trasmissione dovresti controllarne il codice . Presta particolare attenzione alla onReceive funzione poiché gestirà i messaggi ricevuti.


#. Drozer - List Broadcast Receiver:
app.broadcast.info          Get information about broadcast receivers           
app.broadcast.send          Send broadcast using an intent                      
app.broadcast.sniff         Register a broadcast receiver that can sniff particular intents

Es. 
dz> run app.broadcast.info -a my.app.package


Es. Utilizzo un BroadcastReceivers per inviare un SMS a qualsiasi destinazione senza chiedere il permesso all'utente.
https://github.com/linkedin/qark/blob/master/tests/goatdroid.apk

Ho il mio Receivers Send SMS Now Receiver, che è in ascolto da azioni provenienti da "SOCIAL_SMS", leggo il codice del Receiver ed il metodo onReceive ed invio l'action.

<receiver android:label"Send SMS" android:name=".broadcastreceivers.SendSMSNowReceiver">
<intent-filter>
<action android:name= org.owasp.goatdroid.fourgats.SOCIAL_SMS" />
</intent-filter>
</receiver>

run app.broadcast.send --action org.owasp.goatdroid.fourgoats.SOCIAL_SMS --component org.owasp.goatdroid.fourgoats.broadcastreceivers SendSMSNowReceiver --extra string phoneNumber 123456789 --extra string message "Hello mate!"

ADB Manual - Broadcast Receivers - 
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]




## Drozer - Content Providers:





#. Debugging - APK
E' possibile debuggare l'APK se attivato il flag, e collegare un debugger Java all'applicazione in esecuzione.
Solitamente il flag, è settato nel manifest:
<application theme="@2131296387" debuggable="true"


##. Drozer:
run app.package.debuggable   # Check App Debuggable

Tutorial:
https://book.hacktricks.xyz/mobile-pentesting/android-app-pentesting/exploiting-a-debuggeable-applciation

https://resources.infosecinstitute.com/android-penetration-tools-walkthrough-series-drozer/#gref

https://github.com/mgcfish/mobiletools/blob/master/_posts/2016-08-01-Using-Drozer-for-application-security-assessments.md

https://www.hackingarticles.in/android-penetration-testing-drozer/

https://medium.com/@ashrafrizvi3006/how-to-test-android-application-security-using-drozer-edc002c5dcac









```

```
### Debugging:

Check Manifest - debugging 
#or 
run app.package.debuggable   # Check App Debuggable


```


```
Report App - HackerOne:
https://hackerone.com/reports/855618


```