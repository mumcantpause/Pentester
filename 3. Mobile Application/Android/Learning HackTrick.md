

https://book.hacktricks.xyz/mobile-pentesting/android-checklist
https://book.hacktricks.xyz/mobile-pentesting/android-app-pentesting



```
###. Android Applications Basics:

Condivisione UID:
Applicazioni nel manifest devono avere lo stesso android:sharedUserId


Ambiente sicuro utilizzando Sandboxing per ciascuna applicazione.
Ad ogni applicazione viene applicato SELinux, che nega l'interazione tra processi non previste.


APK Contents (Not exhaustive)
- AndroidManifest.xml
- resources.arsc/strings.xml
- resources.arsc: contains precompiled resources, like binary XML.
	res/xml/files_paths.xml
- META-INF/This is where the Certificate is located!
- classes.dex: Contains Dalvik bytecode, representing the compiled Java (or Kotlin) code that the application executes by default.
- lib/
	Houses native libraries, segregated by CPU architecture in subdirectories.
	- armeabi: code for ARM based processors
	- armeabi-v7a: code for ARMv7 and higher based processors
	- x86: code for X86 processors
	- mips: code for MIPS processors only
- assets/
	- Stores miscellaneous files needed by the app, potentially including additional native libraries or DEX files, sometimes used by malware authors to conceal additional code.
- res/
Contains resources that are not compiled into resources.arsc


```



### Learn Android Fundamentals
```
###. ADB


Windows:
C:\Users\<username>\AppData\Local\Android\sdk\platform-tools\adb.exe

> adb devices
> adb -s "emulator" shell
> adb connect <IP>:<PORT>
> adb install -s test.apk   #install application on sdcard
> adb push test.apk /storage/emulated/0/Download
> adb push test.apk /sdcard
> adb uninstall <com.test.app>
> adb shell pm list packages <FILTER-STR>



Print the path to the APK:
> adb shell pm path <com.android.phone>
> adb shell pm clear <com.android.phone>


Taking a screenshot of a device display:
> adb shell screencap /sdcard/screen.png


PM - Command:
#List installed packages:
> pm list packages 

#Get the path to the apk file of tha package
> pm path <package name> 

#Start an activity. Whiout options you can see the help menu
> am start [<options>]

#Start a service. Whiout options you can see the help menu:
> am startservice [<options>] 

#Send a broadcast. Whiout options you can see the help menu:
am broadcast [<options>]

#Send keystrokes to device:
input [text|keyevent] 


ADB - Processes:
> adb shell pidof com.your.application [PID]
> adb shell ps [PID]




ADB - Logcat:
> adb logcat | grep 4526 (pid)
> adb logcat | findstr 4526 (pid)



> adb logcat *:V   #Lowest priority, filter to only show Verbose level
> adb logcat *:W   #Filter to only show Warning level
> adb logcat *:E   #Filter to only show Error level
> adb logcat *:F   #Filter to only show Fatal level
> adb logcat *:S   #Silent, highest priority, on which nothing is ever printed

> adb logcat *:E -f /data/local/tmp/log.txt
> adb locat -c    #Clear Log

> adb backup [-apk] [-shared] [-system] [-all] -f file.backup
> adb backup -f myapp_backup.ab -apk com.myapp

```

```
###. Smali

#. Fast Way:
Visual Studio Code + APKLab extensions u can automaticallyu decompile, modify, recompile, sign & install the application without executing any command.
Change Smali Code:
Using VS Code, install smalise extension with debugging editor enabled
After u must compile and sign APK

- Other Scripts: 
https://github.com/ax/apk.sh


#. Manual - Decompiling:
> apktool d APP.apk  (if error try with -r and dont decode resources - update lastest version)
[res/values/strings.xml]
[AndroidManifest.xml]
[.sqlite or .db]


#. Recompile the APK:
> apktool b . #In the folder generated when you decompiled the application


#. Sign the new APK:
La firma delle APK (Android Package) con una chiave è un passaggio cruciale per garantire l'integrità e la sicurezza delle applicazioni Android. Ecco alcuni motivi per cui è necessario firmare le APK con una chiave:

1. Verifica dell'autenticità: La firma con una chiave privata garantisce che l'APK provenga da una fonte attendibile. Quando un utente installa o aggiorna un'app, il sistema Android verifica la firma dell'APK utilizzando il certificato pubblico associato alla chiave privata. Se la firma corrisponde, l'aggiornamento viene accettato.

2. Prevenzione di modifiche non autorizzate: La firma impedisce modifiche non autorizzate all'APK. Se qualcuno tenta di alterare il codice o i contenuti dell'APK, la firma non corrisponderà e l'installazione verrà bloccata.

3. Gestione delle versioni: Per consentire l'aggiornamento di un'app, deve essere firmata con la stessa chiave utilizzata per la versione precedente. Questo garantisce che gli utenti ricevano solo aggiornamenti da fonti attendibili.

4. Distribuzione su Google Play: Per pubblicare un'app su Google Play, è obbligatorio firmarla con una chiave. Google Play gestisce automaticamente la chiave di firma dell'app e la utilizza per firmare gli APK di distribuzione ottimizzati generati dagli app bundle. Questo processo migliora la sicurezza e semplifica la gestione delle chiavi.



Then, you need to generate a key:
> keytool -genkey -v -keystore key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias <your-alias>

Sign the APK:
> jarsigner -keystore key.jks path/to/dist/* <your-alias>


#. Optimize new application:
Zipalign is an archive alignment tool that provides important optimisation to Android application (APK) files.
> zipalign [-f] [-v] <alignment> infile.apk outfile.apk
> zipalign -v 4 infile.apk

Estract APK from device:
> adb shell pm list packages
> adb shell pm path com.android.insecurebankv2
> adb pull /data/app/com.android.insecurebankv2- Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

Utils - Download APK:
https://apps.evozi.com/apk-downloader/
https://apkcombo.com/es-es/apk-downloader/
https://apkpure.com/es
https://www.apkmirror.com

```


```
###. Static Analysis:

#. APK Decompilers
- JD-GUI
- JADX:
To specify an output directory or adjust decompilation options: jadx app.apk -d <path to output dir> --no-res --no-src --no-imports
- ByteCode-Viewer


#. Tools - Leak Info:
Apkurlgrep:
Search for api keys, encryption, bluetooth uuids, tokens

Firebase - Bad Configuration:

###. Common Vulnerabilities:

#. Debuggable Applications:
le applicazioni impostate come debuggabili ( `debuggable="true"`) nel file _Manifest.xml_ rappresentano un rischio poiché consentono connessioni che possono portare allo sfruttamento. Per ulteriori informazioni su come sfruttare le applicazioni di cui è possibile eseguire il debug, fare riferimento a un tutorial su come trovare e sfruttare le applicazioni di cui è possibile eseguire il debug su un dispositivo.



#. Backup Configuration:
l' `android:allowBackup="false"`attributo deve essere impostato esplicitamente per le applicazioni che trattano informazioni sensibili per impedire backup di dati non autorizzati tramite adb, in particolare quando è abilitato il debug USB


#. Security Netowrk
le configurazioni di sicurezza di rete personalizzate ( android:networkSecurityConfig="@xml/network_security_config") in res/xml/ possono specificare dettagli di sicurezza come pin del certificato e impostazioni del traffico HTTP. Un esempio è consentire il traffico HTTP per domini specifici.


#. Activity - Service Exported:
identificare le attività e i servizi esportati nel manifest può evidenziare componenti che potrebbero essere utilizzati in modo improprio. Ulteriori analisi durante i test dinamici possono rivelare come sfruttare questi componenti.


#. Content Provider - File:
i fornitori di contenuti esposti potrebbero consentire l'accesso non autorizzato o la modifica dei dati. Anche la configurazione di FileProviders dovrebbe essere esaminata attentamente.


#. Broadcast Sender / Receiver
questi componenti potrebbero essere sfruttati per lo sfruttamento, con particolare attenzione al modo in cui gli schemi URL vengono gestiti per le vulnerabilità di input.


#. Version SDK:
gli attributi minSdkVersion, targetSDKVersione maxSdkVersionindicano le versioni Android supportate, evidenziando l'importanza di non supportare versioni Android obsolete e vulnerabili per motivi di sicurezza.


#. TapJacking:
Il tapjacking è un attacco in cui un'applicazione dannosa viene  lanciata e si posiziona sopra un'applicazione vittima . Una volta oscurata visibilmente l'app vittima, la sua interfaccia utente è progettata in modo tale da indurre l'utente a interagire con essa, mentre trasmette l'interazione all'app vittima. In effetti, impedisce all'utente di sapere che sta effettivamente eseguendo azioni sull'app vittima.

Per rilevare le app vulnerabili a questo attacco dovresti cercare le attività esportate nel manifest di Android (nota che un'attività con un filtro intent viene automaticamente esportata per impostazione predefinita). Una volta trovate le attività esportate, controlla se richiedono qualche autorizzazione . Questo perché anche l'applicazione dannosa avrà bisogno di tale autorizzazione .


Se sul button `android:filterTouchesWhenObscured`è impostato su `true, `View`non riceverà tocchi ogni volta che la finestra della vista è oscurata da un'altra finestra visibile. Se impostato su `true`, ad esempio, un pulsante può essere automaticamente disabilitato se è oscurato.

<Button android:text="Button"
android:id="@+id/button1"
android:layout_width="wrap_content"
android:layout_height="wrap_content" 
android:filterTouchesWhenObscured="true">
</Button>

https://github.com/carlospolop/Tapjacking-ExportedActivity

Puoi utilizzare qark con i parametri --exploit-apk--sdk-path /Users/username/Library/Android/sdkper creare un'applicazione dannosa per verificare possibili vulnerabilità di Tapjacking .\






#. Task Hijacking
In Android, un'attività è essenzialmente un insieme di attività con cui gli utenti interagiscono per completare un lavoro specifico, organizzato all'interno di uno stack . Questo stack ordina le attività in base a quando sono state aperte, con l'attività più recente visualizzata in alto come attività in primo piano . In qualsiasi momento, solo questa attività è visibile sullo schermo, rendendola parte dell'attività in primo piano .

Ecco una rapida ripartizione delle transizioni delle attività:

1. L'attività 1 inizia come unica attività in primo piano.

2. L'avvio dell'attività 2 spinge l'attività 1 nello stack posteriore, portando l'attività 2 in primo piano.

3. Iniziare l'Attività 3 sposta l'Attività 1 e l'Attività 2 più indietro nella pila, con l'Attività 3 ora in primo piano.

4. La chiusura dell'attività 3 riporta l'attività 2 in primo piano, mostrando il meccanismo semplificato di navigazione delle attività di Android.



Modalità di avvio
L' launchMode attributo dirige la gestione delle istanze di attività all'interno delle attività. La modalità singleTask è fondamentale per questo attacco, dettando tre scenari basati sulle istanze di attività esistenti e sulle corrispondenze di affinità delle attività. L'exploit dipende dalla capacità dell'app dell'aggressore di imitare l'affinità delle attività dell'app bersaglio, inducendo con l'inganno il sistema Android a lanciare l'app dell'aggressore invece del bersaglio previsto.


#. Passaggi di attacco dettagliati
- Installazione di app dannose : la vittima installa l'app dell'aggressore sul proprio dispositivo.

- Attivazione iniziale : la vittima apre innanzitutto l'app dannosa, configurando il dispositivo per l'attacco.

- Tentativo di avvio dell'app di destinazione : la vittima tenta di aprire l'app di destinazione.

- Esecuzione del dirottamento : a causa dell'affinità delle attività corrispondenti, l'app dannosa viene avviata al posto dell'app di destinazione.

- Inganno : l'app dannosa presenta una schermata di accesso falsa simile all'app di destinazione, inducendo l'utente a inserire informazioni sensibili.


https://github.com/az0mb13/Task_Hijacking_Strandhogg

Per prevenire tali attacchi, gli sviluppatori possono impostare taskAffinity una stringa vuota e optare per la singleInstance launchMode, garantendo l'isolamento della propria app dagli altri. La personalizzazione della onBackPressed()funzione offre una protezione aggiuntiva contro il dirottamento delle attività.




#. Archiviazione dei dati non sicura.



```



```
###. Dynamic Analysis:


```