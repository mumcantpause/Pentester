

```
#. Android Fundamental
Ogni applicazione Android, indipendentemente dalla finalità che si prefigge, affida le sue funzionalità a quattro tipi di componenti. Si tratta di Activity, Service, Content Provider e BroadcastReceiver ed esistono affinchè la nostra applicazione possa integrarsi alla perfezione nell'ecosistema Android.
Ogni app Android si trova nella propria sandbox per la sicurezza, protetta dalle seguenti funzionalità di sicurezza Android:

- Il sistema operativo Android è un sistema Linux multiutente in cui ogni app è un utente diverso.
- Per impostazione predefinita, il sistema assegna a ogni app un ID utente Linux univoco, che viene utilizzato solo dal sistema e sconosciuto all'app. Il sistema imposta le autorizzazioni per tutti i file in un'app in modo che solo l'ID utente assegnato all'app possa accedervi.
- Ogni processo ha la propria macchina virtuale (VM), quindi il codice di un'app viene eseguito in modo isolato da altre app.
- Per impostazione predefinita, ogni app viene eseguita nel proprio processo Linux. Il sistema Android avvia il processo quando è necessario eseguire uno qualsiasi dei componenti dell'app, quindi arresta il processo quando non è più necessario o quando il sistema deve recuperare memoria per altre app.



Il sistema Android implementa il principio del privilegio minimo. In altre parole, ogni app, per impostazione predefinita, ha accesso solo ai componenti necessari per svolgere il proprio lavoro e niente altro. Ciò crea un ambiente molto sicuro in cui un'app non può accedere a parti del sistema per cui non ha l'autorizzazione.

- È possibile fare in modo che due app condividano lo stesso ID utente Linux, nel qual caso saranno in grado di accedere reciproche ai file. Per risparmiare risorse di sistema, le app con lo stesso ID utente possono anche essere in grado di essere eseguite nello stesso processo Linux e condividere la stessa VM. Anche le app devono essere firmate con lo stesso certificato.
- Un'app può chiedere l'autorizzazione ad accedere a dati del dispositivo quali la posizione, la fotocamera e la connessione Bluetooth del dispositivo. L'utente deve concedere esplicitamente queste autorizzazioni. Per ulteriori informazioni sulle autorizzazioni, vedi Autorizzazioni su Android.


MyProject/
    src/
        MyActivity.java
    resources.arsc/
	    strings.xml
	    res/xml/files_paths.xml
    res/
        drawable/
            graphic.png
        layout/
            main.xml
            info.xml
        mipmap/
            icon.png
        values/
            strings.xml
    AndroidManifest.xml
    META-INF/
    lib/
    assets/


APK Contents (Not exhaustive)
- AndroidManifest.xml
- resources.arsc/strings.xml
- resources.arsc: contains precompiled resources, like binary XML.
	res/xml/files_paths.xml
- META-INF/This is where the Certificate is located!
- classes.dex: Contains Dalvik bytecode, representing the compiled Java (or Kotlin) code that the application executes by default.
- lib/
	Houses native libraries, segregated by CPU architecture in subdirectories.
	- armeabi: code for ARM based processors
	- armeabi-v7a: code for ARMv7 and higher based processors
	- x86: code for X86 processors
	- mips: code for MIPS processors only
- assets/
	- Stores miscellaneous files needed by the app, potentially including additional native libraries or DEX files, sometimes used by malware authors to conceal additional code.
- res/
Contains resources that are not compiled into resources.arsc




#. Activity:
Un'Activity è un'interfaccia utente. Ogni volta che si usa un'app generalmente si interagisce con una o più "pagine" mediante le quali si consultano dati o si immettono input. Ovviamente la realizzazione di Activity è il punto di partenza di ogni corso di programmazione Android visto che è il componente con cui l'utente ha il contatto più diretto.
Le Activity nel loro complesso costituiscono il flusso in cui l'utente si inoltra per sfruttare le funzionalità messe a disposizione. Questo richiede pertanto non solo la realizzazione delle interfacce in sé stesse, ma anche una corretta progettazione della navigazione tra di esse offrendo la possibilità di sfogliarne i contenuti e risalirli gerarchicamente in maniera coerente.
Un'altra app può avviare una qualsiasi di queste attività, se l'app email lo consente. Ad esempio, un'app fotocamera potrebbe avviare l'attività nell'app email per scrivere una nuova email e consentire all'utente di condividere una foto.



#. Service:
Un Service svolge un ruolo, se vogliamo, opposto all'Activity (sebbene, a livello di ereditarietà di classe siano imparentati). Infatti rappresenta un lavoro – generalmente lungo e continuato - che viene svolto interamente in background senza bisogno di interazione diretta con l'utente. Ad esempio, un'app che permette di avviare un audio che non si interrompe alla chiusura della sua interfaccia con tutta probabilità basa il suo funzionamento su un Service.
I loro usi sono dei più disparati e, a seconda dei casi, l'utente potrebbe anche non notare il loro avvio ottenendone però i benefici. Da una punto di vista strutturale, i Service sono di due tipologie: started e bounded. 
Un servizio è un punto di contatto generico che consente di mantenere un'app in esecuzione in background per tutti i tipi di motivi. È un componente che viene eseguito in background per eseguire operazioni a lunga esecuzione o per lavorare per processi remoti. Un servizio non fornisce un'interfaccia utente.
Ad esempio, un servizio potrebbe riprodurre musica in background mentre l'utente si trova in un'altra app oppure recuperare dati tramite la rete senza bloccare l'interazione dell'utente con un'attività. Un altro componente, ad esempio un'attività, può avviare il servizio e lasciarne l'esecuzione o l'associazione per interagirvi.

#. Service Started:
I Service Started, vengono attivati quando un'app ha bisogno di svolgere attività in background, mirate ad uno scopo specifico, fino al loro completamento.
Service Started avviate startService(), non hanno interazione e proseguono finchè non vengono interrotti.
I Service Started sono da predilligere per operazioni con una loro finalità indipendente dallo stato delle altre applicazioni. Si potrebbero occupare di aggiornamenti dati in background, scaricamento di file o immagini, sincronizzazione remota verso server esterni, etc. Considerando che il service Started rimarrà in background a lungo la sua esistenza deve essere giustificata dalla finalità preposta.

I Servizi Started indicano al sistema di mantenerli in esecuzione fino al completamento del lavoro. Potrebbe essere necessario sincronizzare alcuni dati in background o riprodurre musica anche dopo che l'utente è uscito dall'app. La sincronizzazione dei dati in background o la riproduzione di musica rappresentano diversi tipi di servizi avviati, che il sistema gestisce in modo diverso:

La riproduzione di musica è qualcosa di cui l'utente è direttamente a conoscenza e l'app comunica ciò al sistema indicando che vuole essere in primo piano, con una notifica per comunicare all'utente che è in esecuzione. In questo caso, il sistema dà la priorità a mantenere il processo del servizio in esecuzione, perché l'utente ha un'esperienza negativa se scompare.
L'utente non è a conoscenza direttamente di un normale servizio in background, pertanto il sistema ha maggiore libertà nella gestione del processo. Potrebbe essere interrotto, riavviando il servizio in un secondo momento, se ha bisogno di RAM per attività di interesse più immediato per l'utente.




#. Service Bounded:
I Service Bounded, vengono attivati solo nel caso in cui un'altra app abbia bisogno di connettersi a loro. Si tratta di un tipo di Service che permette l'interazione tra processi differenti e risponde ad una logica simile a quella delle API nei servizi web.
Service Bound vivono in modalità client-server. Hanno senso se qualche componente si collega e vengono interrotti solo se non ci sono piu client collegati.
I Service Bound svolgono il ruolo di supporto ad altre applicazioni. Non rischiano pertanto di essere “dimenticati” in background come potrebbe malauguratamente succedere agli Started ma non sono adatti a lavori da eseguire continuamente in background.

Chi gestisce tutti i dati relativi all'attività da svolgere mediante il JobScheduler è un oggetto JobInfo in cui sono specificate tutte le condizioni che determinano l'avvio del task. I passi che permettono di attivare un'attività asincrona sono:

- definizione di una classe derivata da JobService in cui verranno specificate le attività da svolgere in maniera asincrona;
- creazione di un oggetto JobInfo cui sarà collegato il JobService del punto precedente;
inserimento del JobInfo nello JobScheduler mediante l'invocazione del metodo schedule;
- attivazione del task asincrono non appena i criteri specificati nel JobInfo saranno soddisfatti.

Si noti inoltre che anche questo settore è stato rivoluzionato negli anni, in particolare con la nascita dei JobScheduler che permettono lavori in background con un uso parsimonioso della batteria.

I servizi associati vengono eseguiti perché un'altra app (o il sistema) ha dichiarato di voler utilizzare il servizio. Un servizio associato fornisce un'API a un altro processo e il sistema sa che esiste una dipendenza tra questi processi. Quindi, se il processo A è associato a un servizio nel processo B, il sistema sa che deve mantenere il processo B e il suo servizio in esecuzione per A. Inoltre, se l'utente è interessato al processo A, sa che deve trattare il processo B come un aspetto che interessa anche all'utente.







#. Content Provider:
Un Content Provider nasce con lo scopo della condivisione di dati tra applicazioni. La sua finalità richiama quel principio di sicurezza dell'applicazione di cui si è trattato poco fa. Questi componenti permettono di condividere, nell'ambito del sistema, contenuti custoditi in un database, su file o reperibili mediante accessi in Rete. Tali contenuti potranno essere usati da altre applicazioni senza invadere lo spazio di memoria ma stabilendo quel dialogo “sano” cui si è accennato.
I Content Provider sono riconoscibili mediante un URI, un riferimento univoco. Questi indirizzi sono costituiti da due parti:
- authority: è il nome del Provider in generale. Spesso, per evitare conflitti, richiama il nome del package Java di appartenenza.
- path: costituisce un percorso interno alla singola authority. Spesso rappresenta una tabella del database cui si vuole accedere ma, in generale, indica la tipologia di dati su cui agire.

ContentProvider molto noti del sistema opearativo sono:
- Contacts: include tutte le informazioni sui contatti dell'utente: rubrica telefonica, email, etc.
- MediaStore: gestisce dati relativi a file multimediali contenuti nel sistema tra cui file audio, immagini e video;
- UserDictionary: si occupa delle parole aggiunte dall'utente al dizionario di default;
- Calendar: serve a gestire appuntamenti ed eventi sul calendario del dispositivo eventualmente sincronizzato con l'account Google.



#. Broadcast Receiver:
Un Broadcast Receiver è un componente che reagisce ad un invio di messaggi a livello di sistema (appunto in broadcast), con cui Android notifica l'avvenimento di un determinato evento, ad esempio l'arrivo di un SMS o di una chiamata o sollecita l'esecuzione di azioni. Questi componenti come si può immaginare sono particolarmente utili per la gestione istantanea di determinate circostanze speciali.
I Broadcast Receiver non utilizzano interfaccia grafica sebbene possano inoltrare notifiche alla barra di stato per avvisare l'utente dell'avvenimento.
Inoltre la loro esecuzione dovrebbe essere istantanea delegando a Service o JobScheduler eventuali operazioni da attivare.

Un ricevitore di trasmissione è un componente che consente al sistema di inviare eventi all'app al di fuori del normale flusso di utenti, in modo che l'app possa rispondere agli annunci di trasmissione a livello di sistema. Poiché i ricevitori sono un altro strumento ben definito per l'app, il sistema può inviare trasmissioni anche ad app non attualmente in esecuzione.
Ad esempio, un'app può programmare una sveglia per pubblicare una notifica e informare l'utente di un evento imminente. Poiché la sveglia viene inviata a un numero BroadcastReceiver nell'app, non è necessario che l'app rimanga in esecuzione fino a quando l'allarme non suona.

Molte trasmissioni provengono dal sistema, ad esempio un annuncio che annuncia che lo schermo è spento, che la batteria è in esaurimento o che viene acquisita una foto. Le app possono anche avviare trasmissioni, ad esempio per comunicare ad altre app che alcuni dati vengono scaricati sul dispositivo e possono essere utilizzati.

Anche se i ricevitori non mostrano un'interfaccia utente, possono creare una notifica nella barra di stato per avvisare l'utente quando si verifica un evento di trasmissione. Tuttavia, più comunemente, un ricevitore di trasmissione è solo un gateway per altri componenti ed è progettato per svolgere un lavoro minimo.

Ad esempio, un ricevitore di trasmissione potrebbe programmare un JobService per eseguire alcune operazioni in base a un evento utilizzando JobScheduler. I ricevitori di trasmissioni spesso coinvolgono le app che interagiscono tra loro, quindi è importante essere consapevoli delle implicazioni di sicurezza durante la loro configurazione.

Un ricevitore di trasmissione è implementato come una sottoclasse di BroadcastReceiver e ogni trasmissione viene pubblicata come oggetto Intent. Per ulteriori informazioni, consulta il corso BroadcastReceiver.





#. Intent:
Molto importante ricordare che una componente può attivarne un'altra mediante apposite invocazioni di sistema. Questa intenzione viene codificata con un Intent utilizzabile come normale classe Java ma che sottintende un potentissimo strumento di comunicazione di Android. Anche degli Intent faremo uso sin dai prossimi articoli.

Un messaggio asincrono chiamato intent attiva tre dei quattro tipi di componenti: attività, servizi e ricevitori di trasmissione. Gli intent associano tra loro singoli componenti in fase di runtime. Possono essere considerati come i messaggeri che richiedono un'azione da altri componenti, indipendentemente dal fatto che il componente appartenga alla tua app o a un'altra.

Un intent viene creato con un oggetto Intent, che definisce un messaggio per attivare un componente specifico (un intent esplicito) o un tipo specifico di componente (un intent implicito).

Per attività e servizi, un intent definisce l'azione da eseguire, ad esempio visualizzare o inviare qualcosa, e potrebbe specificare l'URI dei dati su cui agire, tra le altre cose che il componente avviato potrebbe dover essere a conoscenza.

Ad esempio, un intent potrebbe trasmettere una richiesta di un'attività per mostrare un'immagine o aprire una pagina web. In alcuni casi, puoi avviare un'attività per ricevere un risultato. In questo caso l'attività restituisce anche il risultato in un Intent. Puoi anche emettere un intent per consentire all'utente di scegliere un contatto personale e di restituirlo. L'intent di ritorno include un URI che rimanda al contatto scelto.

Per i ricevitori, l'intent definisce l'annuncio di trasmissione. Ad esempio, un annuncio trasmesso per indicare che la batteria del dispositivo è in esaurimento, include solo una stringa di azioni nota che indica che la batteria è in esaurimento.

A differenza di attività, servizi e ricevitori di trasmissioni, i fornitori di contenuti vengono attivati quando vengono scelti come target da una richiesta di un ContentResolver. Il sistema di risoluzione dei contenuti gestisce tutte le transazioni dirette con il fornitore di contenuti e il componente che esegue le transazioni con il fornitore chiama i metodi sull'oggetto ContentResolver. Questo lascia un livello di astrazione per motivi di sicurezza tra il fornitore di contenuti e il componente che richiede le informazioni.

Esistono diversi metodi per attivare ciascun tipo di componente:

Puoi iniziare un'attività o impartire qualcosa di nuovo passando un Intent a startActivity() oppure, quando vuoi che l'attività restituisca un risultato, startActivityForResult().
Su Android 5.0 (livello API 21) e versioni successive, puoi utilizzare la classe JobScheduler per pianificare le azioni. Per le versioni precedenti di Android, puoi avviare un servizio o dare nuove istruzioni a un servizio in corso trasferendo Intent a startService(). Puoi eseguire l'associazione al servizio passando un Intent a bindService().
Puoi avviare una trasmissione passando un Intent a metodi quali sendBroadcast() o sendOrderedBroadcast().
Puoi eseguire una query a un fornitore di contenuti chiamando query() su un ContentResolver.
Per ulteriori informazioni sull'utilizzo degli intent, consulta il documento Intent e filtri di intent. I seguenti documenti forniscono ulteriori informazioni sull'attivazione di componenti specifici: Introduzione alle attività, Panoramica dei servizi, BroadcastReceiver e Fornitori di contenuti.

I processi possono essere classificati, in ordine di importanza decrescente, come:

- Processi in "foreground": sono quelli che  interagiscono direttamente o indirettamente con l'utente. Stiamo parlando delle applicazioni che, ad esempio,  contengono l'Activity attualmente utilizzata o i Service ad essa collegati. Questi sono i processi che Android tenterà di preservare maggiormente. Importante notare che, comunque, anche le applicazioni in foreground non sono del tutto al sicuro. Se ad esempio il sistema non disponesse di risorse sufficienti a mantenerli tutti in vita, si troverebbe costretto ad arrestarne qualcuno;

- Processi visibili: non sono importanti come quelli in foreground ma vengono anch'essi grandemente tutelati da Android. Infatti, avendo componenti ancora visibili all'utente anche se non vi interagiscono più, svolgono comunque un ruolo particolarmente critico. Anche in questo caso si tratta di Activity visibili e Service ad esse collegati;

- Processi "service": contengono dei service in esecuzione che generalmente svolgono lavori molto utili all'utente anche se non direttamente collegati con ciò che egli vede nel display. Il loro livello di priorità può essere considerato medio: importanti sì ma non tanto quanto i processi di cui ai precedenti due punti;

- Processi "cached": sono l'ultima categoria e rappresentano processi che non servono più a nulla. Tra questi vengono selezionati quelli da abbattere e finché il sistema operativo non affronta una fase di difficoltà non ha bisogno di eliminare processi di altre categorie se non di questa. I cached process eliminati non rischiano di impattare minimamente sulla user experience e spesso contengono Activity che non sono più visibili.



#. Directory Structure:
L'architettura di progetto così impostata è costituita da un certo numero di file e cartelle.
Tutti sono importanti ma gli elementi tra i quali il programmatore dovrà sapersi muovere al più presto con scioltezza sono:
• la cartella "src" che conterrà tutto il codice Java che scriveremo.
• la cartella "res" in cui risiederanno le cosiddette risorse dell'applicazione per la maggior parte configurate in XML ma non solo.
• il file "AndroidManifest.xml" anch'esso in XML che custodirà configurazioni e ruoli dei componenti della nostra app.







###. Fundamental Details:


#. Activity - Interfaccia utente:
Il codice Java che realizza l'Activity risiede nella cartella src, come spiegato in precedenza. Il contenuto di un tipico “Hello world” potrebbe essere questo:

public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}
La classe si chiama MainActivity ed estende AppCompatActivity. Al suo interno viene implementato l'override del metodo onCreate. Per il momento, ci accontentiamo di sapere che questo metodo viene invocato alla creazione dell'Activity. Più avanti scopriremo che si tratta di una tappa fondamentale del ciclo di vita di questo tipo di componenti.

A proposito delle due righe di codice presenti all'interno dell'onCreate:

- super.onCreate(savedInstanceState): invoca il metodo omonimo della classe base.
- setContentView(R.layout.activity_main): specifica quale sarà il “volto” dell'Activity, il suo layout. Al momento la dicitura R.layout.activity_main. Il suo effetto è quello di imporre come struttura grafica dell'Activity il contenuto del file activity_main.xml presente nella cartella res/layout.

#. Activity Launched:
onCreate()
onStart() / onRestart()
onResume()

- onCreate: l'activity viene creata. Il programmatore deve assegnare le configurazioni di base e definire quale sarà il layout dell'interfaccia.
- onStart: l'activity diventa visibile. È il momento in cui si possono attivare funzionalità e servizi che devono offrire informazioni all'utente.
- onResume: l'activity diventa la destinataria di tutti gli input dell'utente.



#. Activity Running:
onPause()
onStop()
onDestroy()

- onPause: (l'inverso di onResume) notifica la cessata interazione dell'utente con l'activity.
- onStop: (contraltare di onStart) segna la fine della visibilità dell'activity.
- onDestroy: (contrapposto a onCreate) segna la distruzione dell'activity.
- onSaveInstanceState: chiamato durante la messa in pausa dell'Activity, si può effettuare il salvataggio mentre in onRestoreInstanceState: invocato in fase di start dell'Activity, verrà consegnato il Bundle con i dati salvati nella sessione precedente, ed il programmatore avrà la possibilità di utilizzarli per ripristinare lo stato dell'Actvity.






#. Application Manifest.XML

Per ogni componente dell'app che crei nell'app, dichiara un elemento XML corrispondente nel file manifest:

<activity> per ogni sottoclasse di Activity
<service> per ogni sottoclasse di Service
<receiver> per ogni sottoclasse di BroadcastReceiver
<provider> per ogni sottoclasse di ContentProvider

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="it.html.helloworld">
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>

#. Manifest
Il nodo <application> contiene le componenti usate nell'applicazione. In questo caso, c'è un nodo <activity> che con l'attributo android:name specifica il nome della classe Java che incarna l'Activity. Se, come in questo caso, non viene specificato un package è sottintesa l'appartenenza della classe al package riportato nel nodo <manifest>, la root del file.

Oggetti Manifest:
<action>: Aggiunge un'azione a un filtro per intent.
<activity>:	Dichiara un componente dell'attività.
<activity-alias>: Dichiara un alias per un'attività.
<application>: Dichiara l'applicazione.
<category>: Aggiunge un nome di categoria a un filtro per intent.
<compatible-screens>: Specifica ogni configurazione dello schermo con cui è compatibile l'applicazione.
<data>: Aggiunge una specifica dei dati a un filtro per intent.
<grant-uri-permission>: Specifica i sottoinsiemi di dati dell'app a cui il fornitore di contenuti principale è autorizzato ad accedere.
<instrumentation>: Dichiara una classe Instrumentation che consente di monitorare l'interazione di un'applicazione con il sistema.
<intent-filter>: Specifica i tipi di intent a cui un'attività, un servizio o un ricevitore può rispondere.
<manifest>: L'elemento principale del file AndroidManifest.xml.
<meta-data>: Una coppia nome-valore relativa a un elemento di dati arbitrari aggiuntivi che possono essere forniti al componente principale.
<path-permission>: Definisce il percorso e le autorizzazioni richieste per un sottoinsieme specifico di dati all'interno di un fornitore di contenuti.
<permission>: Dichiara un'autorizzazione di sicurezza che può essere utilizzata per limitare l'accesso a componenti o funzionalità specifici di questa o di altre applicazioni.
<permission-group>: Dichiara un nome per un raggruppamento logico di autorizzazioni correlate.
<permission-tree>: Dichiara il nome di base per una struttura di autorizzazioni.
<provider>: Dichiara un componente del fornitore di contenuti.
<queries>: Dichiara l'insieme di altre app a cui la tua app intende accedere. Scopri di più nella guida sull'applicazione di filtri alla visibilità dei pacchetti.
<receiver>: Dichiara un componente BroadcastRicevitore.
<service>: Dichiara un componente del servizio.
<supports-gl-texture>: Dichiara un singolo formato di compressione delle texture GL supportato dall'app.
<supports-screens>: Dichiara le dimensioni dello schermo supportate dalla tua app e attiva la modalità di compatibilità dello schermo per schermi più grandi di quelle supportate dalla tua app.
<uses-configuration>: Indica funzionalità di input specifiche richieste dall'applicazione.
<uses-feature>: Dichiara una singola funzionalità hardware o software utilizzata dall'applicazione.
<uses-library>: Specifica una libreria condivisa a cui deve essere collegata l'applicazione.
<uses-native-library>: Specifica una libreria condivisa nativa fornita dal fornitore a cui deve essere collegata l'app.
<uses-permission>: Consente di specificare un'autorizzazione di sistema che l'utente deve concedere per il corretto funzionamento dell'app.
<uses-permission-sdk-23>: Specifica che un'app richiede un'autorizzazione specifica, ma solo se è installata su un dispositivo con Android 6.0 (livello API 23) o versioni successive.
<uses-sdk>: Consente di esprimere la compatibilità di un'applicazione con una o più versioni della piattaforma Android tramite un numero intero a livello di API.


#. Intent
Intent trasporta i dati, quindi per passare dati da un activity ad un'altra, devo creare un Intent a cui aggancio l'activity che voglio invocare e al quale voglio passare i dati.
Dopo aver creato l'intent, e agganciata l'activity, lo lancio dalla mia activity "locale" con lo start(Activity)

#. Intent-Filter
Il costrutto intent-filter specifica che l'activity può essere lanciata da un intent specifico soggetto a filtri.
Un componente dell'app deve dichiarare filtri separati per ogni job univoco che può eseguire. Ad esempio, un'attività in un'app galleria immagini può avere due filtri: un filtro per visualizzare un'immagine e un altro per modificare un'immagine. Quando inizia l'attività, controlla il Intent e decide come comportarsi in base alle informazioni nell' Intent (ad esempio, mostrare o meno i controlli dell'editor).
Un filtro di intenti deve corrispondere all'azione , ai dati e alla categoria per ricevere un messaggio.

Il processo di "risoluzione dell'intento" determina quale app deve ricevere ciascun messaggio. Questo processo considera l' attributo priorità , che può essere impostato nella dichiarazione del filtro di intenti , e verrà selezionato quello con la priorità più alta . Questa priorità può essere impostata tra -1000 e 1000 e le applicazioni possono utilizzare il SYSTEM_HIGH_PRIORITYvalore. Se si verifica un conflitto , viene visualizzata una finestra "scelta" in modo che l' utente possa decidere .

Ogni filtro per intent è definito da un elemento <intent-filter> nel file manifest dell'app, nidificato nel componente dell'app corrispondente (ad esempio un elemento <activity>).

In ogni componente dell'app che include un elemento <intent-filter>, imposta esplicitamente un valore per android:exported. Questo attributo indica se il componente dell'app è accessibile ad altre app. In alcune situazioni, ad esempio le attività i cui filtri per intent includono la categoria LAUNCHER, è utile impostare questo attributo su true. In caso contrario, è più sicuro impostare questo attributo su false.

Avviso: se un ricevitore di attività, un servizio o una trasmissione nella tua app utilizza filtri per intent e non imposta esplicitamente il valore di android:exported, l'app non può essere installata su un dispositivo con Android 12 o versioni successive, alternativamente il valore di default sarà true.

All'interno di <intent-filter>, puoi specificare il tipo di intent da accettare utilizzando uno o più di questi tre elementi:

#. Intent Filter - Action:
Un elemento <intent-filter> deve contenere uno o più elementi <action>. Se non ci sono elementi <action> in un filtro per intent, il filtro non accetta oggetti Intent.
Action='MAIN', indica che l'activity può essere lanciata da un action "Main" che non presenta dati settati nell'intent.

#. Intent Filter - Category:
Category='LAUNCHER' significa che deve essere un intent di avvio, in quanto l'activity verrà lanciata durante l'avvio del sistema che accoglierà l'utente all'ingresso nell'applicazione.

#. Activity - Tag/Attribute:
<activity android:allowEmbedded=["true" | "false"]
          android:allowTaskReparenting=["true" | "false"]
          android:alwaysRetainTaskState=["true" | "false"]
          android:autoRemoveFromRecents=["true" | "false"]
          android:banner="drawable resource"
          android:clearTaskOnLaunch=["true" | "false"]
          android:colorMode=[ "hdr" | "wideColorGamut"]
          android:configChanges=["mcc", "mnc", "locale",
                                 "touchscreen", "keyboard", "keyboardHidden",
                                 "navigation", "screenLayout", "fontScale",
                                 "uiMode", "orientation", "density",
                                 "screenSize", "smallestScreenSize"]
          android:directBootAware=["true" | "false"]
          android:documentLaunchMode=["intoExisting" | "always" |
                                  "none" | "never"]
          android:enabled=["true" | "false"]
          android:enabledOnBackInvokedCallback=["true" | "false"]
          android:excludeFromRecents=["true" | "false"]
          android:exported=["true" | "false"]
          android:finishOnTaskLaunch=["true" | "false"]
          android:hardwareAccelerated=["true" | "false"]
          android:icon="drawable resource"
          android:immersive=["true" | "false"]
          android:label="string resource"
          android:launchMode=["standard" | "singleTop" |
                              "singleTask" | "singleInstance" | "singleInstancePerTask"]
          android:lockTaskMode=["normal" | "never" |
                              "if_whitelisted" | "always"]
          android:maxRecents="integer"
          android:maxAspectRatio="float"
          android:multiprocess=["true" | "false"]
          android:name="string"
          android:noHistory=["true" | "false"]  
          android:parentActivityName="string" 
          android:persistableMode=["persistRootOnly" | 
                                   "persistAcrossReboots" | "persistNever"]
          android:permission="string"
          android:process="string"
          android:relinquishTaskIdentity=["true" | "false"]
          android:resizeableActivity=["true" | "false"]
          android:screenOrientation=["unspecified" | "behind" |
                                     "landscape" | "portrait" |
                                     "reverseLandscape" | "reversePortrait" |
                                     "sensorLandscape" | "sensorPortrait" |
                                     "userLandscape" | "userPortrait" |
                                     "sensor" | "fullSensor" | "nosensor" |
                                     "user" | "fullUser" | "locked"]
          android:showForAllUsers=["true" | "false"]
          android:stateNotNeeded=["true" | "false"]
          android:supportsPictureInPicture=["true" | "false"]
          android:taskAffinity="string"
          android:theme="resource or theme"
          android:uiOptions=["none" | "splitActionBarWhenNarrow"]
          android:windowSoftInputMode=["stateUnspecified",
                                       "stateUnchanged", "stateHidden",
                                       "stateAlwaysHidden", "stateVisible",
                                       "stateAlwaysVisible", "adjustUnspecified",
                                       "adjustResize", "adjustPan"] >   
    ...
</activity>

android:allowTaskReparenting
Indica se l'attività può essere spostata dall'attività che l'ha avviata all'attività per cui ha un'affinità la prossima volta che l'attività viene portata in primo piano. È "true" se può essere spostato e "false" se rimane con l'attività in cui è iniziata.
Se questo attributo non viene impostato, all'attività si applica il valore impostato dall'attributo allowTaskReparenting corrispondente dell'elemento <application>. Il valore predefinito è "false".

Normalmente, quando un'attività viene avviata, viene associata a quella dell'attività che l'ha avviata e rimane lì per tutta la sua durata. Puoi utilizzare questo attributo per forzarne la reintegrazione rispetto all'attività per cui ha un'affinità quando l'attività attuale non viene più visualizzata. In genere, questo viene utilizzato per spostare le attività di un'applicazione all'attività principale associata all'applicazione.

Ad esempio, se un messaggio email contiene un link a una pagina web e facendo clic sul link viene visualizzata un'attività che può visualizzare la pagina. Questa attività è definita dall'applicazione browser, ma viene avviata come parte dell'attività email. Se viene reiniziato nell'attività del browser, viene mostrato quando il browser viene mostrato in primo piano e non è presente quando viene nuovamente mostrata l'attività email.

L'affinità di un'attività è definita dall'attributo taskAffinity. L'affinità di un'attività viene determinata leggendo l'affinità della sua attività principale. Pertanto, per definizione, un'attività radice è sempre in un'attività con la stessa affinità. Poiché le attività con modalità di avvio "singleTask" o "singleInstance" possono trovarsi solo alla radice di un'attività, la creazione di un nuovo elemento padre è limitata alle modalità "standard" e "singleTop". (vedi anche l'attributo launchMode).



android:exported
Se l'attività può essere avviata da componenti di altre applicazioni:
Se "true", l'attività è accessibile a qualsiasi app e può essere avviata dal nome esatto della classe.
Se "false", l'attività può essere avviata solo dai componenti della stessa applicazione, da applicazioni con lo stesso ID utente o da componenti di sistema con privilegi. Questo è il valore predefinito se non sono presenti filtri per intent.
Se un'attività nella tua app include filtri per intent, imposta questo elemento su "true" per consentire ad altre app di avviarlo. Ad esempio, se l'attività è l'attività principale dell'app e include category android.intent.category.LAUNCHER.

Se questo elemento è impostato su "false" e un'app tenta di avviare l'attività, il sistema genera un ActivityNotFoundException.

Questo attributo non è l'unico modo per limitare l'esposizione di un'attività ad altre applicazioni. Le autorizzazioni vengono utilizzate anche per limitare le entità esterne che possono richiamare l'attività. Vedi l'attributo permission.



android:launchMode
Un'istruzione su come avviare l'attività. Esistono cinque modalità che operano in combinazione con i flag di attività (costanti FLAG_ACTIVITY_*) negli oggetti Intent per determinare cosa succede quando l'attività viene chiamata per gestire un intent:
"standard"
"singleTop"
"singleTask"
"singleInstance"
"singleInstancePerTask"

La modalità predefinita è "standard".

Come mostrato nella tabella seguente, le modalità si suddividono in due gruppi principali, con le attività "standard" e "singleTop" su un lato e le attività "singleTask", "singleInstance" e "singleInstancePerTask" dall'altro. Un'attività con la modalità di avvio "standard" o "singleTop" può essere creata più volte.

Le istanze possono appartenere a qualsiasi attività e trovarsi ovunque In genere, vengono avviati nell'attività denominata startActivity(), a meno che l'oggetto Intent non contenga un'istruzione FLAG_ACTIVITY_NEW_TASK, nel qual caso viene scelta un'attività diversa. Per maggiori informazioni, consulta l'attributo taskAffinity.

Al contrario, le attività "singleTask", "singleInstance" e "singleInstancePerTask" hanno comportamenti diversi. "singleInstancePerTask" è sempre alla radice dell'attività. Inoltre, il dispositivo può contenere una sola istanza alla volta dell'attività "singleInstance", mentre l'attività "singleInstancePerTask può essere creata più volte in attività diverse se è impostata l'opzione FLAG_ACTIVITY_MULTIPLE_TASK o FLAG_ACTIVITY_NEW_DOCUMENT.

Un'attività con la modalità di avvio "singleTask" combina i comportamenti di "singleInstance" e "singleInstancePerTask": l'attività può essere creata più volte e può trovarsi ovunque in un'attività della stessa taskAffinity. Tuttavia, il dispositivo può contenere una sola attività per individuare l'attività "singleTask" alla radice dell'attività.

Le modalità "standard" e "singleTop" sono diverse per un aspetto: ogni volta che esiste un nuovo intent per un'attività "standard", viene creata una nuova istanza della classe per rispondere a questo intento. Ogni istanza gestisce un singolo intent. Analogamente, può essere creata una nuova istanza di un'attività "singleTop" per gestire un nuovo intent.

Tuttavia, se l'attività di destinazione dispone già di un'istanza dell'attività in cima al proprio stack, l'istanza riceve il nuovo intent in una chiamata onNewIntent(). Non viene creata una nuova istanza. In caso contrario, se un'istanza esistente dell'attività "singleTop" si trova nell'attività di destinazione ma non in cima allo stack o se si trova in cima a uno stack, ma non nell'attività di destinazione, viene creata una nuova istanza e ne viene eseguito il push nello stack.

Allo stesso modo, se l'utente apre un'attività nello stack attuale, il comportamento è determinato dalla modalità di avvio dell'attività principale. Se l'attività principale ha la modalità di avvio singleTop (o l'intent up contiene FLAG_ACTIVITY_CLEAR_TOP), l'attività principale viene portato in cima all'elenco e il suo stato viene conservato.

L'intent di navigazione viene ricevuto dal metodo onNewIntent() dell'attività principale. Se l'attività principale ha la modalità di avvio standard e l'intent up non contiene FLAG_ACTIVITY_CLEAR_TOP, l'attività corrente e l'attività principale si separano dall'elenco e viene creata una nuova istanza dell'attività principale per ricevere l'intent di navigazione.

La modalità "singleInstance" differisce anche da "singleTask" e "singleInstancePerTask" per un solo aspetto: un'attività con la modalità di avvio "singleTask" o "singleInstancePerTask" consente ad altre attività, necessariamente "standard" e "singleTop", di farne parte.

Un'attività "singleInstance", invece, consente a nessun'altra attività di far parte della sua attività. Deve essere l'unica attività nell'attività. Se viene avviata un'altra attività, questa viene assegnata a un'altra attività, come se l'intent FLAG_ACTIVITY_NEW_TASK fosse presente.





#. Activity - Exported
Quando imposti android:exported="true" per un particolare componente nel tuo file AndroidManifest. xml, significa che è possibile accedere al componente da componenti esterni all'applicazione. Al contrario, l'impostazione android:exported="false" limita l'accesso al componente solo ai componenti all'interno della tua applicazione.



#. Directory Structure:
Cartella res contiene tutte le cartelle contenenti le risorse: layout, values, drawable, mipmap.

• layout: 
conterrà l'architettura grafica dei componenti dell'interfaccia utente. Sono definiti in XML in una maniera simile a come viene usato HTML per strutturare le pagine web.

• values: 
conterrà stringhe, colori, dimensioni e altre tipologie di valori che potranno essere usate in ulteriori risorse o nel codice Java. Importante notare che questi valori costituiranno il contenuto di appositi tag XML (<string>, <dimen>, etc.) raggruppati  in files dal nome solitamente indicativo:  strings.xml, dimens.xml, colors.xml e via dicendo. Tali nomi sono frutto di pura convenzione ma il programmatore può scegliere liberamente come chiamarli.

• drawable:
sono immagini nei formati più comuni o, cosa che può stupire, configurate in XML.

• mipmap:
sono immagini che costituiscono l'icona dell'applicazione, quella con cui viene lanciata da sistema operativo. Un tempo erano collocate tra i drawable ma successivamente gli è stata dedicata una sezione a parte tra le risorse.


Mediante i loro identificativi, le risorse sono accessibili sia da codice Java che da altre risorse definite in XML:

- Java: R.tipo_risorsa.nome_risorsa;
<string android:name="appname">Hello world!</string>
@Java - R.string.appname

- XML: @tipo_risorsa/nome_risorsa.
Ad esempio, la risorsa di tipo stringa e nome appname:
<string android:name="appname">Hello world!</string>
@XML - @string/appname 




#. Intent - Depth:
Rappresentano una forma di messaggistica gestita dal sistema operativo con cui una componente può richiedere l'esecuzione di un'azione da parte di un'altra componente.
Tre casistiche:
- Activity: avviare un'Activity.
- Service: avviare un Service.
- Broadcast Receiver: inviare un messaggio in broadcast che può essere ricevuto da ogni applicazione.

# Intent - Activity:
Un Activity rappresenta una singola schermata in un'app. Puoi avviare una nuova istanza di un Activity passando un Intent a startActivity(). Intent descrive l'attività da avviare e trasporta tutti i dati necessari.
Per ricevere un risultato dall'attività al termine, chiama startActivityForResult().
La tua attività riceve il risultato come oggetto Intent separato nel callback onActivityResult() dell'attività. Per ulteriori informazioni.

# Intent - Service:
Un Service è un componente che esegue operazioni in background senza un'interfaccia utente. Con Android 5.0 (livello API 21) e versioni successive, puoi avviare un servizio con JobScheduler.
Per le versioni precedenti ad Android 5.0 (livello API 21), puoi avviare un servizio utilizzando i metodi della classe Service. Puoi avviare un servizio per eseguire un'operazione una tantum (ad esempio il download di un file) passando un Intent a startService(). Intent descrive il servizio per l'avvio e trasporta tutti i dati necessari.
Se il servizio è progettato con un'interfaccia client-server, puoi associarlo al servizio da un altro componente passando un Intent a bindService().

# Intent - SendBroadcast:
Un annuncio è un messaggio che qualsiasi app può ricevere. Il sistema invia varie trasmissioni per eventi di sistema, ad esempio l'avvio del sistema o la ricarica del dispositivo. Puoi trasmettere una trasmissione ad altre app passando un Intent a sendBroadcast() o sendOrderedBroadcast().


Intent: espliciti e impliciti.

#. Intent Espliciti: 
Viene dichiarato quale componente dovrà essere attivata. Particolarmente utili nell'apertura di una nuova Activity.
Il nome del componente da cui iniziare è facoltativa, ma è l'informazione fondamentale che rende un intent esplicito, ovvero l'intent deve essere pubblicato solo nel componente dell'app definito dal suo nome. Senza un nome, l'intent è implicito e il sistema decide quale componente deve riceverlo in base alle altre informazioni sull'intent, ad esempio l'azione, i dati e la categoria, descritti di seguito. Se devi avviare un componente specifico nell'app, devi specificarne il nome.

Un intento esplicito specifica il nome della classe a cui è rivolto:
Intent downloadIntent = new (this, DownloadService.class):

In altre applicazioni per accedere all'intento precedentemente dichiarato è possibile utilizzare:
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);

#. Intent Impliciti:
Non specificano una componente da attivare ma quale azione deve essere svolta. La loro invocazione si estrinseca spesso nell'apertura di una finestra di dialogo che chiede all'utente quale app vuole si apra per completare l'azione.
Senza un nome specifico associato all'activity/service, l'intent è implicito e il sistema decide quale componente deve riceverlo in base alle altre informazioni sull'intent, ad esempio l'azione, i dati e la categoria, descritti di seguito. Se devi avviare un componente specifico nell'app, devi specificarne il nome.

Un Intent è un oggetto di messaggistica che puoi utilizzare per richiedere un'azione da un altro componente dell'app. Sebbene gli intent facilitino la comunicazione tra i componenti in diversi modi, esistono tre casi d'uso fondamentali:



#. Extras - Intent:
Intent custodiscono dati che possono essere letti dal destinatario chiamati Extras negli Intent funziona in maniera simile ad una struttura dati a mappa: con dei metodi put viene inserito un valore etichettato con una chiave e con i corrispondenti metodi get viene prelevato il valore, richiedendolo mediante la chiave di riconoscimento.
A livello di codice, nella MainActivity, una volta ottenuto il successo nel login troveremo:

Intent i=new Intent(this,SecretActivity.class);
i.putExtra("username", account_username);
startActivity(i);

Le tre operazioni rappresentano:
- Dichiarazione dell'Intent come normale oggetto Java. In questo caso avremo un cosiddetto intent esplicito in quanto appare chiaramente il nome della classe che verrà invocata. Viene inserito, tra gli Extras, una String, la variabile account_username, che sarà trasportata con l'Intent fino a destinazione ossia la classe SecretActivity. Lo scopo è inserire in questa stringa il nome dell'utente che ha effettuato il login. Notare che l'extra viene etichettato con una chiave, in questo caso “username”. Ciò perchè possono essere trasportati più Extras per ogni Intent e dovrà essere possibile distinguerli per utilizzarli.
Infine il metodo startActivity dimostra quale azione vogliamo attivare con questo Intent (in questo caso dell'avvio di un'Activity).
Nel metodo "onCreate" della seconda Activity, quella con il contenuto riservato, troveremo le seguenti righe:

Intent i=getIntent();
String username=i.getStringExtra("username");

Notiamo subito che l'Activity attivata si trova a disposizione, mediante getIntent(),  l'Intent che ne ha provocato l'attivazione. Lo può utilizzare per recuperare la stringa passata, contenente il nome utente.


#. Intent Filter:
Action, Data, Category, Extra

#.  Intent-Filter - Action:
Una stringa che specifica l'azione generica da eseguire (come view o pick o main).
Nel caso di un intent di trasmissione, questa è l'azione che è avvenuta e che viene segnalata. L'azione determina in gran parte il modo in cui è strutturato il resto dell'intent, in particolare le informazioni contenute nei dati e negli extra.
Dichiara l'azione intent accettata nell'attributo name. Il valore deve essere il valore letterale della stringa di un'azione, non la costante di classe.

<intent-filter>
        <action android:name="android.intent.action.MAIN"/>
        <category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>

Puoi specificare le tue azioni da utilizzare per gli intent all'interno dell'app (o da altre app per richiamare i componenti dell'app), ma in genere specifichi le costanti delle azioni definite dalla classe Intent o da altre classi di framework. Di seguito sono riportate alcune azioni comuni per avviare un'attività:

#. Action-Filter: Action - ACTION_MAIN
L'azione ACTION_MAIN indica che questo è il punto di ingresso principale e non prevede dati sugli intent

#. Action-Filter: Action - ACTION_VIEW
Utilizza questa azione in un intent con startActivity() se hai informazioni che un'attività può mostrare all'utente, ad esempio una foto da visualizzare in un'app Galleria o un indirizzo da visualizzare in un'app di mappe.

#. Action-Filter: Action - ACTION_SEND
Chiamato anche Intent Share, dovresti utilizzarlo in un intent con startActivity() quando disponi di alcuni dati che l'utente può condividere tramite un'altra app, ad esempio un'app email o un'app di condivisione sui social.
Consulta il riferimento della classe Intent per altre costanti che definiscono azioni generiche. Altre azioni sono definite altrove nel framework Android, ad esempio in Settings per le azioni che aprono schermate specifiche nell'app Impostazioni del sistema.
Puoi specificare l'azione per un intent con setAction() o con un costruttore Intent.




#.  Intent-Filter - Data:
L'URI (un oggetto Uri) che fa riferimento ai dati su cui eseguire azioni e/o il tipo MIME di tali dati. Il tipo di dati forniti è generalmente dettato dall'azione dell'intent. Ad esempio, se l'azione è ACTION_EDIT, i dati devono contenere l'URI del documento da modificare.
Quando crei un intent, spesso è importante specificare il tipo di dati (il tipo MIME) oltre al relativo URI. Ad esempio, un'attività in grado di visualizzare immagini probabilmente non sarà in grado di riprodurre un file audio, anche se i formati URI potrebbero essere simili. La specifica del tipo MIME dei dati consente al sistema Android di trovare il componente migliore per ricevere il tuo intent. Tuttavia, a volte il tipo MIME può essere dedotto dall'URI, in particolare quando i dati sono un URI content. 
Un URI content: indica che i dati si trovano sul dispositivo e sono controllati da un elemento ContentProvider, che rende visibile al sistema il tipo MIME dei dati.
Per impostare solo l'URI dei dati, chiama setData(). Per impostare solo il tipo MIME, chiama setType(). Se necessario, puoi impostarli entrambi esplicitamente con setDataAndType().
Dichiara il tipo di dati accettato utilizzando uno o più attributi che specificano i vari aspetti dell'URI dei dati (scheme, host, port, path) e del tipo MIME.



#.  Intent-Filter - Category:
Una stringa contenente informazioni aggiuntive sul tipo di componente che dovrebbe gestire l'intent. In un intent può essere inserito un numero qualsiasi di descrizioni di categorie, ma la maggior parte degli intent non richiede una categoria. Ecco alcune categorie comuni.
Dichiara la categoria di intent accettata nell'attributo name. Il valore deve essere il valore letterale della stringa di un'azione, non la costante di classe.
Nota:per ricevere intent impliciti, devi includere la categoria CATEGORY_DEFAULT nel filtro per intent. I metodi startActivity() e startActivityForResult() trattano tutti gli intent come se avessero dichiarato la categoria CATEGORY_DEFAULT. Se non dichiari questa categoria nel filtro per intent, nessun intent implicito si risolverà nella tua attività.

#. Intent-Filter - Category: CATEGORY_ BROWSABLE
L'attività target consente di essere avviata da un browser web per mostrare dati a cui fa riferimento un link, come un'immagine o un messaggio email.

#. Intent-Filter - Category: CATEGORY_ LAUNCHER
L'attività è l'attività iniziale di un'attività ed è elencata in Avvio applicazioni del sistema.
Consulta la descrizione della classe Intent per l'elenco completo delle categorie.
Puoi specificare una categoria con addCategory().
<intent-filter>
    <action android:name="android.intent.action.MAIN"/>
    <category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>

Le proprietà elencate sopra (nome del componente, azione, dati e categoria) rappresentano le caratteristiche distintive di un intent. Leggendo queste proprietà, il sistema Android riuscirà a stabilire il componente dell'app da avviare. Tuttavia, un intent può includere informazioni aggiuntive che non influiscono sul modo in cui viene risolto in un componente dell'app. Un intent può anche fornire le seguenti informazioni:
Ad esempio, ecco una dichiarazione di attività con un filtro per intent per ricevere un intent ACTION_SEND quando il tipo di dati è di tipo testuale:

<activity android:name="ShareActivity" android:exported="false">
    <intent-filter>
        <action android:name="android.intent.action.SEND"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:mimeType="text/plain"/>
    </intent-filter>
</activity>
Puoi creare un filtro che include più istanze di <action>, <data> o <category>. In questo caso, devi assicurarti che il componente sia in grado di gestire tutte le combinazioni di questi elementi filtro.

Se vuoi gestire più tipi di intent, ma solo in combinazioni specifiche di azione, dati e tipo di categoria, devi creare più filtri per intent.

Extra:
Coppie chiave-valore che contengono informazioni aggiuntive necessarie per eseguire l'azione richiesta. Proprio come alcune azioni utilizzano tipi particolari di URI di dati, anche alcune azioni utilizzano particolari extra.
Puoi aggiungere altri dati con vari metodi putExtra(), ognuno dei quali accetta due parametri: il nome della chiave e il valore. Puoi anche creare un oggetto Bundle con tutti i dati aggiuntivi, quindi inserire Bundle in Intent con putExtras().

Ad esempio, quando crei un intent per inviare un'email con ACTION_SEND, puoi specificare il destinatario to con la chiave EXTRA_EMAIL e specificare l'oggetto con la chiave EXTRA_SUBJECT.

La classe Intent specifica molte costanti EXTRA_* per i tipi di dati standardizzati. Se devi dichiarare chiavi aggiuntive (per gli intent ricevuti dalla tua app), assicurati di includere il nome del pacchetto dell'app come prefisso, come mostrato nell'esempio seguente:




#. Intent Implicito - Manifest.xml

Ricezione di un Intent implicito
Per pubblicizzare gli intent impliciti che la tua app può ricevere, dichiara uno o più filtri di intent per ciascuno dei componenti dell'app con un elemento <intent-filter> nel file manifest. Ogni filtro per intent specifica il tipo di intent che accetta in base all'azione, ai dati e alla categoria dell'intent. Il sistema fornisce un intent implicito al componente dell'app solo se l'intent può passare attraverso uno dei filtri per intent.

Nota: un intent esplicito viene sempre pubblicato nel relativo target, indipendentemente dagli eventuali filtri per intent dichiarati dal componente.

Un intent implicito viene testato rispetto a un filtro confrontando l'intent con ciascuno dei tre elementi. Per essere pubblicato nel componente, l'intent deve superare tutti e tre i test. Se non riesce a trovare nemmeno uno di questi elementi, il sistema Android non trasmetterà l'intent al componente. Tuttavia, poiché un componente può avere più filtri per intent, un intent che non passa attraverso uno dei filtri di un componente potrebbe farlo in un altro filtro. Maggiori informazioni su come il sistema risolve gli intent sono fornite nella sezione di seguito sulla risoluzione degli intent.

Filtri di esempio
Per dimostrare alcuni comportamenti del filtro per intent, ecco un esempio tratto dal file manifest di un'app per la condivisione sui social:
<activity android:name="MainActivity" android:exported="true">
    <!-- This activity is the main entry, should appear in app launcher -->
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>

<activity android:name="ShareActivity" android:exported="false">
    <!-- This activity handles "SEND" actions with text data -->
    <intent-filter>
        <action android:name="android.intent.action.SEND"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:mimeType="text/plain"/>
    </intent-filter>
    <!-- This activity also handles "SEND" and "SEND_MULTIPLE" with media data -->
    <intent-filter>
        <action android:name="android.intent.action.SEND"/>
        <action android:name="android.intent.action.SEND_MULTIPLE"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:mimeType="application/vnd.google.panorama360+jpg"/>
        <data android:mimeType="image/*"/>
        <data android:mimeType="video/*"/>
    </intent-filter>
</activity>
La prima attività, MainActivity, è il punto di ingresso principale dell'app, ovvero l'attività che si apre quando l'utente avvia per la prima volta l'app con l'icona in Avvio applicazioni:
• L'azione ACTION_MAIN indica che questo è il punto di ingresso principale e non prevede dati sugli intent.
• La categoria CATEGORY_LAUNCHER indica che l'icona di questa attività deve essere posizionata in Avvio applicazioni del sistema. Se l'elemento <activity> non specifica un'icona con icon, il sistema utilizza l'icona dell'elemento <application>.
Questi due dispositivi devono essere accoppiati per consentire la visualizzazione dell'attività in Avvio applicazioni.
La seconda attività, ShareActivity, ha lo scopo di facilitare la condivisione di testo e contenuti multimediali. Anche se gli utenti possono accedere a questa attività accedendovi da MainActivity, possono anche inserire ShareActivity direttamente da un'altra app che genera un intent implicito che corrisponde a uno dei due filtri per intent.

L'intent può non specificare una specifica app/package, in tal caso ogni applicazione potrebbe processare l'intent.
Se esistono molteplici intent tra piu APP, nella resolution dell'intents, a parità di data, category viene scelto l'app con il SYSTEM_HIGH_PRIORITY value maggiore.





#. Permissions:
Un'applicazione Android vive in all'interno di una sandbox, ovvero un ambiente chiuso in cui l'applicazione opera in maniera sostanzialmente isolata dal resto del sistema. Talvolta, però, può essere necessario che essa debba "uscire" da questa gabbia per accedere a informazioni, funzionalità o apparati hardware del dispositivo. Per far sì che l'app acceda a tali servizi, essa deve possedere alcuni "permessi" speciali - le cosiddette permission - che è necessario dichiarare espressamente nel file AndroidManifest.xml. 
Ogni permission viene dichiarata tramite il tag <uses-permission>, da collocare al di fuori del nodo <application>


<manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="...." >
<uses-permission android:name="android.permission.INTERNET" />
<application>
...
...
</application>
...
</manifest>



###. Permissions:
Le permission Android vengono suddivise in tre famiglie in base al livello di protezione:


#. Permission Normal:
Non mettono cioè a rischio la privacy dell'utente, tra le quali troviamo:
- android.permission.INTERNET: accesso alla Rete
- android.permission.ACCESS_NETWORK_STATE: verifica dello stato della rete
- android.permission.ACCESS_WIFI_STATE: accesso alle informazioni sulle reti Wi-Fi

- accesso a particolari tecnologie per la connettività:
android.permission.BLUETOOTH, android.permission.BLUETOOTH_ADMIN,android.permission.NFC.
- invio di un Intent per l'impostazione di un allarme: com.android.alarm.permission.SET_ALARM;
- gestione della vibrazione (android.permission.VIBRATE) o del WaveLock per il controllo dello stand-by (android.permission.WAVE_LOCK);
- molte altre: una lista completa è disponibile sulla documentazione ufficiale.


#. Permission Dangerous:
Potenzialmente più lesive della riservatezza degli utenti, come quelle riguardanti:
• la localizzazione: android.permission.ACCESS_FINE_LOCATION, android.permission.ACCESS_COARSE_LOCATION.
• il calendario: android.permission.READ_CALENDAR, android.permission.WRITE_CALENDAR.
• i contatti: android.permission.READ_CONTACTS e android.permission.WRITE_CONTACTS.
• attività telefoniche: ad esempio, android.permission.READ_PHONE_STATE e android.permission.SEND_SMS.
• accesso ai file: android.permission.READ_EXTERNAL_STORAGE e android.permission.WRITE_EXTERNAL_STORAGE.


#. Permission Signature:
Gestite a livello di installazione ma utilizzabili solo se l'app che le richiede è firmata con lo stesso certificato di quella che ha definito la permission.

Per sviluppare app moderne, quindi, è necessario gestire le permission a runtime, verificando se esse siano revocate o meno, nonchè richiedendo all'utente di abilitarle.
La classe ContextCompat, inclusa nella libreria di supporto, mette a disposizione un metodo per effettuare questo tipo di controllo:

int statoPermission = ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION);







###. GUI:
Interfaccia grafica può essere creata tramite HTML (procedura dichiarativa), descrittore XML (procedura dichiarativa), codice Java (metodo procedurale).


#. Fragment:
I Fragment costituiscono senz'altro uno dei più importanti elementi per la creazione di una interfaccia utente Android moderna. Il loro ruolo a partire da Android 3.0 è diventato preponderante tanto che ormai rappresentano una delle conoscenze più importanti per il programmatore.

Un Fragment è una porzione di Activity. Ma si faccia attenzione a comprenderne bene il ruolo. Non si tratta solo di un gruppo di controlli o di una sezione del layout. Può essere definito più come una specie di sub-activity con un suo ruolo funzionale molto importante ed un suo ciclo di vita.



#. Fragments vs Activity
Definiamo subito il rapporto tra Fragments e Activity.

Prima di tutto un Fragment non può vivere senza un'Activity. Tipicamente nei nostri programmi creeremo più Fragments che si alterneranno nel layout mentre di Activity ne sarà sufficiente una (ma possono essere anche di più).
Come detto il Fragment ha il suo ciclo di vita fortemente collegato con quello dell'Activity di appartenenza.
La figura qui riportata mostra la sequenza di stati che scandiscono la vita del Fragment.
I Fragments possono essere visti come blocchi componibili che permettono di rendere il layout adattabile al dispositivo. Se la frammentazione dei dispositivi rappresenta una problematica di rilievo per i programmatori Android, i Fragments rappresentano in buona parte una soluzione.

• Fragments collegati tra loro il minimo possibile per permetterne un maggior riutilizzo.
• Activity usata per lo più come snodo di comunicazione tra Fragments.
• Risorse in grado di separare all'origine i layout distinguendo con id diversi i contenitori dei Fragments.
• Ogni classe Fragment deve avere sin dalla nascita uno scopo ben preciso e contenere in sé tutta la logica necessaria per raggiungerlo in maniera indipendente.




Storage:
Internal Storage vs External Storage.
Internal Storage:
Ogni app ha un suo Internal Storage accessibli da /data/data/package_java_app/files

ExternalStorage:
Tutte le risorse di utilità collettiva e consultazione generale (musica, suonerie, film), solitamente collocato su una SD card al sistema

Storage Esterno:
La prima operazione da svolgere è controllare lo stato del supporto. Lo si fa con il metodo statico String Environment.getExternalStorageState().

La stringa restituita può avere una molteplicità di valori, tutti associati a costanti della classe Environment. Evitando di elencarli tutti, teniamo presente solo che due valori in particolare ci dicono che il supporto può essere usato:

Environment.MEDIA_MOUNTED: il caso migliore. Supporto disponibile in lettura/scrittura;
Environment.MEDIA_MOUNTED_READ_ONLY: il supporto è disponibile ma solo in lettura.


Gestione Thread:
AsyncTask che, a suo modo, permette di avviare attività asincrone a supporto dell'interfaccia utente. I task gestiti da questa classe non dovrebbero essere molto lunghi, “a few seconds at the most” ('pochi secondi al massimo') come dichiara esplicitamente la documentazione ufficiale.


Keystore:
Il sistema Android Keystore ti permette di archiviare chiavi crittografiche in un contenitore per renderle più difficili da estrarre dal dispositivo. Una volta che le chiavi sono nel keystore, puoi utilizzarle per operazioni crittografiche, con il materiale della chiave che rimane non esportabile.

Ecco alcune caratteristiche chiave del sistema Android Keystore:

1. Prevenzione dell'estrazione: Il materiale della chiave non entra mai nel processo dell'applicazione. Quando un'app esegue operazioni crittografiche utilizzando una chiave Android Keystore, i dati in chiaro, il testo cifrato e i messaggi da firmare o verificare vengono gestiti da un processo di sistema che esegue le operazioni crittografiche. Se il processo dell'app viene compromesso, l'attaccante potrebbe utilizzare le chiavi dell'app, ma non può estrarre il loro materiale chiave (ad esempio, per utilizzarlo al di fuori del dispositivo Android). Inoltre, il materiale della chiave può essere vincolato all'hardware sicuro del dispositivo Android, come l'Ambiente di esecuzione attendibile (TEE) o l'Elemento sicuro (SE). Quando questa funzionalità è abilitata per una chiave, il suo materiale chiave non viene mai esposto all'esterno dell'hardware sicuro. Anche se il sistema operativo Android è compromesso o un attaccante può leggere la memoria interna del dispositivo, non può estrarre le chiavi Android Keystore dal dispositivo¹.

2. Autorizzazioni di utilizzo delle chiavi: Il sistema Keystore Android consente di limitare quando e come le chiavi possono essere utilizzate. Ad esempio, puoi richiedere l'autenticazione dell'utente per l'uso della chiave o limitare le chiavi all'utilizzo solo in determinate modalità crittografiche¹.

In sintesi, il sistema Android Keystore offre un livello di protezione per le chiavi crittografiche all'interno del dispositivo, rendendole più sicure e difficili da estrarre¹.

Origine: conversazione con Bing, 17/3/2024
(1) https://developer.android.com/privacy-and-security/keystore?hl=es-419.
(2) https://developer.android.com/privacy-and-security/keystore.
(3) https://developer.android.com/privacy-and-security/keystore?hl=zh-tw.
(4) https://source.android.com/docs/security/features/keystore?hl=zh-cn.
(5) https://developer.android.com/reference/java/security/KeyStore.

```


```
###. Android - Layout

#. Implementazione Procedurale:
Lato Codice: Swing - Java:
JButton, JFrame



#. Implementazione dichiarativa: 
HTML statico



#. Implementazione Ibrida:
Implementazione dell'interfaccia in modo dichiarativo e la si controlla e specifica in modo procedurale (da codice richiamo il descrittore XML) 




###. Tipi Layout:
#. LinearLayout: Continee un insieme di elementi che distribuisce in maniera sequenziale dall'alto verso il basso o sinistra/destra.
Il LinearLayout riceve con l'attributo orientation la sua connotazione principale.
[android:orientation="vertical"]

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:orientation="vertical">
. . .
. . .
</LinearLayout>




#. TableLayout:
Layout a tabella - <table> <tr> <td>
Il TableLayout viene specificato mediante due tag: TableLayout e TableRow.
[TableLayout]  [TableRow]

<TableLayout xmlns:android="http://schemas.android.com/apk/res/android"
android:layout_width="wrap_content"
android:layout_height="match_parent">
<TableRow
android:layout_width="wrap_content"
android:layout_height="match_parent">
. . .
. . .
</TableRow>
. . .
. . .
</TableLayout>





#. RelativeLayout:
Pagine Web Flottanti
Il frammento di XML che segue mostra un esempio di RelativeLayout con una TextView collocata in alto a sinistra ed un Button in basso al centro:



<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
android:layout_width="match_parent"
android:layout_height="match_parent">
<TextView
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:layout_alignParentTop="true"
android:layout_alignParentLeft="true"
        android:text="Esempio di Relative Layout"/>
<Button
android:layout_width="90dp"
android:layout_height="wrap_content"
android:layout_alignParentBottom="true"
android:layout_centerHorizontal="true"
android:text="Clicca qui!"/>
</RelativeLayout>


# Menu
# ActionBar
# Notifiche: Toast e Dialog




##. WebView:
Una WebView è un tipo di View che permette di visualizzare pagine web. La sua utilità principale è quella di permettere di integrare una web application o più in generale un sito web nella propria applicazione.


1. Definition of Web View Layout
<WebView xmlns:android="http://schemas.android.com/apk/res/android"
android:id="@+id/webview"
android:layout_width="match_parent"
android:layout_height="match_parent"
/>


2. Web View - Java class
Aggancio la Web View all'Activity

Activity Class

@Override
protected void onCreate(Bundle savedInstanceState)
{
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        WebView myWebView = findViewById(R.id.webview);
        myWebView.loadUrl("https://www.html.it");
}



3. Definition Permissions "INTERNET" on AndroidManifest.xml per accedere dall'app ad internet
   
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
<uses-permission android:name="android.permission.INTERNET"/><application
...




###. WebView - Web Settings:
> webSettings.setJavaScriptEnabled(true);
> cache
> font e layout
> interaction js with Javacode




###. Adapter e AdapterView:
Permettono una visualizzazione iterativa dei contenuti archiviati in strutture dati.

#. Adapter:
è un componente collegato ad una struttura dati di oggetti Java (array, Collections, risultati di query) e che incapsula il meccanismo di trasformazione di questi oggetti in altrettante View da mostrare su layout;

#. AdapterView:
è un componente visuale che è collegato ad un adapter e raccoglie tutte le View prodotte dall'adapter per mostrarle secondo le sue politiche.

Creo una List View e la aggancio ad una Text View:

<ListView xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/listview"
    android:layout_width="match_parent"
    android:layout_height="match_parent"/>


<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:textSize="28sp"
    android:padding="8dp"/>


java
@Override
protected void onCreate(Bundle savedInstanceState)
{
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    String[] citta= {"Torino","Roma","Milano","Napoli","Firenze"};
    ArrayAdapter<String> adapter=new ArrayAdapter<String>(this, R.layout.row,citta);
    ListView listView = findViewById(R.id.listview);
    listView.setAdapter(adapter);
}


ListView -> GridView per mostrare griglia




# Fragments:
Creo l'xml contente l'activity utilizzando il fragments.
Lato codice java lo aggancio all'activity.




```


```
###. Storage

#. Internal Storage:
/data/data/package_java_della_applicazione/files.


#. External Storage:
È possibile accedere alla memoria esterna in:
- /storage/emulated/0, 
- /mnt/sdcard
- /sdcard/
- /storage/emulated/0/Download


 Context.getExternalFilesDirs


#. SharedPrefs:
directory shared_prefs:

getPreferences();
getSharedPreferences();

SharedPreferences sharedPref = this.getPreferences(Context.MODE_PRIVATE);
int savedValue = sharedPref.getInt(getString(R.string.saved_value), 22);


#. Database e SQLite:
Alternativa alla memorizzazione dei file, SQLite, una libreria software che pemrette di gestire in un unico file un database relazionale.

1. Creazione script SQL per creazione tabella (o uso di SQLiteman)
2. Creare classe Java che estende SQLiteOpenHelper
3. Creare classe per l'interazione con il DB. Reference dell'oggetto Helper (2), e metodi per richiedere e i dati.


Es. Code:

public class DBhelper extends SQLiteOpenHelper
{
public static final String DBNAME="BILLBOOK";
public DBhelper(Context context) {
super(context, DBNAME, null, 1);
}
@Override
public void onCreate(SQLiteDatabase db)
{
String q="CREATE TABLE "+DatabaseStrings.TBL_NAME+
" ( _id INTEGER PRIMARY KEY AUTOINCREMENT," +
DatabaseStrings.FIELD_SUBJECT+" TEXT," +
DatabaseStrings.FIELD_TEXT+" TEXT," +
DatabaseStrings.FIELD_DATE+" TEXT)";
db.execSQL(q);
}
@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)
{ }
}




public class DbManager
{
private DBhelper dbhelper;
public DbManager(Context ctx)
{
dbhelper=new DBhelper(ctx);
}
public void save(String sub, String txt, String date)
{
SQLiteDatabase db=dbhelper.getWritableDatabase();
ContentValues cv=new ContentValues();
cv.put(DatabaseStrings.FIELD_SUBJECT, sub);
cv.put(DatabaseStrings.FIELD_TEXT, txt);
cv.put(DatabaseStrings.FIELD_DATE, date);
try
{
db.insert(DatabaseStrings.TBL_NAME, null,cv);
}
catch (SQLiteException sqle)
{
// Gestione delle eccezioni
}
}
public boolean delete(long id)
{
SQLiteDatabase db=dbhelper.getWritableDatabase();
try
{
if (db.delete(DatabaseStrings.TBL_NAME, DatabaseStrings.FIELD_ID+"=?", new String[]{Long.toString(id)})>0)
return true;
return false;
}
catch (SQLiteException sqle)
{
return false;
}
}
public Cursor query()
{
Cursor crs=null;
try
{
SQLiteDatabase db=dbhelper.getReadableDatabase();
crs=db.query(DatabaseStrings.TBL_NAME, null, null, null, null, null, null, null);
}
catch(SQLiteException sqle)
{
return null;
}
return crs;
}
}


public class MainActivity extends AppCompatActivity
{
	private DbManager db=null;
	private CursorAdapter adapter;
	private ListView listview=null;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		db=new DbManager(this);
		listview= findViewById(R.id.listview);
		Cursor crs=db.query();
		adapter=new CursorAdapter(this, crs, 0)



L'Activity gestisce l'interazione con il database appellandosi all'oggetto DbManager istanziato. I comandi di salvataggio e cancellazione che l'utente impartisce vengono, rispettivamente, attivati mediante:





#. Content Provider - Condivisione Dati:
I ContentProvider sono riconoscibili mediante un URI, un riferimento univoco. Questi indirizzi sono costituiti da due parti:

authority: è il nome del Provider in generale. Spesso, per evitare conflitti, richiama il nome del package Java di appartenenza;
path: costituisce un percorso interno alla singola authority. Spesso rappresenta una tabella del database cui si vuole accedere ma, in generale, indica la tipologia di dati su cui agire.
Un ContentProvider, come avviene per le Activity, deve essere definito in due step:

creare una classe Java che estenda ContentProvider;
creare un nodo <provider> all'interno dell'AndroidManifest.xml. Servirà ad associare la classe Java che implementa il Provider (definita al punto precedente) e l'authority scelta per gli URI.


Per attuare l'adattamento del database a ContentProvider, iniziamo con la definizione degli URI. Scegliamo il package Java (“it.html.guida.database”) come authority e che tutti i path inizino con il segmento “/scadenze”. Queste sono decisioni che spettano al programmatore.

Le azioni che potranno essere invocate sul ContentProvider sono le stesse del precedente capitolo:

l'elenco delle scadenze: una query che recupera tutto il contenuto della tabella;
inserire una nuova scadenza;
richiede la cancellazione di una scadenza riconosciuta mediante l'id;
e questi gli URI presso i quali potranno, rispettivamente, essere richieste:

content:// it.html.guida.database/scadenze/lista
content:// it.html.guida.database/scadenze/nuova
content:// it.html.guida.database/scadenze/elimina


La registrazione del ContentProvider nell'AndroidManifest.xml avverrà così:

<application
. . .
. . .>
<activity
. . .
. . ./>
<provider android:name=".BillBookProvider" android:authorities="it.html.guida.database"/>
</application>

public class BillBookProvider extends ContentProvider
{
private DBhelper dbhelper=null;

db=new DbManager(this);
Cursor crs=db.query();


Cursor crs=getContentResolver().query(Uri.parse("content://it.html.guida.database/scadenziario"), null, null, null, null);

```


```
###. Processi e servizi

#. Service Started:
Service Started vengono avviati tramite il metodo startService(). La loro particolarità è di essere eseguiti in background indefinitamente anche se la componente che li ha avviati viene terminata. Generalmente non offrono interazione con il chiamante e proseguono finchè non vengono interrotti con il metodo stopService o si auto-interrompono con stopSelf();


#. Service Bound:
Service Bound vivono in una modalità client-server. Hanno senso solo se qualche altra componente vi si collega. Vengono interrotti nel momento in cui non vi sono più client ad essi collegati.




```


```
###. FingerprintManager API

<uses-permission
android:name="android.permission.USE_FINGERPRINT" />

API Level > 23

API Disponibili per il Fingerprining:
FingerprintManager, KeyguardManager



Il lavoro di autenticazione viene reso piuttosto agevole dalle API disponibili. Infatti, nel metodo onCreate, richiederemo l'istanza di due servizi di sistema: FingerprintManager, che si occuperà di svolgere l'autenticazione tramite impronte digitali tramite il metodo authenticate, e KeyguardManager, che verificherà la presenza nel dispositivo di un blocco all'accesso (mediante PIN, sequenza di qualche genere o altro):

protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
keyguardManager =
(KeyguardManager) getSystemService(KEYGUARD_SERVICE);
fingerprintManager =
(FingerprintManager) getSystemService(FINGERPRINT_SERVICE);
if (!keyguardManager.isKeyguardSecure()) {
Toast.makeText(this, "Il dispositivo non dispone di alcun blocco",Toast.LENGTH_LONG).show();
return;
}
Cipher cipher = CipherGenerator.getCipher();
if (cipher != null) {
cryptoObject = new FingerprintManager.CryptoObject(cipher);
}
}
Si noti che, sul finire del metodo, viene inizializzato un oggetto definito come CryptoObject. Questo sarà passato al FingerprintManager per rendere sicura la comunicazione con lo scanner di impronte, come vedremo più avanti.

L'inizio dell'autenticazione coinciderà con il metodo onResume che, come sappiamo, coincide con l'inizio dell'interazione utente con l'Activity:

protected void onResume() {
super.onResume();
String msg;
String title;
if (ActivityCompat.checkSelfPermission(this, Manifest.permission.USE_FINGERPRINT)
== PackageManager.PERMISSION_GRANTED && fingerprintManager.hasEnrolledFingerprints() && cryptoObject!=null) {
cancellationSignal = new CancellationSignal();
fingerprintManager.authenticate(cryptoObject, cancellationSignal, 0, callback, null);
title = "Autenticazione richiesta";
msg = "Quest'app è soggetta a controllo mediante impronta digitale";
}
else {
title = "Errore";
msg = "Impossibile procedere con autenticazione via impronta digitale";
}
dialog = new AlertDialog.Builder(this)
.setIcon(R.drawable.ic_fp_40px)
.setTitle(title)
.setCancelable(false)
.setMessage(msg)
.create();
dialog.show();
}
Nel metodo onResume, l'autenticazione avrà realmente inizio solo se le permission necessarie sono state assegnate, e se almeno un'impronta digitale è stata registrata. Il meccanismo che utilizzeremo per impedire di usare l'app fino allo sblocco consisterà, per semplicità, in una normale AlertDialog non cancellabile.

Il metodo authenticate del FingerprintManager, al momento dell'invocazione, riceve il CryptoObject cui abbiamo già accennato, un CancellationSignal che useremo nell'onPause per interdire il meccanismo di autenticazione, ed un riferimento ad un listener i cui metodi saranno invocati all'esito del riconoscimento delle impronte:

private FingerprintManager.AuthenticationCallback callback= new FingerprintManager.AuthenticationCallback() {
@Override
public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result) {
// autenticazione riuscita, sblocchiamo app
dialog.dismiss();
}
/*
* omesso il codice dei metodi
* onAuthenticationError,
* onAuthenticationHelp e
* onAuthenticationFailed
*/
};
Il metodo onAuthenticationSucceeded viene invocato quando viene riconosciuta una impronta digitale valida: interpreteremo ciò come autorizzazione ad utilizzare l'applicazione. Nel nostro esempio, lo sblocco si estrinsecherà semplicemente nella chiusura della finestra di dialogo.

```



```
###. App Android Architecture:





```
