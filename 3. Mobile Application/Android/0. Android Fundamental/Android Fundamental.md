

```
#. Android Fundamental
Ogni applicazione Android, indipendentemente dalla finalità che si prefigge, affida le sue funzionalità a quattro tipi di componenti. Si tratta di Activity, Service, Content Provider e BroadcastReceiver ed esistono affinchè la nostra applicazione possa integrarsi alla perfezione nell'ecosistema Android.




#. Activity:
Un'Activity è un'interfaccia utente. Ogni volta che si usa un'app generalmente si interagisce con una o più "pagine" mediante le quali si consultano dati o si immettono input. Ovviamente la realizzazione di Activity è il punto di partenza di ogni corso di programmazione Android visto che è il componente con cui l'utente ha il contatto più diretto.
Le Activity nel loro complesso costituiscono il flusso in cui l'utente si inoltra per sfruttare le funzionalità messe a disposizione. Questo richiede pertanto non solo la realizzazione delle interfacce in sé stesse, ma anche una corretta progettazione della navigazione tra di esse offrendo la possibilità di sfogliarne i contenuti e risalirli gerarchicamente in maniera coerente.




#. Service:
Un Service svolge un ruolo, se vogliamo, opposto all'Activity (sebbene, a livello di ereditarietà di classe siano imparentati). Infatti rappresenta un lavoro – generalmente lungo e continuato - che viene svolto interamente in background senza bisogno di interazione diretta con l'utente. Ad esempio, un'app che permette di avviare un audio che non si interrompe alla chiusura della sua interfaccia con tutta probabilità basa il suo funzionamento su un Service.
I loro usi sono dei più disparati e, a seconda dei casi, l'utente potrebbe anche non notare il loro avvio ottenendone però i benefici. Da una punto di vista strutturale, i Service sono di due tipologie: started e bounded. 

#. Service Started:
I Service Started, vengono attivati quando un'app ha bisogno di svolgere attività in background, mirate ad uno scopo specifico, fino al loro completamento.
Service Started avviate startService(), non hanno interazione e proseguono finchè non vengono interrotti.
I Service Started sono da predilligere per operazioni con una loro finalità indipendente dallo stato delle altre applicazioni. Si potrebbero occupare di aggiornamenti dati in background, scaricamento di file o immagini, sincronizzazione remota verso server esterni, etc. Considerando che il service Started rimarrà in background a lungo la sua esistenza deve essere giustificata dalla finalità preposta.

#. Service Bounded:
I Service Bounded, vengono attivati solo nel caso in cui un'altra app abbia bisogno di connettersi a loro. Si tratta di un tipo di Service che permette l'interazione tra processi differenti e risponde ad una logica simile a quella delle API nei servizi web.
Service Bound vivono in modalità client-server. Hanno senso se qualche componente si collega e vengono interrotti solo se non ci sono piu client collegati.
I Service Bound svolgono il ruolo di supporto ad altre applicazioni. Non rischiano pertanto di essere “dimenticati” in background come potrebbe malauguratamente succedere agli Started ma non sono adatti a lavori da eseguire continuamente in background.

Chi gestisce tutti i dati relativi all'attività da svolgere mediante il JobScheduler è un oggetto JobInfo in cui sono specificate tutte le condizioni che determinano l'avvio del task. I passi che permettono di attivare un'attività asincrona sono:

- definizione di una classe derivata da JobService in cui verranno specificate le attività da svolgere in maniera asincrona;
- creazione di un oggetto JobInfo cui sarà collegato il JobService del punto precedente;
inserimento del JobInfo nello JobScheduler mediante l'invocazione del metodo schedule;
- attivazione del task asincrono non appena i criteri specificati nel JobInfo saranno soddisfatti.

Si noti inoltre che anche questo settore è stato rivoluzionato negli anni, in particolare con la nascita dei JobScheduler che permettono lavori in background con un uso parsimonioso della batteria.








#. Content Provider:
Un Content Provider nasce con lo scopo della condivisione di dati tra applicazioni. La sua finalità richiama quel principio di sicurezza dell'applicazione di cui si è trattato poco fa. Questi componenti permettono di condividere, nell'ambito del sistema, contenuti custoditi in un database, su file o reperibili mediante accessi in Rete. Tali contenuti potranno essere usati da altre applicazioni senza invadere lo spazio di memoria ma stabilendo quel dialogo “sano” cui si è accennato.
I Content Provider sono riconoscibili mediante un URI, un riferimento univoco. Questi indirizzi sono costituiti da due parti:
- authority: è il nome del Provider in generale. Spesso, per evitare conflitti, richiama il nome del package Java di appartenenza.
- path: costituisce un percorso interno alla singola authority. Spesso rappresenta una tabella del database cui si vuole accedere ma, in generale, indica la tipologia di dati su cui agire.

ContentProvider molto noti del sistema opearativo sono:
- Contacts: include tutte le informazioni sui contatti dell'utente: rubrica telefonica, email, etc.
- MediaStore: gestisce dati relativi a file multimediali contenuti nel sistema tra cui file audio, immagini e video;
- UserDictionary: si occupa delle parole aggiunte dall'utente al dizionario di default;
- Calendar: serve a gestire appuntamenti ed eventi sul calendario del dispositivo eventualmente sincronizzato con l'account Google.



#. Broadcast Receiver:
Un Broadcast Receiver è un componente che reagisce ad un invio di messaggi a livello di sistema (appunto in broadcast), con cui Android notifica l'avvenimento di un determinato evento, ad esempio l'arrivo di un SMS o di una chiamata o sollecita l'esecuzione di azioni. Questi componenti come si può immaginare sono particolarmente utili per la gestione istantanea di determinate circostanze speciali.
I Broadcast Receiver non utilizzano interfaccia grafica sebbene possano inoltrare notifiche alla barra di stato per avvisare l'utente dell'avvenimento.
Inoltre la loro esecuzione dovrebbe essere istantanea delegando a Service o JobScheduler eventuali operazioni da attivare.




#. Intent:
Molto importante ricordare che una componente può attivarne un'altra mediante apposite invocazioni di sistema. Questa intenzione viene codificata con un Intent utilizzabile come normale classe Java ma che sottintende un potentissimo strumento di comunicazione di Android. Anche degli Intent faremo uso sin dai prossimi articoli.

I processi possono essere classificati, in ordine di importanza decrescente, come:

- Processi in "foreground": sono quelli che  interagiscono direttamente o indirettamente con l'utente. Stiamo parlando delle applicazioni che, ad esempio,  contengono l'Activity attualmente utilizzata o i Service ad essa collegati. Questi sono i processi che Android tenterà di preservare maggiormente. Importante notare che, comunque, anche le applicazioni in foreground non sono del tutto al sicuro. Se ad esempio il sistema non disponesse di risorse sufficienti a mantenerli tutti in vita, si troverebbe costretto ad arrestarne qualcuno;

- Processi visibili: non sono importanti come quelli in foreground ma vengono anch'essi grandemente tutelati da Android. Infatti, avendo componenti ancora visibili all'utente anche se non vi interagiscono più, svolgono comunque un ruolo particolarmente critico. Anche in questo caso si tratta di Activity visibili e Service ad esse collegati;

- Processi "service": contengono dei service in esecuzione che generalmente svolgono lavori molto utili all'utente anche se non direttamente collegati con ciò che egli vede nel display. Il loro livello di priorità può essere considerato medio: importanti sì ma non tanto quanto i processi di cui ai precedenti due punti;

- Processi "cached": sono l'ultima categoria e rappresentano processi che non servono più a nulla. Tra questi vengono selezionati quelli da abbattere e finché il sistema operativo non affronta una fase di difficoltà non ha bisogno di eliminare processi di altre categorie se non di questa. I cached process eliminati non rischiano di impattare minimamente sulla user experience e spesso contengono Activity che non sono più visibili.



#. Directory Structure:
L'architettura di progetto così impostata è costituita da un certo numero di file e cartelle.
Tutti sono importanti ma gli elementi tra i quali il programmatore dovrà sapersi muovere al più presto con scioltezza sono:
• la cartella "src" che conterrà tutto il codice Java che scriveremo.
• la cartella "res" in cui risiederanno le cosiddette risorse dell'applicazione per la maggior parte configurate in XML ma non solo.
• il file "AndroidManifest.xml" anch'esso in XML che custodirà configurazioni e ruoli dei componenti della nostra app.





###. Fundamental Details:


#. Activity - Interfaccia utente:
Il codice Java che realizza l'Activity risiede nella cartella src, come spiegato in precedenza. Il contenuto di un tipico “Hello world” potrebbe essere questo:

public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}
La classe si chiama MainActivity ed estende AppCompatActivity. Al suo interno viene implementato l'override del metodo onCreate. Per il momento, ci accontentiamo di sapere che questo metodo viene invocato alla creazione dell'Activity. Più avanti scopriremo che si tratta di una tappa fondamentale del ciclo di vita di questo tipo di componenti.

A proposito delle due righe di codice presenti all'interno dell'onCreate:

- super.onCreate(savedInstanceState): invoca il metodo omonimo della classe base.
- setContentView(R.layout.activity_main): specifica quale sarà il “volto” dell'Activity, il suo layout. Al momento la dicitura R.layout.activity_main. Il suo effetto è quello di imporre come struttura grafica dell'Activity il contenuto del file activity_main.xml presente nella cartella res/layout.

#. Activity Launched:
onCreate()
onStart() / onRestart()
onResume()

- onCreate: l'activity viene creata. Il programmatore deve assegnare le configurazioni di base e definire quale sarà il layout dell'interfaccia.
- onStart: l'activity diventa visibile. È il momento in cui si possono attivare funzionalità e servizi che devono offrire informazioni all'utente.
- onResume: l'activity diventa la destinataria di tutti gli input dell'utente.



#. Activity Running:
onPause()
onStop()
onDestroy()

- onPause: (l'inverso di onResume) notifica la cessata interazione dell'utente con l'activity.
- onStop: (contraltare di onStart) segna la fine della visibilità dell'activity.
- onDestroy: (contrapposto a onCreate) segna la distruzione dell'activity.
- onSaveInstanceState: chiamato durante la messa in pausa dell'Activity, si può effettuare il salvataggio mentre in onRestoreInstanceState: invocato in fase di start dell'Activity, verrà consegnato il Bundle con i dati salvati nella sessione precedente, ed il programmatore avrà la possibilità di utilizzarli per ripristinare lo stato dell'Actvity.






#. Application Manifest.XML

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="it.html.helloworld">
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>

#. Manifest
Il nodo <application> contiene le componenti usate nell'applicazione. In questo caso, c'è un nodo <activity> che con l'attributo android:name specifica il nome della classe Java che incarna l'Activity. Se, come in questo caso, non viene specificato un package è sottintesa l'appartenenza della classe al package riportato nel nodo <manifest>, la root del file.

#. Intent
Intent trasporta i dati, quindi per passare dati da un activity ad un'altra, devo creare un Intent a cui aggancio l'activity che voglio invocare e al quale voglio passare i dati.
Dopo aver creato l'intent, e agganciata l'activity, lo lancio dalla mia activity "locale" con lo start(Activity)

#. Intent-Filter
Il costrutto intent-filter specifica che l'activity può essere lanciata da un intent specifico soggetto a filtri.
Un componente dell'app deve dichiarare filtri separati per ogni job univoco che può eseguire. Ad esempio, un'attività in un'app galleria immagini può avere due filtri: un filtro per visualizzare un'immagine e un altro per modificare un'immagine. Quando inizia l'attività, controlla il Intent e decide come comportarsi in base alle informazioni nell' Intent (ad esempio, mostrare o meno i controlli dell'editor).

Ogni filtro per intent è definito da un elemento <intent-filter> nel file manifest dell'app, nidificato nel componente dell'app corrispondente (ad esempio un elemento <activity>).

In ogni componente dell'app che include un elemento <intent-filter>, imposta esplicitamente un valore per android:exported. Questo attributo indica se il componente dell'app è accessibile ad altre app. In alcune situazioni, ad esempio le attività i cui filtri per intent includono la categoria LAUNCHER, è utile impostare questo attributo su true. In caso contrario, è più sicuro impostare questo attributo su false.

Avviso: se un ricevitore di attività, un servizio o una trasmissione nella tua app utilizza filtri per intent e non imposta esplicitamente il valore di android:exported, l'app non può essere installata su un dispositivo con Android 12 o versioni successive, alternativamente il valore di default sarà true.

All'interno di <intent-filter>, puoi specificare il tipo di intent da accettare utilizzando uno o più di questi tre elementi:

#. Intent Filter - Action:
Action='MAIN', indica che l'activity può essere lanciata da un action "Main" che non presenta dati settati nell'intent.

#. Intent Filter - Category:
Category='LAUNCHER' significa che deve essere un intent di avvio, in quanto l'activity verrà lanciata durante l'avvio del sistema che accoglierà l'utente all'ingresso nell'applicazione.

#. Activity - Exported
Quando imposti android:exported="true" per un particolare componente nel tuo file AndroidManifest. xml, significa che è possibile accedere al componente da componenti esterni all'applicazione. Al contrario, l'impostazione android:exported="false" limita l'accesso al componente solo ai componenti all'interno della tua applicazione.



#. Directory Structure:
Cartella res contiene tutte le cartelle contenenti le risorse: layout, values, drawable, mipmap.

• layout: 
conterrà l'architettura grafica dei componenti dell'interfaccia utente. Sono definiti in XML in una maniera simile a come viene usato HTML per strutturare le pagine web.

• values: 
conterrà stringhe, colori, dimensioni e altre tipologie di valori che potranno essere usate in ulteriori risorse o nel codice Java. Importante notare che questi valori costituiranno il contenuto di appositi tag XML (<string>, <dimen>, etc.) raggruppati  in files dal nome solitamente indicativo:  strings.xml, dimens.xml, colors.xml e via dicendo. Tali nomi sono frutto di pura convenzione ma il programmatore può scegliere liberamente come chiamarli.

• drawable:
sono immagini nei formati più comuni o, cosa che può stupire, configurate in XML.

• mipmap:
sono immagini che costituiscono l'icona dell'applicazione, quella con cui viene lanciata da sistema operativo. Un tempo erano collocate tra i drawable ma successivamente gli è stata dedicata una sezione a parte tra le risorse.


Mediante i loro identificativi, le risorse sono accessibili sia da codice Java che da altre risorse definite in XML:

- Java: R.tipo_risorsa.nome_risorsa;
<string android:name="appname">Hello world!</string>
@Java - R.string.appname

- XML: @tipo_risorsa/nome_risorsa.
Ad esempio, la risorsa di tipo stringa e nome appname:
<string android:name="appname">Hello world!</string>
@XML - @string/appname 




#. Intent - Depth:
Rappresentano una forma di messaggistica gestita dal sistema operativo con cui una componente può richiedere l'esecuzione di un'azione da parte di un'altra componente.
Tre casistiche:
- Activity: avviare un'Activity.
- Service: avviare un Service.
- Broadcast Receiver: inviare un messaggio in broadcast che può essere ricevuto da ogni applicazione.

# Intent - Activity:
Un Activity rappresenta una singola schermata in un'app. Puoi avviare una nuova istanza di un Activity passando un Intent a startActivity(). Intent descrive l'attività da avviare e trasporta tutti i dati necessari.
Per ricevere un risultato dall'attività al termine, chiama startActivityForResult().
La tua attività riceve il risultato come oggetto Intent separato nel callback onActivityResult() dell'attività. Per ulteriori informazioni.

# Intent - Service:
Un Service è un componente che esegue operazioni in background senza un'interfaccia utente. Con Android 5.0 (livello API 21) e versioni successive, puoi avviare un servizio con JobScheduler.
Per le versioni precedenti ad Android 5.0 (livello API 21), puoi avviare un servizio utilizzando i metodi della classe Service. Puoi avviare un servizio per eseguire un'operazione una tantum (ad esempio il download di un file) passando un Intent a startService(). Intent descrive il servizio per l'avvio e trasporta tutti i dati necessari.
Se il servizio è progettato con un'interfaccia client-server, puoi associarlo al servizio da un altro componente passando un Intent a bindService().

# Intent - SendBroadcast:
Un annuncio è un messaggio che qualsiasi app può ricevere. Il sistema invia varie trasmissioni per eventi di sistema, ad esempio l'avvio del sistema o la ricarica del dispositivo. Puoi trasmettere una trasmissione ad altre app passando un Intent a sendBroadcast() o sendOrderedBroadcast().


Intent: espliciti e impliciti.

#. Intent Espliciti: 
Viene dichiarato quale componente dovrà essere attivata. Particolarmente utili nell'apertura di una nuova Activity.
Il nome del componente da cui iniziare è facoltativa, ma è l'informazione fondamentale che rende un intent esplicito, ovvero l'intent deve essere pubblicato solo nel componente dell'app definito dal suo nome. Senza un nome, l'intent è implicito e il sistema decide quale componente deve riceverlo in base alle altre informazioni sull'intent, ad esempio l'azione, i dati e la categoria, descritti di seguito. Se devi avviare un componente specifico nell'app, devi specificarne il nome.

#. Intent Impliciti:
Non specificano una componente da attivare ma quale azione deve essere svolta. La loro invocazione si estrinseca spesso nell'apertura di una finestra di dialogo che chiede all'utente quale app vuole si apra per completare l'azione.
Senza un nome specifico associato all'activity/service, l'intent è implicito e il sistema decide quale componente deve riceverlo in base alle altre informazioni sull'intent, ad esempio l'azione, i dati e la categoria, descritti di seguito. Se devi avviare un componente specifico nell'app, devi specificarne il nome.

Un Intent è un oggetto di messaggistica che puoi utilizzare per richiedere un'azione da un altro componente dell'app. Sebbene gli intent facilitino la comunicazione tra i componenti in diversi modi, esistono tre casi d'uso fondamentali:



#. Extras - Intent:
Intent custodiscono dati che possono essere letti dal destinatario chiamati Extras negli Intent funziona in maniera simile ad una struttura dati a mappa: con dei metodi put viene inserito un valore etichettato con una chiave e con i corrispondenti metodi get viene prelevato il valore, richiedendolo mediante la chiave di riconoscimento.
A livello di codice, nella MainActivity, una volta ottenuto il successo nel login troveremo:

Intent i=new Intent(this,SecretActivity.class);
i.putExtra("username", account_username);
startActivity(i);

Le tre operazioni rappresentano:
- Dichiarazione dell'Intent come normale oggetto Java. In questo caso avremo un cosiddetto intent esplicito in quanto appare chiaramente il nome della classe che verrà invocata. Viene inserito, tra gli Extras, una String, la variabile account_username, che sarà trasportata con l'Intent fino a destinazione ossia la classe SecretActivity. Lo scopo è inserire in questa stringa il nome dell'utente che ha effettuato il login. Notare che l'extra viene etichettato con una chiave, in questo caso “username”. Ciò perchè possono essere trasportati più Extras per ogni Intent e dovrà essere possibile distinguerli per utilizzarli.
Infine il metodo startActivity dimostra quale azione vogliamo attivare con questo Intent (in questo caso dell'avvio di un'Activity).
Nel metodo "onCreate" della seconda Activity, quella con il contenuto riservato, troveremo le seguenti righe:

Intent i=getIntent();
String username=i.getStringExtra("username");

Notiamo subito che l'Activity attivata si trova a disposizione, mediante getIntent(),  l'Intent che ne ha provocato l'attivazione. Lo può utilizzare per recuperare la stringa passata, contenente il nome utente.


#. Intent Filter:
Action, Data, Category, Extra

#.  Intent-Filter - Action:
Una stringa che specifica l'azione generica da eseguire (come view o pick o main).
Nel caso di un intent di trasmissione, questa è l'azione che è avvenuta e che viene segnalata. L'azione determina in gran parte il modo in cui è strutturato il resto dell'intent, in particolare le informazioni contenute nei dati e negli extra.
Dichiara l'azione intent accettata nell'attributo name. Il valore deve essere il valore letterale della stringa di un'azione, non la costante di classe.

<intent-filter>
        <action android:name="android.intent.action.MAIN"/>
        <category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>

Puoi specificare le tue azioni da utilizzare per gli intent all'interno dell'app (o da altre app per richiamare i componenti dell'app), ma in genere specifichi le costanti delle azioni definite dalla classe Intent o da altre classi di framework. Di seguito sono riportate alcune azioni comuni per avviare un'attività:

#. Action-Filter: Action - ACTION_MAIN
L'azione ACTION_MAIN indica che questo è il punto di ingresso principale e non prevede dati sugli intent

#. Action-Filter: Action - ACTION_VIEW
Utilizza questa azione in un intent con startActivity() se hai informazioni che un'attività può mostrare all'utente, ad esempio una foto da visualizzare in un'app Galleria o un indirizzo da visualizzare in un'app di mappe.

#. Action-Filter: Action - ACTION_SEND
Chiamato anche Intent Share, dovresti utilizzarlo in un intent con startActivity() quando disponi di alcuni dati che l'utente può condividere tramite un'altra app, ad esempio un'app email o un'app di condivisione sui social.
Consulta il riferimento della classe Intent per altre costanti che definiscono azioni generiche. Altre azioni sono definite altrove nel framework Android, ad esempio in Settings per le azioni che aprono schermate specifiche nell'app Impostazioni del sistema.
Puoi specificare l'azione per un intent con setAction() o con un costruttore Intent.




#.  Intent-Filter - Data:
L'URI (un oggetto Uri) che fa riferimento ai dati su cui eseguire azioni e/o il tipo MIME di tali dati. Il tipo di dati forniti è generalmente dettato dall'azione dell'intent. Ad esempio, se l'azione è ACTION_EDIT, i dati devono contenere l'URI del documento da modificare.
Quando crei un intent, spesso è importante specificare il tipo di dati (il tipo MIME) oltre al relativo URI. Ad esempio, un'attività in grado di visualizzare immagini probabilmente non sarà in grado di riprodurre un file audio, anche se i formati URI potrebbero essere simili. La specifica del tipo MIME dei dati consente al sistema Android di trovare il componente migliore per ricevere il tuo intent. Tuttavia, a volte il tipo MIME può essere dedotto dall'URI, in particolare quando i dati sono un URI content. 
Un URI content: indica che i dati si trovano sul dispositivo e sono controllati da un elemento ContentProvider, che rende visibile al sistema il tipo MIME dei dati.
Per impostare solo l'URI dei dati, chiama setData(). Per impostare solo il tipo MIME, chiama setType(). Se necessario, puoi impostarli entrambi esplicitamente con setDataAndType().
Dichiara il tipo di dati accettato utilizzando uno o più attributi che specificano i vari aspetti dell'URI dei dati (scheme, host, port, path) e del tipo MIME.



#.  Intent-Filter - Category:
Una stringa contenente informazioni aggiuntive sul tipo di componente che dovrebbe gestire l'intent. In un intent può essere inserito un numero qualsiasi di descrizioni di categorie, ma la maggior parte degli intent non richiede una categoria. Ecco alcune categorie comuni.
Dichiara la categoria di intent accettata nell'attributo name. Il valore deve essere il valore letterale della stringa di un'azione, non la costante di classe.
Nota:per ricevere intent impliciti, devi includere la categoria CATEGORY_DEFAULT nel filtro per intent. I metodi startActivity() e startActivityForResult() trattano tutti gli intent come se avessero dichiarato la categoria CATEGORY_DEFAULT. Se non dichiari questa categoria nel filtro per intent, nessun intent implicito si risolverà nella tua attività.

#. Intent-Filter - Category: CATEGORY_ BROWSABLE
L'attività target consente di essere avviata da un browser web per mostrare dati a cui fa riferimento un link, come un'immagine o un messaggio email.

#. Intent-Filter - Category: CATEGORY_ LAUNCHER
L'attività è l'attività iniziale di un'attività ed è elencata in Avvio applicazioni del sistema.
Consulta la descrizione della classe Intent per l'elenco completo delle categorie.
Puoi specificare una categoria con addCategory().
<intent-filter>
    <action android:name="android.intent.action.MAIN"/>
    <category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>

Le proprietà elencate sopra (nome del componente, azione, dati e categoria) rappresentano le caratteristiche distintive di un intent. Leggendo queste proprietà, il sistema Android riuscirà a stabilire il componente dell'app da avviare. Tuttavia, un intent può includere informazioni aggiuntive che non influiscono sul modo in cui viene risolto in un componente dell'app. Un intent può anche fornire le seguenti informazioni:
Ad esempio, ecco una dichiarazione di attività con un filtro per intent per ricevere un intent ACTION_SEND quando il tipo di dati è di tipo testuale:

<activity android:name="ShareActivity" android:exported="false">
    <intent-filter>
        <action android:name="android.intent.action.SEND"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:mimeType="text/plain"/>
    </intent-filter>
</activity>
Puoi creare un filtro che include più istanze di <action>, <data> o <category>. In questo caso, devi assicurarti che il componente sia in grado di gestire tutte le combinazioni di questi elementi filtro.

Se vuoi gestire più tipi di intent, ma solo in combinazioni specifiche di azione, dati e tipo di categoria, devi creare più filtri per intent.

Extra:
Coppie chiave-valore che contengono informazioni aggiuntive necessarie per eseguire l'azione richiesta. Proprio come alcune azioni utilizzano tipi particolari di URI di dati, anche alcune azioni utilizzano particolari extra.
Puoi aggiungere altri dati con vari metodi putExtra(), ognuno dei quali accetta due parametri: il nome della chiave e il valore. Puoi anche creare un oggetto Bundle con tutti i dati aggiuntivi, quindi inserire Bundle in Intent con putExtras().

Ad esempio, quando crei un intent per inviare un'email con ACTION_SEND, puoi specificare il destinatario to con la chiave EXTRA_EMAIL e specificare l'oggetto con la chiave EXTRA_SUBJECT.

La classe Intent specifica molte costanti EXTRA_* per i tipi di dati standardizzati. Se devi dichiarare chiavi aggiuntive (per gli intent ricevuti dalla tua app), assicurati di includere il nome del pacchetto dell'app come prefisso, come mostrato nell'esempio seguente:




#. Intent Implicito - Manifest.xml

Ricezione di un Intent implicito
Per pubblicizzare gli intent impliciti che la tua app può ricevere, dichiara uno o più filtri di intent per ciascuno dei componenti dell'app con un elemento <intent-filter> nel file manifest. Ogni filtro per intent specifica il tipo di intent che accetta in base all'azione, ai dati e alla categoria dell'intent. Il sistema fornisce un intent implicito al componente dell'app solo se l'intent può passare attraverso uno dei filtri per intent.

Nota: un intent esplicito viene sempre pubblicato nel relativo target, indipendentemente dagli eventuali filtri per intent dichiarati dal componente.

Un intent implicito viene testato rispetto a un filtro confrontando l'intent con ciascuno dei tre elementi. Per essere pubblicato nel componente, l'intent deve superare tutti e tre i test. Se non riesce a trovare nemmeno uno di questi elementi, il sistema Android non trasmetterà l'intent al componente. Tuttavia, poiché un componente può avere più filtri per intent, un intent che non passa attraverso uno dei filtri di un componente potrebbe farlo in un altro filtro. Maggiori informazioni su come il sistema risolve gli intent sono fornite nella sezione di seguito sulla risoluzione degli intent.

Filtri di esempio
Per dimostrare alcuni comportamenti del filtro per intent, ecco un esempio tratto dal file manifest di un'app per la condivisione sui social:
<activity android:name="MainActivity" android:exported="true">
    <!-- This activity is the main entry, should appear in app launcher -->
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>

<activity android:name="ShareActivity" android:exported="false">
    <!-- This activity handles "SEND" actions with text data -->
    <intent-filter>
        <action android:name="android.intent.action.SEND"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:mimeType="text/plain"/>
    </intent-filter>
    <!-- This activity also handles "SEND" and "SEND_MULTIPLE" with media data -->
    <intent-filter>
        <action android:name="android.intent.action.SEND"/>
        <action android:name="android.intent.action.SEND_MULTIPLE"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:mimeType="application/vnd.google.panorama360+jpg"/>
        <data android:mimeType="image/*"/>
        <data android:mimeType="video/*"/>
    </intent-filter>
</activity>
La prima attività, MainActivity, è il punto di ingresso principale dell'app, ovvero l'attività che si apre quando l'utente avvia per la prima volta l'app con l'icona in Avvio applicazioni:
• L'azione ACTION_MAIN indica che questo è il punto di ingresso principale e non prevede dati sugli intent.
• La categoria CATEGORY_LAUNCHER indica che l'icona di questa attività deve essere posizionata in Avvio applicazioni del sistema. Se l'elemento <activity> non specifica un'icona con icon, il sistema utilizza l'icona dell'elemento <application>.
Questi due dispositivi devono essere accoppiati per consentire la visualizzazione dell'attività in Avvio applicazioni.
La seconda attività, ShareActivity, ha lo scopo di facilitare la condivisione di testo e contenuti multimediali. Anche se gli utenti possono accedere a questa attività accedendovi da MainActivity, possono anche inserire ShareActivity direttamente da un'altra app che genera un intent implicito che corrisponde a uno dei due filtri per intent.

L'intent può non specificare una specifica app/package, in tal caso ogni applicazione potrebbe processare l'intent.
Se esistono molteplici intent tra piu APP, nella resolution dell'intents, a parità di data, category viene scelto l'app con il SYSTEM_HIGH_PRIORITY value maggiore.





#. Permissions:
Un'applicazione Android vive in all'interno di una sandbox, ovvero un ambiente chiuso in cui l'applicazione opera in maniera sostanzialmente isolata dal resto del sistema. Talvolta, però, può essere necessario che essa debba "uscire" da questa gabbia per accedere a informazioni, funzionalità o apparati hardware del dispositivo. Per far sì che l'app acceda a tali servizi, essa deve possedere alcuni "permessi" speciali - le cosiddette permission - che è necessario dichiarare espressamente nel file AndroidManifest.xml. 
Ogni permission viene dichiarata tramite il tag <uses-permission>, da collocare al di fuori del nodo <application>


<manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="...." >
<uses-permission android:name="android.permission.INTERNET" />
<application>
...
...
</application>
...
</manifest>



###. Permissions:
Le permission Android vengono suddivise in tre famiglie in base al livello di protezione:


#. Permission Normal:
Non mettono cioè a rischio la privacy dell'utente, tra le quali troviamo:
- android.permission.INTERNET: accesso alla Rete
- android.permission.ACCESS_NETWORK_STATE: verifica dello stato della rete
- android.permission.ACCESS_WIFI_STATE: accesso alle informazioni sulle reti Wi-Fi

- accesso a particolari tecnologie per la connettività:
android.permission.BLUETOOTH, android.permission.BLUETOOTH_ADMIN,android.permission.NFC.
- invio di un Intent per l'impostazione di un allarme: com.android.alarm.permission.SET_ALARM;
- gestione della vibrazione (android.permission.VIBRATE) o del WaveLock per il controllo dello stand-by (android.permission.WAVE_LOCK);
- molte altre: una lista completa è disponibile sulla documentazione ufficiale.


#. Permission Dangerous:
Potenzialmente più lesive della riservatezza degli utenti, come quelle riguardanti:
• la localizzazione: android.permission.ACCESS_FINE_LOCATION, android.permission.ACCESS_COARSE_LOCATION.
• il calendario: android.permission.READ_CALENDAR, android.permission.WRITE_CALENDAR.
• i contatti: android.permission.READ_CONTACTS e android.permission.WRITE_CONTACTS.
• attività telefoniche: ad esempio, android.permission.READ_PHONE_STATE e android.permission.SEND_SMS.
• accesso ai file: android.permission.READ_EXTERNAL_STORAGE e android.permission.WRITE_EXTERNAL_STORAGE.


#. Permission Signature:
Gestite a livello di installazione ma utilizzabili solo se l'app che le richiede è firmata con lo stesso certificato di quella che ha definito la permission.

Per sviluppare app moderne, quindi, è necessario gestire le permission a runtime, verificando se esse siano revocate o meno, nonchè richiedendo all'utente di abilitarle.
La classe ContextCompat, inclusa nella libreria di supporto, mette a disposizione un metodo per effettuare questo tipo di controllo:

int statoPermission = ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION);







###. GUI:
Interfaccia grafica può essere creata tramite HTML (procedura dichiarativa), descrittore XML (procedura dichiarativa), codice Java (metodo procedurale).


#. Fragment:
I Fragment costituiscono senz'altro uno dei più importanti elementi per la creazione di una interfaccia utente Android moderna. Il loro ruolo a partire da Android 3.0 è diventato preponderante tanto che ormai rappresentano una delle conoscenze più importanti per il programmatore.

Un Fragment è una porzione di Activity. Ma si faccia attenzione a comprenderne bene il ruolo. Non si tratta solo di un gruppo di controlli o di una sezione del layout. Può essere definito più come una specie di sub-activity con un suo ruolo funzionale molto importante ed un suo ciclo di vita.



#. Fragments vs Activity
Definiamo subito il rapporto tra Fragments e Activity.

Prima di tutto un Fragment non può vivere senza un'Activity. Tipicamente nei nostri programmi creeremo più Fragments che si alterneranno nel layout mentre di Activity ne sarà sufficiente una (ma possono essere anche di più).
Come detto il Fragment ha il suo ciclo di vita fortemente collegato con quello dell'Activity di appartenenza.
La figura qui riportata mostra la sequenza di stati che scandiscono la vita del Fragment.
I Fragments possono essere visti come blocchi componibili che permettono di rendere il layout adattabile al dispositivo. Se la frammentazione dei dispositivi rappresenta una problematica di rilievo per i programmatori Android, i Fragments rappresentano in buona parte una soluzione.

• Fragments collegati tra loro il minimo possibile per permetterne un maggior riutilizzo.
• Activity usata per lo più come snodo di comunicazione tra Fragments.
• Risorse in grado di separare all'origine i layout distinguendo con id diversi i contenitori dei Fragments.
• Ogni classe Fragment deve avere sin dalla nascita uno scopo ben preciso e contenere in sé tutta la logica necessaria per raggiungerlo in maniera indipendente.




Storage:
Internal Storage vs External Storage.
Internal Storage:
Ogni app ha un suo Internal Storage accessibli da /data/data/package_java_app/files

ExternalStorage:
Tutte le risorse di utilità collettiva e consultazione generale (musica, suonerie, film), solitamente collocato su una SD card al sistema

Storage Esterno:
La prima operazione da svolgere è controllare lo stato del supporto. Lo si fa con il metodo statico String Environment.getExternalStorageState().

La stringa restituita può avere una molteplicità di valori, tutti associati a costanti della classe Environment. Evitando di elencarli tutti, teniamo presente solo che due valori in particolare ci dicono che il supporto può essere usato:

Environment.MEDIA_MOUNTED: il caso migliore. Supporto disponibile in lettura/scrittura;
Environment.MEDIA_MOUNTED_READ_ONLY: il supporto è disponibile ma solo in lettura.


Gestione Thread:
AsyncTask che, a suo modo, permette di avviare attività asincrone a supporto dell'interfaccia utente. I task gestiti da questa classe non dovrebbero essere molto lunghi, “a few seconds at the most” ('pochi secondi al massimo') come dichiara esplicitamente la documentazione ufficiale.


Keystore:
Il sistema Android Keystore ti permette di archiviare chiavi crittografiche in un contenitore per renderle più difficili da estrarre dal dispositivo. Una volta che le chiavi sono nel keystore, puoi utilizzarle per operazioni crittografiche, con il materiale della chiave che rimane non esportabile.

Ecco alcune caratteristiche chiave del sistema Android Keystore:

1. Prevenzione dell'estrazione: Il materiale della chiave non entra mai nel processo dell'applicazione. Quando un'app esegue operazioni crittografiche utilizzando una chiave Android Keystore, i dati in chiaro, il testo cifrato e i messaggi da firmare o verificare vengono gestiti da un processo di sistema che esegue le operazioni crittografiche. Se il processo dell'app viene compromesso, l'attaccante potrebbe utilizzare le chiavi dell'app, ma non può estrarre il loro materiale chiave (ad esempio, per utilizzarlo al di fuori del dispositivo Android). Inoltre, il materiale della chiave può essere vincolato all'hardware sicuro del dispositivo Android, come l'Ambiente di esecuzione attendibile (TEE) o l'Elemento sicuro (SE). Quando questa funzionalità è abilitata per una chiave, il suo materiale chiave non viene mai esposto all'esterno dell'hardware sicuro. Anche se il sistema operativo Android è compromesso o un attaccante può leggere la memoria interna del dispositivo, non può estrarre le chiavi Android Keystore dal dispositivo¹.

2. Autorizzazioni di utilizzo delle chiavi: Il sistema Keystore Android consente di limitare quando e come le chiavi possono essere utilizzate. Ad esempio, puoi richiedere l'autenticazione dell'utente per l'uso della chiave o limitare le chiavi all'utilizzo solo in determinate modalità crittografiche¹.

In sintesi, il sistema Android Keystore offre un livello di protezione per le chiavi crittografiche all'interno del dispositivo, rendendole più sicure e difficili da estrarre¹.

Origine: conversazione con Bing, 17/3/2024
(1) https://developer.android.com/privacy-and-security/keystore?hl=es-419.
(2) https://developer.android.com/privacy-and-security/keystore.
(3) https://developer.android.com/privacy-and-security/keystore?hl=zh-tw.
(4) https://source.android.com/docs/security/features/keystore?hl=zh-cn.
(5) https://developer.android.com/reference/java/security/KeyStore.










```