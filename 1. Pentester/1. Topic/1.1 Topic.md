
```
1. SELinux: SELinux è un sistema MAC integrato nel kernel Linux. È progettato per fornire un controllo capillare degli accessi alle risorse e alle applicazioni di sistema. SELinux funziona applicando una politica che definisce i controlli di accesso per ciascun processo e file sul sistema. Fornisce un livello di sicurezza più elevato limitando il danno che un processo compromesso può causare.    
    
2. AppArmor: AppArmor è anche un sistema MAC che fornisce un livello simile di controllo sulle risorse e sulle applicazioni di sistema, ma funziona in modo leggermente diverso. AppArmor è implementato come Linux Security Module (LSM) e utilizza i profili dell'applicazione per definire le risorse a cui un'applicazione può accedere. AppArmor è in genere più semplice da utilizzare e configurare rispetto a SELinux, ma potrebbe non fornire lo stesso livello di controllo capillare.  
    

3. Wrapper TCP: I wrapper TCP sono un meccanismo di controllo dell'accesso alla rete basato su host che può essere utilizzato per limitare l'accesso ai servizi di rete in base all'indirizzo IP del sistema client. Funziona intercettando le richieste di rete in entrata e confrontando l'indirizzo IP del sistema client con le regole di controllo degli accessi (ACL). Sono utili per limitare l'accesso ai servizi di rete da sistemi non autorizzati.    
    
4. SELinux vs AppArmor vs Wrapper TCP: Per quanto riguarda le somiglianze, i tre meccanismi di sicurezza condividono l'obiettivo comune di garantire la sicurezza e la protezione dei sistemi Linux. Oltre a fornire una protezione aggiuntiva, possono limitare l’accesso a risorse e servizi, riducendo così il rischio di accesso non autorizzato e violazione dei dati. Vale anche la pena notare che questi meccanismi sono prontamente disponibili come parte della maggior parte delle distribuzioni Linux, rendendoli accessibili a noi per migliorare la sicurezza dei loro sistemi. Inoltre, questi meccanismi possono essere facilmente personalizzati e configurati utilizzando strumenti e utilità standard, rendendoli una scelta conveniente per gli utenti Linux.  In termini di differenze, SELinux e AppArmor sono entrambi sistemi MAC che forniscono un controllo di accesso capillare sulle risorse di sistema ma funzionano in modi diversi. SELinux è integrato nel kernel ed è più complesso da configurare e utilizzare, mentre AppArmor è implementato come modulo ed è in genere più semplice da utilizzare. D'altro canto, i wrapper TCP sono un meccanismo di controllo dell'accesso alla rete basato su host progettato per limitare l'accesso ai servizi di rete in base all'indirizzo IP del sistema client. È un meccanismo più semplice di SELinux e AppArmor ma è utile per limitare l'accesso ai servizi di rete da sistemi non autorizzati.  
    
5. Shodan: Shodan può essere utilizzato per trovare dispositivi e sistemi permanentemente connessi a Internet come Internet of Things( IoT). Cerca in Internet porte TCP/IP aperte e filtra i sistemi in base a termini e criteri specifici. Ad esempio, apri le porte HTTP o HTTPS e altre porte del server per FTP, SSH, SNMP, Telnet, RTSP, O SIPvengono perquisiti. Di conseguenza, possiamo trovare dispositivi e sistemi, come ad esempio surveillance cameras, servers, smart home systems, industrial controllers, traffic lightsE traffic controllerse vari componenti di rete.  
    
6. TCPWrapped Un programma di controllo dell'accesso alla rete basato su host su Unix e Linux. Quando Nmap etichetta qualcosa tcpwrapped , significa che il comportamento della porta è coerente con quello protetto da tcpwrapper. In particolare, significa che è stato completato un handshake TCP completo, ma l'host remoto ha chiuso la connessione senza ricevere alcun dato. È importante notare che tcpwrapper protegge i programmi , non le porte . Ciò significa che una risposta tcpwrapped valida (non falsa positiva) indica che è disponibile un servizio di rete reale, ma non sei nell'elenco degli host autorizzati a parlare con esso. Quando un numero così elevato di porte viene mostrato come tcpwrapped , è improbabile che rappresentino servizi reali, quindi il comportamento probabilmente significa qualcos'altro.  
    
7. BootSetup:   Insieme dei processi eseguiti in fase di avvio  
    
8. Bootloader: In fase di start, si occupa di caricare il kernel del Sistema Operativo dal disco di massa (es. Hard disk), sulla RAM permettendo l'esecuzione da parte del processore e il conseguente avvio del sistema. Un pezzo di codice che viene eseguito per guidare il processo di avvio per avviare il sistema operativo. Parrot Linux utilizza il Bootloader GRUB. La funzione fondamentale di un boot loader è dunque caricare ed eseguire una kernel di sistema operativo, unitamente ai processi e servizi secondari. Nella maggior parte dei casi, questo richiede di accedere alla memoria di massa, per leggere il kernel di sistema operativo, e potenzialmente altri file. Nei casi più semplici, il boot loader contiene l'indirizzo dei blocchi di disco in cui sono memorizzati i file da caricare, e deve quindi essere aggiornato se questi file vengono modificati. L'accesso al disco spesso avviene attraverso le funzioni fornite dal firmware  
    
9. Firmware: Spesso il firmware consiste in più componenti software, che si occupano delle funzioni minimali necessarie a gestire la memoria non volatile e a caricare il bootloader. Offre quindi delle funzioni per l'accesso al disco. Il suo scopo è quello di avviare il componente stesso e consentirgli di interagire con altri componenti hardware tramite l'implementazione di protocolli di comunicazione o interfacce di programmazione. Rappresenta di fatto il punto di incontro fra le componenti logiche e fisiche di un dispositivo elettronico, ossia tra software e hardware. Software posto all'interno delle componenti elettroniche, fa da collante tra lo strato hardware e software.   Il suo scopo è quello di avviare il componente stesso e consentirgli di interagire con altri componenti hardware tramite l'implementazione di protocolli di comunicazione o interfacce di programmazione. Rappresenta di fatto il punto di incontro fra le componenti logiche e fisiche di un dispositivo elettronico, ossia tra software e hardware.   
    
10. Bios:  è il primo programma che viene eseguito dopo l'accensione, coinvolto pertanto nella fase di avvio del sistema di elaborazione si occupa di caricare il kernel del SO in memoria  
    
11. Kernel: E' il nucleo del sistema operativo, si occupa di gestire l'accesso dell'hardware ai vari processi in esecuzione sul computer Dato che possono eventualmente esserne eseguiti simultaneamente più di uno, il kernel può avere anche la responsabilità di assegnare una porzione di tempo-macchina (scheduling) e di accesso all'hardware a ciascun programma (multitasking). Il kernel è il componente principale di un sistema operativo. Gestisce le risorse per i dispositivi I/O del sistema a livello hardware. Il nucleo del sistema operativo Linux la cui funzione è virtualizzare e controllare le risorse hardware comuni del computer come CPU, memoria allocata, dati a cui si accede e altro. Il kernel fornisce a ciascun processo le proprie risorse virtuali e previene/mitiga i conflitti tra diversi processi.  
    
12. OS Shell: La shell del sistema operativo o l'interprete del linguaggio dei comandi (noto anche come riga di comando) è l'interfaccia tra il sistema operativo e l'utente. Questa interfaccia consente all'utente di dire al sistema operativo cosa fare. Le shell più comunemente usate sono Bash, Tcsh/Csh, Ksh, Zsh e Fish.  
    
13. Kali:   Distribuzione di Linux di offensive security basato su Debian    
    
14. NVME:  Protocollo di trasferimento per accedere ai dati velocemente da dispositivi storage con memoria flash  (memorie non volatili)  
    
15. CVSS:  Common vulnerability Scoring System è usato per misurare la severità della vulnerabilità   
    
16. CVE: Common Vulnerability Esposure  
    
17. Indirizzamento privato vs public:  Indirizzamento privato accessibile solo all'interno della rete: 10.0/8 172.16.0.0/17.31.255.255 192.168.0.0/16  Riservati: 0.0.0.0 - 0.255.255.255 127.0.0.0 - 127.255.255.255  
    
18. Rete DMZ  Rete Demilitarized Zone, ossia zona militare. Solitamente una rete viene "difesa" da un primo firewall, che a sua volta può definire una serie di porte e collegamenti.  Solitamente viene creata e suddivisa la rete, in rete locale e rete nel quale risiedono i server con delle policy per gestire gli accessi.  In questo modo vengono suddivise le aeree della rete e chi bypassa il filtro del firewall riesce ad accedere unicamente alla zona DMZ che potrebbe contenere es. I server.  
    
19. Memorizzazione chiave privata nel file di conf per SSH:  Per recuperare la chiave vado in home/vito/.ssh/id_rsa.pub oppure in root/.ssh/id e la copio e memorizzo sul server nel authorized_keys del .ssh.  Oppure posso inviargliela con ssh-id-copy user@hostname  
    
20. Active directory:   Una sorta di Database che definisce la modalità con cui vengono assegnate agli utenti tutte le risorse di rete attraverso i concetti di: account utente, account computer, cartelle condivise, stampanti di rete ecc. secondo l'assegnazione da parte dell'amministratore di sistema di Group Policy ovvero criteri di gruppo.  E' un database di Windows Server che offre molti servizi per garantire che gli utenti possano connettersi alle risorse di rete necessarie.  L’Active Directory è un insieme di servizi di rete meglio noti come directory service adottati dai sistemi operativi Microsoft. Si fonda sui concetti di dominio (inteso come un mondo in cui vengono concentrate tutte le risorse della rete a partire da: account utente, account computer, cartelle condivise, stampanti ecc) e di Directory. L’insieme dei servizi di rete di Active Directory, ed in particolare il servizio di autenticazione Kerberos, realizzano un’altra delle caratteristiche importanti: il Single Sign-On (SSO). Tramite tale meccanismo un utente, una volta entrato nel dominio ed effettuato quindi il login ad esso da una qualsiasi delle macchine di dominio, può accedere a risorse disponibili in rete (condivisioni, mailbox, intranet ecc.) senza dover effettuare nuovamente l’autenticazione. Questo facilita di molto la gestione degli utenti.   
    
21. Samba:  Software che usa il protocollo SMB, utilizzato per condividere file ed altro da un tra client SMB.  Permette l'interazione tra Windows ed altri sistemi (es. Unix like), fornendo così una piattaforma comune per l'impiego condiviso di risorse (server, client, gruppi, utenti, dischi, cartelle, stampanti e altri dispositivi hardware, ecc) - Porta 445.   
    
22. Domain Controller:  Domain controller (DC) è un server che, nell'ambito di un dominio, attraverso Active Directory (AD), gestisce le richieste di autenticazione per la sicurezza (login, controllo dei permessi, ecc.) e organizza la struttura del dominio in termini di utenti, gruppi e risorse di rete fornendo dunque un servizio di directory service. Un dominio può a sua volta far parte di un dominio di livello superiore il cui server, che esegue AD, si chiama Primary Domain Controller.   
    
23. SSH vs Telnet  
    

La differenza fondamentale tra Telnet e SSH è che SSH utilizza la crittografia, il che significa che tutti i dati trasmessi su una rete sono protetti dalle intercettazioni. SSH utilizza la crittografia a chiave pubblica per tali scopi. Come Telnet, un utente che accede a un dispositivo remoto deve disporre di un client SSH installato.   

24. DVWA:  Damn Vulnerability Web Application  apt install dvwa, dvwa-start  
    
25. Proxy Switcher:  Estensione per gestire il proxy   
    
26. Proxy Trasparent vs Proxy Forward:  Proxy Trasparent senza aggiungere informazione Proxy Forward la aggiunge l'informazione e non è trasparente  
    
27. Netcat:  Software che permette la comunicazione tra due host   
    
28. IDS - Intrusion Detective System:  Solitamente è un altro dispositivo differente dal Firewall da integrare. Es. Darktrace   
    
29. IPS – Intrusion Prevention System: Solitamente alcuni firewall come il fortinet ce l'hanno integrato.   
    
30. TOP 10 OWASP  A01:2021-Broken Access Control sale dalla quinta posizione; Il 94% delle applicazioni è stato testato per una qualche forma di controllo degli accessi interrotti. Le 34 enumerazioni di debolezza comune (CWE) associate a Broken Access Control avevano più occorrenze nelle applicazioni rispetto a qualsiasi altra categoria.  A02:2021-Cryptographic Failuresi passano di una posizione al n. 2, precedentemente noto come esposizione di dati sensibili, che era un sintomo generale piuttosto che una causa principale. La rinnovata attenzione qui è sui guasti legati alla crittografia che spesso portano all'esposizione di dati sensibili o alla compromissione del sistema.  
    

A03:2021-Injection scivola in terza posizione. Il 94% delle applicazioni è stato testato per una qualche forma di iniezione e i 33 CWE mappati in questa categoria hanno il secondo maggior numero di occorrenze nelle applicazioni. Cross-site Scripting fa ora parte di questa categoria in questa edizione.  A04:2021-Insecure Design è una nuova categoria per il 2021, con un focus sui rischi legati ai difetti di progettazione. Se vogliamo veramente "spostarci a sinistra" come settore, è necessario un maggiore utilizzo della modellazione delle minacce, modelli e principi di progettazione sicuri e architetture di riferimento.  A05:2021-Security Misconfiguration errata della sicurezza sale dal numero 6 dell'edizione precedente; Il 90% delle applicazioni è stato testato per qualche forma di configurazione errata. Con più passaggi a software altamente configurabili, non sorprende vedere questa categoria salire. La precedente categoria per XML External Entities (XXE) fa ora parte di questa categoria.  A06:2021-Vulnerable and Outdated Components era precedentemente intitolato Using Components with Known Vulnerabilities ed è al secondo posto nel sondaggio della community Top 10, ma disponeva anche di dati sufficienti per entrare nella Top 10 tramite l'analisi dei dati. Questa categoria sale dal numero 9 nel 2017 ed è un problema noto che facciamo fatica a testare e valutare il rischio. È l'unica categoria a non avere alcuna vulnerabilità ed esposizione comune (CVE) mappata ai CWE inclusi, quindi un exploit predefinito e pesi di impatto di 5.0 vengono presi in considerazione nei loro punteggi.  A07:2021-Identification and Authentication Failures era precedentemente Broken Authentication e sta scendendo dalla seconda posizione e ora include CWE che sono più correlati agli errori di identificazione. Questa categoria è ancora parte integrante della Top 10, ma la maggiore disponibilità di framework standardizzati sembra aiutare.  A08:2021-Software and Data Integrity Failure è una nuova categoria per il 2021, incentrata sulla formulazione di ipotesi relative ad aggiornamenti software, dati critici e pipeline CI/CD senza verificare l'integrità. Uno degli impatti con la ponderazione più alta dai dati Common Vulnerability and Exposures/Common Vulnerability Scoring System (CVE/CVSS) mappati ai 10 CWE in questa categoria. La deserializzazione insicura del 2017 fa ora parte di questa categoria più ampia.  A09:2021Security Logging and Monitoring Failures della sicurezza era in precedenza Registrazione e monitoraggio insufficienti e viene aggiunto dal sondaggio di settore (n. 3), passando dal precedente n. 10. Questa categoria è stata ampliata per includere più tipi di guasti, è difficile da verificare e non è ben rappresentata nei dati CVE/CVSS. Tuttavia, gli errori in questa categoria possono avere un impatto diretto sulla visibilità, sugli avvisi di incidenti e sulle analisi forensi.  A10:2021-Server-Side Request Forgery  - SSRF è stato aggiunto dal sondaggio della community Top 10 (n. 1). I dati mostrano un tasso di incidenza relativamente basso con una copertura dei test superiore alla media, insieme a valutazioni superiori alla media per il potenziale di sfruttamento e impatto. Questa categoria rappresenta lo scenario in cui i membri della comunità della sicurezza ci dicono che questo è importante, anche se al momento non è illustrato nei dati.  

31. Docker:  Docker ls: Visualizzo immagini docker  Docker pull 'nomeImmagine? : Recupera l'immagine dal dockerHub  Docker run 'nomeImmagine': Runna l'immagine docker  Docker ps: Visualizza tutti i container attivi/disattivi  Docker rm 'idContainer': Elimino container tramite Id  Docker build : Crea un immagine a partire da un dockerfile  
    
32. IpTable:  Comando che permette di indirizzare il traffico tramite una regola da un preciso IP ad un altro IP  
    
33. SecureStorageDB:  Password Manager  
    
34. OstorLab: Effettua la scansione dell'APK per trovare vulnerabilità.  Una delle vulnerabilità piu note, è quella che riguarda le API Key di Google in chiaro, che possono non avere il blocco per poter essere utilizzate unicamente dall'APP specifica (le keys di google iniziano con Aiza).   
    
35. MobSF: Tools per scann automatizzato Mobile   
    
36. HSTS:  Procedura che permette di dichiarare al Server Web che i browser devono accettare unicamente connessioni in http, avviene un reindirizzamento nel caso in cui venga richiamato con http su https. Specifica che protegge il web da attacchi di degrado della sicurezza. Flag sul server web che impedisce di passare da https a http per nessun componente ed evitare il SSL stripping.  
    
37. SSL Stripping SSL Stripping consiste nel fare man in the middle, e sfruttare la mancanza di HSTS per mettersi in mezzo ad una connessione HTTP. Una volta che gli aggressori ottengono l’accesso a una rete, possono agire come Man-in-the-Middle (MITM) per intercettare le connessioni sulla rete.  
    
38. About:Config Il browser firefox ha l'editor di configurazioni a cui si può fare accesso  
    
39. CORS:  Cross Origin Resource Sharing, è una modalità che regola l'accesso alle risorse condivise su di un server.  Tali risorse sono accessibili tramite delle regole.  Solitamente per accessi differenti dall'host di destinazione, viene effettuata una chiamata di pre-flight, ossia una Options per verificare la possibilità di effettuare la POST.  CORS implementa il SOP (Same Origin Policy), che indica quali origini possono fare le richieste.   
    

Es. Access-Control-Allow-Origin HTTP/1.1 200 OK Access-Control-Allow-Origin: https://normal-website.com Access-Control-Allow-Origin: * Access-Control-Allow-Credentials  Indica è stato implementato CORS, con l'indicazione di utilizzare delle credenziali per poter effettuare la chiamata (Authorization Bearer or cookie) HTTP/1.1 200 OK Access-Control-Allow-Origin: https://normal-website.com Access-Control-Allow-Credentials: true  

40. SOP - Same Origin Policy E' un meccanismo del browser che verifica se il mittente di origine è lo stesso del browser a cui si vuole accedere. Effettua dei check utilizzando lo schema mittente/destinatario (http -> http), dominio (normal-website.com/ -> normal-website.com) port number (80 -> 80). Questo meccanismo viene esteso ed arricchito dalla politica CORS.  
    
41. CSP – Content Security Policy:  Content Security Policy è una policy per mitigare attacchi XSS.  Il client può caricare JS unicamente se generati dal sito di origine. E' un meccanismo del browser che mira a mitigare l'impatto del cross-site scripting e di alcune altre vulnerabilità. Se un'applicazione che utilizza CSP contiene un comportamento simile a XSS, il CSP potrebbe ostacolare o impedire lo sfruttamento della vulnerabilità. Spesso, il CSP può essere aggirato per consentire lo sfruttamento della vulnerabilità sottostante.  Funziona limitando le risorse (come script e immagini) che una pagina può caricare e limitando se una pagina può essere incorniciata da altre pagine.  
    

Content-Security-Policy: La seguente direttiva consentirà solo agli script di essere caricati dalla stessa origine della pagina stessa:  Content-Security-Policy: policy, dove policy è una stringa di direttive di policy separate da punti e virgola.  Content-Security-Policy: script-src 'self', frame-ancestors 'self';  Content-Security-Policy: frame-ancestors normal-website.com;  

42. CSP - script-src 'self'  
    

La seguente direttiva consentirà solo agli script di essere caricati da un dominio specifico:  Content-Security-Policy: script-src [https://scripts.normal-website.com](https://scripts.normal-website.com/). Il browser Chrome ha deciso di affrontare gli attacchi di markup penzolanti impedendo a tag come imgla definizione di URL contenenti caratteri non elaborati come parentesi angolari e newline. Ciò impedirà gli attacchi poiché i dati che altrimenti verrebbero acquisiti conterranno generalmente quei caratteri non elaborati, quindi l'attacco viene bloccato.  Potresti incontrare un sito Web che riflette l'input nella politica effettiva, molto probabilmente in una report-uridirettiva.  Chrome ha recentemente introdotto la script-src-elemdirettiva, che consente di controllare script gli elementi, ma non gli eventi. Fondamentalmente, questa nuova direttiva consente di sovrascrivere le direttive esistenti script-src.   

43. CSP - frame-ancestors  La seguente direttiva consentirà solo alla pagina di essere incorniciata da altre pagine dalla stessa origine:  frame-ancestors 'self'   La seguente direttiva impedirà del tutto il framing:  frame-ancestors 'none'.   
    
44. CSP - X-Frame-Options (versione legacy del CSP - frame-ancestors) X – Frame-Options è la versione legacy del frame-ancestors implementato con il CSP. L'intestazione della risposta HTTP X-Frame-Options può essere utilizzata per indicare se a un browser deve essere consentito o meno di eseguire il rendering di una pagina in un <frame> , <iframe> , <embed> o <object> . I siti possono utilizzarlo per evitare attacchi di clickjacking, assicurandosi che il loro contenuto non sia incorporato in altri siti.  X-Frame-Options è stato originariamente introdotto come intestazione di risposta non ufficiale in Internet Explorer 8 ed è stato rapidamente adottato in altri browser. L'intestazione fornisce al proprietario del sito Web il controllo sull'uso di iframe o oggetti in modo che l'inclusione di una pagina Web all'interno di un frame possa essere vietata con la denydirettiva:  X-Frame-Options: deny In alternativa, il framing può essere limitato alla stessa origine del sito Web utilizzando la sameorigindirettiva.  X-Frame-Options: sameorigin o a un sito Web denominato utilizzando la allow-fromdirettiva: X-Frame-Options: allow-from [https://normal-website.com](https://normal-website.com/)  
    
45. X-Content-Type-Options L'intestazione HTTP della risposta X-Content-Type-Options è un indicatore utilizzato dal server per indicare che il browser non deve utilizzare il tipi MIME partendo dall'estensione del file, ma si deve fidare del Content-Type. L'intestazione consente di evitare lo sniffing del tipo MIME dicendo che i tipi MIME sono deliberatamente configurati. Se ho quindi un file .php che sono riuscito a caricare bypassando il check sul Content-Type inserendolo come text/plain, quando lo vado a richiedere al server mi darà nuovamente il .php che però io gestirò come testo e non verrà eseguito lo script.  
    
46. Regole di configurazioni server: Apache -> /etc/httpd/conf/httpd. Conf Apache (oppure sulla directory specifica, posso creare un file che permette di overridare le regole di default, ossia il file .htaccess in cui posso inserire tutti gli header supportati, i moduli per permettere l'esecuzione di codice es php, etc. Nginx -> /etc/nginx/nginx. Conf   
    
47. Regole configurazioni server + PUT FileUpload: Posso es. Andare a provare a settare nei file di config, dei moduli es. Php e fare una put senza il bisogno di avere un API dedicata per fare il file upload. Prendo un path in cui è stata fatta una GET, e vado a fare una OPTIONS per vedere se è possibile fare una PUT. Nel caso lo fosse posso sostituire quel file con un file magari .php   PUT /images/exploit.php HTTP/1.1  Host: vulnerable-website.com  Content-Type: application/x-httpd-php  Content-Length: 49   <?php echo file_get_contents('/path/to/file'); ?>  
    
48. Prevenzione Cookie: SameSite: Invia Cookie solo se sullo stesso sito, sito esterno, nessuno (Strict, Lact, None)  HttpOnly: Nascondo il Cookie da Javascript  Secure: Nascondo Cookie su connessioni HTTP   
    

setcookie("sessionid", "QmFieWxvbiA1", ['httponly' => true, 'secure' => true, 'samesite'=>'Strict']);  

49. HttpOnlyFlag - Cookie: Molte applicazioni nascondono i propri cookie da JavaScript utilizzando il HttpOnlyflag.  
    
50. Secure – Cookie: Inviano cookie solo se la connessione è sicura http (e non https).  
    
51. SameSite - Cookie:  Meccanismo di sicurezza che permette di includere il cookie proveniente da un sito in un altro sito.  Strict (solo stessa origine), Lax (stessa origine + external site), None (invio sempre).   
    
52. Trojan  Un malware che ha come obiettivo prendere possesso completo dell' host.  
    
53. IDOR – Insecure Direct Object References:  Accesso a dati indiretti tramite references  
    
54. WAF – Web Application Firewall:  Web Application Firewall per l'analisi statica del contenuto sulle WebApplication.  Per aggirarlo è necessario encoding o scandire il tempo tra un attacco ed un altro.  
    
55. IIES Server - CVE:  Nei vecchi sistemi windows (DOS), veniva utilizzato il formato 8.3, che aveva un numero limitato di 8 caratteri/ bit da poter utilizzare.  Le directory che venivano salvate con piu di 8 caratteri, venivano salvate con 6° carattere + "~1", quindi con le grep puoi inserire la ~ per cercare una directory anche non conoscendo il nome completo /*~1  
    
56. Modalità bridge:  Attraverso questa modalità la mia kali, assume indipendenza a tutti gli effetti ed ha un suo indirizzo IP distinto, mentre se la KALI è Nattata, il suo indirizzo viene nattato con l'indirizzo della mia macchina locale, quindi il traffico prodotto dalla kali viene reindirizzato sul mio host, e fatto uscire tramite il gw di default della rete associata.   
    
57. fping:  Simile al Ping, ma utilizzato automatizzare le scansioni e per lavorare in parallelo su piu host IP, recuperati da file   
    
58. hping:  Permette di creare e inviare messaggi ICMP, o pacchetti IP, o segmenti TCP è utilizzato in coppia con idle scan nmap sI, per fare in modo di capire se un host è raggiungibile facendo ip spoofing ed utilizzando un host zombie inattivo.  
    
59. User enumeration:  Utilizzo l'enumeration per ottenere un user, se il messaggio di risposta è parlante es. (passa da Utente non valido a "password invalida") e si permette il bruteforce dei tentativi senza blocco IP.   
    
60. IP Routing: Internal Gateway Protocol (IGP) oppure External Gateway Protocol EGP.  
    
61. EGP: 
    

Protocollo utilizzato è BGP.   

62. IGP – Internal Gateway Protocol Protocolli RIP, OSPF.  
    
63. RIP: Protocollo di routing che utilizza distance vector (Hellman Ford), calcola tutti gli hop e le distante da un router ad un altro fino ad un max di 15 hop.  E' inaffidabile perchè non considera la bandwith, scarsa connessione etc.   
    
64. Protocollo OSPF: Utilizza link state, ed è piu efficiente poichè fa un'analisi dello stato del link vicino e si aggiorna ogni 30 secondi.  Considera la velocità di banda ed è quello piu utilizzato.  
    
65. User Enumeration:  Da segnare come da cercare con piu attenzione nei Web PT, ottengo un utente usando magari linkedin, posso fare bruteforcing, attacchi a dizionario (importante!), password spraing.  
    
66. Password comuni:  Mesi + anno (es. Giugno2023!)   
    
67. Quotes: Prendi dall'albero il frutto piu basso.   
    
68. Info Utile PT/Web:  Se pagina php, trovare tutte le pagine che possono restituire informazioni. -> Da inserire come controllo da fare.   
    
69. Link utili per trovare una vpn se integrata all'interno del dominio - VPN Integrata: https://vpn.xxxx/remote/login?lang=en  https://vpn2.xxx.com/remote/login?lang=en   
    
70. Indirizzo di classi - Address class A -> 1.0.0.0   to 127.0.0.0 B -> 128.0.0.0 to 191.255.0.0 C -> 192.0.0.0 to 223.255.255.255  Indirizzi IP Riservati/Privati A -> 10.0.0.0 to 10.255.255.255 B -> 172.16.0.0 to 172.31.255.255 C -> 192.168.0.0 to 192.168.255.255   
    

Gli indirizzi IP privati sono riservati alle reti locali e non sono visibili dall’esterno della sottorete. Questi indirizzi sono utilizzati all’interno di reti locali, come case, aziende e campus, allo scopo di ridurre la richiesta di indirizzi IP pubblici. Le classi di indirizzi IP privati includono: 

1. Classe A (24 bit): Intervallo da 10.0.0.0 a 10.255.255.255, con un totale di 16.777.216 indirizzi disponibili. 
    
2. Classe B (20 bit): Intervallo da 172.16.0.0 a 172.31.255.255, con un totale di 1.048.576 indirizzi disponibili. 
    
3. [Classe C (16 bit): Intervallo da 192.168.0.0 a 192.168.255.255, con un totale di 65.536 indirizzi disponibili 1](https://it.wikipedia.org/wiki/Indirizzo_IP_privato). 
    

Gli indirizzi IP privati sono utilizzati per le comunicazioni all’interno di reti locali e non possono essere collegati ad altri indirizzi IP di rete in generale. [Per connettere una rete locale che utilizza questi indirizzi a Internet, si ricorre al network address translation (NAT), che mappa più indirizzi IP privati su un singolo indirizzo IP pubblico visibile all’esterno della sottorete 1](https://it.wikipedia.org/wiki/Indirizzo_IP_privato). 

In contrasto, un indirizzo IP pubblico è unico e visibile a livello globale. [Garantisce la possibilità di essere chiaramente identificati su Internet](https://it.wikipedia.org/wiki/Indirizzo_IP_privato) [2](https://www.avira.com/it/blog/indirizzo-ip-pubblico-vs-privato). Quindi, mentre gli indirizzi IP privati sono esclusivi per una rete locale, gli indirizzi IP pubblici sono accessibili da qualsiasi parte del mondo. 

  

71. Cryptography - Cifrari a blocchi vs cifrari a flusso Cifrari a Blocchi vanno a cifrare un blocco all'interno di un flusso. Cifrari a flusso, vanno a cifrare l'intero flusso. All'interno dei cifrari a blocchi viene utilizzata la tecnica CBC, Concatenazione blocchi cifrati.  
    
72. Cifrari a blocchi Protocolli SSL, PGP, IPSec, viene stabilito un blocco di k bit e viene cifrato lo specifico blocco. I cifrari a blocchi usano una tecnica denominata Concatenazione dei Blocchi Cifrati (CBC). L'idea base è quella di trasmettere solo il primo valore casuale insieme al primo messaggio, poi il mittente ed il destinatario usano i blocchi di codifica calcolati al posto dei successivi numeri casuali. La maggior parte dei cifrari a blocchi utilizza chiave simmetriche.  
    
73. CBC: Per superare i limiti di sicurezza è necessario l'utilizzo di una tecnica in cui lo stesso blocco di testo in chiaro, se ripetuto, produce blocchi di testo cifrato differenti. Questo è ciò che accade con la modalità CBC, in cui l'input dell'algoritmo di crittografia è il risultato dello XOR tra il blocco di testo in chiaro corrente e il blocco di testo cifrato precedente; per ciascun blocco viene utilizzata la stessa chiave.  
    
74. Chiave Simmetrica – stessa chiave DES: Cifrario a blocchi a chiave simmetrica, usa blocchi di 64 bit con chiave a 56 bit (deprecato). 3DES: Implementa CBC AES - Advanced Encryption Standard: usa 128 bit,  implementa CBC e può funzionare con chiavi di 128, 192, 256 bit.  
    
75. Chiave Pubblica RSA: Si ha una chiave pubblica con cui criptare i messaggi, che possono essere decriptati solo dal possessore di una chiave privata. Il problema è RSA richiede molto tempo, (DES è circa 100 volte piu veloce), pertanto viene utilizzata una chiave di sessione. Sostanzialmente viene creata una ulteriore chiave di sessione utilizzando una chiave simmetrica DES o AES.  
    
76. CrackStation : Tools per codificare le password  
    
77. Hashing Codifico la password utilizzando algoritmi di Hashing. Algoritmi deboli SHA-1 e MD5. Algoritmi buoni SHA-2 e Argoin2id e bcrypt. Per rendere ancora piu sicuro l'hashing delle password, vengono aggiunti salt e pepper. I “salt” sono stringhe addizionali di caratteri che vengono generate e poi aggiunte alla password prima di calcolarne l’hash. Invece, “pepper” è un valore segreto che viene aggiunto alla password prima della procedura di hashing. A differenza del “salt”, però, il “pepper” di solito è inserito all’interno del codice del sistema che esegue l'hashing della password Per l'hashing delle password vengono utilizzati o attacchi a dizionario, oppure hashing di password comune e sfruttando la potenza delle GPU vengono effettuati bruteforce. Windows usa salt ed altre tecniche, ma è facilmente recuperabile in quanto anche Windows stesso deve conoscere il salt e quindi è possibile estrarlo da qualche parte dalla memoria (per questo è relativamente inutile salare gli hash nel SAM).  
    
78. Hashing Crack Password: Le rainbow table sono tabelle dove vengono inseriti tutti gli input possibili e ne vengono precalcolati i rispettivi hash. Per contrastare la reinbow table è stata inventata la tecnica di salare la password con il "salt", ossia viene generato un valore randomico utilizzato in aggiunta durante l'hashing della password. Windows usa salt ed altre tecniche, ma è facilmente recuperabile in quanto anche Windows stesso deve conoscere il salt e quindi è possibile estrarlo da qualche parte dalla memoria (per questo è relativamente inutile salare gli hash nel SAM). Mentre negli handshake (es. Quelli catturati dal responder), viene usato una specie di salt, che però viene trasmesso e creato al volo dal tizio che vuole autenticarsi durante l'handshake.  
    
79. MD5 - Algoritmi Hashing: 
    

MD5 (“Message Digest”): genera una fingerprint da 128 bit (32 caratteri esadecimali). Sviluppato da Ronald Rivest nel 1991, è ormai considerato non più sicuro, sebbene sia ancora utilizzato; Approfondire  

80. SHA-1 – Algoritmi Hashing SHA-1 (“Secure Hash Algorithm 1”): genera una fingerprint da 160 bit (40 esadecimali). Nato nel 1995, è considerato non più sicuro, dopo che Google ne ha dimostrato la possibilità di collisione; Approfondire  
    
81. SHA-2 – Algoritmi Hashing SHA-2 (“Secure Hash Algorithm 2”): nato nel 2001, è la variante più sicura di SHA-1, con dimensioni dell’hash maggiori, da 256 (64 esadecimali) a 512 bit (128 esadecimali); 
    

Approfondire  

82. SHA-3:  è stato definito dal NIST con la FIPS PUB 202 (agosto 2015) ed è destinato a diventare il nuovo standard. Approfondire  
    
83. Hashing vs Crittografia La peculiarità dell’hash è quello di essere non invertibile (one-way): dall’hash non è mai possibile risalire al valore iniziale. La algoritmi di crittografia simmetrica (AES, DES) e asimmetrica (RSA ecc.) Questa è una differenza sostanziale rispetto agli altri algoritmi di crittografia simmetrica (AES) e asimmetrica (RSA ecc.) che invece sono reversibili: dal messaggio originale (messaggio in chiaro) si genera un testo cifrato e da questo con l’algoritmo deputato alla decodifica si ritorna al messaggio originale, a condizione di conoscere la chiave (o le chiavi) di codifica e decodifica. Di contro però è che alcuni sistemi accettano anche l'hash delle password per potersi autenticare.  
    
84. MAC - Message authentication code Per garantire l’integrità dei messaggi, oltre alle funzioni hash crittografiche, Alice e Bob hanno bisogno di un segreto condiviso. Questo segreto condiviso, che non è altro che una stringa di bit, è chiamato chiave di autenticazione. Usando questo segreto condiviso, l’integrità del messaggio è realizzata come segue. Rimane ancora la questione importante di come venga distribuita la chiave di autenticazione condivisa tra le entità in comunicazione. Per esempio, nell’algoritmo d instradamento link state avremo bisogno di distribuire in un qualche modo la chiave di autenticazione a ciascun router fidato nella rete di calcolatori. Si noti che tutti i router possono usare la stessa chiave di autenticazione. Un amministratore di rete può, a dire il vero, svolgere questo compito manualmente, visitando ciascun router, oppure, se ciascun router ha una sua chiave pubblica, l’amministratore di rete può comunicare la chiave di autenticazione a ciascun router, cifrandola con la chiave pubblica del router e poi inviandogliela tramite la rete.  Successore di MAC è HMAC, che cripta una seconda volta la chiave di autenticazione ed è usato comunemente in SHA1 e MD5.  
    
85. Handshake SSL Handshake Durante la fase di handshake, Bob ha bisogno di (a) stabilire una connessione TCP con Alice, (b) verificare che Alice sia realmente Alice e (c) inviarle una chiave segreta principale che verrà utilizzata da entrambi per generare tutte le chiavi simmetriche di cui hanno bisogno per la sessione SSL. Notate che una volta che la connessione TCP è stata stabilita, Bob manda ad Alice un messaggio “hello” e Alice risponde con il proprio certificato che contiene la sua chiave pubblica. Come abbiamo visto nel Paragrafo 8.3, dato che il certificato è garantito da una CA, Bob sa con certezza che la chiave pubblica del certificato appartiene ad Alice. Bob genera un master secret (MS): un valore segreto che verrà usato solo per questa sessione SSL e dal quale verranno derivate altre chiavi. Il master secret viene cifrato con la chiave pubblica di Alice, per creare un encyrpted master secret (EMS) che viene inviato ad Alice, la quale decifra l’EMS con la sua chiave privata e ottiene MS. Dopo questa fase Bob ha autenticato Alice, ed entrambi (ma nessun’altro) conoscono il master secret per questa sessione SSL. È però generalmente considerato più sicuro che Bob e Alice usino ciascuno chiavi crittografiche differenti, oltre che a impiegare chiavi diverse per la cifratura e la verifica dell’integrità dei dati. Quindi, Alice e Bob usano MS per generare 4 chiavi:  EB • = chiave di cifratura di sessione per i dati inviati da Bob ad Alice  MB • = chiave MAC di sessione per i dati inviati da Bob ad Alice  EA • = chiave di cifratura di sessione per i dati inviati da Alice a Bob  MA • = chiave MAC di sessione per i dati inviati da Alice a Bob  SSL non richiede che Alice e Bob usino uno specifico algoritmo a chiave simmetrica 
    

o uno specifico a chiave pubblica, o uno specifico MAC, ma consente loro di accordarsi all’inizio della sessione SSL, durante la fase di handshake, su quali algoritmi crittografici useranno. Inoltre, durante la fase di handshake, Alice e Bob si scambiano dei nonce che vengono usati nella creazione delle chiavi di sessione (EB, MB, EA, e MA). 

I passi del reale handshake SSL sono i seguenti.  1. Il client invia, assieme al proprio nonce, la lista degli algoritmi crittografici da lui supportati.  2. Dalla lista, il server sceglie un algoritmo a chiave simmetrica (per esempio, AES), uno a chiave pubblica (per esempio RSA, con una specifica lunghezza di chiave) e un algoritmo MAC. Restituisce al client le proprie scelte, insieme a un certificato e al nonce del server.  3. Il client verifica il certificato, estrae la chiave pubblica del server, genera un premaster secret (PMS) e lo cifra con la chiave pubblica del server per poi mandarlo cifrato al server.  4. Usando la stessa funzione di derivazione della chiave, come specificato dallo standard SSL, il client e il server calcolano indipendentemente il master secret partendo da PMS e nonce. Il master secret viene poi suddiviso per generare le due chiavi di cifratura e le due chiavi MAC. Inoltre, se l’algoritmo a chiave simmetrica va uso di CBC (come nel caso di 3DES e AES) i due vettori di inizializzazione (uno per ogni capo della connessione) sono anch’essi ottenuti dal master secret. D’ora in poi tutti i messaggi inviati tra il client e il server sono cifrati e autenticati con il MAC.  5. Il client invia un MAC di tutti i messaggi di handshake. 

 6. Il server manda un MAC di tutti i messaggi di handshake  

86. Handshake TLS: Il client dà il via all’handshake TLS inviando un messaggio al server. Il messaggio include il valore casuale del client, la versione TLS supportata e la suite di crittografia. Il server risponde con un messaggio che include il valore casuale del server, il certificato SSL, la suite di cifratura scelta e, a volte, la richiesta del certificato del client. Il client autentica il certificato SSL del server e la CA. Il client invia il premaster secret, una stringa casuale di byte e lo crifra con la chiave pubblica dal certificato SSL del server. Il server decifra il premaster secret e le due parti generano le chiavi di sessione. Il client invia un messaggio crittografato con la chiave di sessione. Il server passa il suo stato di sicurezza del livello di registrazione alla crittografia simmetrica utilizzando le chiavi di sessione e invia un messaggio al client. Viene stabilito un canale protetto e tutti i messaggi inviati vengono crittografati utilizzando la chiave di sessione.  


87. TLS Handshaking: Transport Layer Security (TLS) Handshake Protocol è responsabile dell'autenticazione e dello scambio di chiavi necessario per stabilire o riprendere sessioni sicure. Quando si stabilisce una sessione sicura, handshake Protocol gestisce quanto segue:  - Negoziazione della suite di crittografia: Il client e il server fanno contatto e scelgono la suite di crittografia che verrà usata durante lo scambio di messaggi  - Autenticazione del server e facoltativamente, il client:  In TLS un server dimostra la propria identità al client. Il client potrebbe anche dover dimostrare la propria identità al server. PKI, l'uso di coppie di chiavi pubbliche/private, è la base di questa autenticazione. Il metodo esatto usato per l'autenticazione è determinato dalla suite di crittografia negoziata.  - Scambio di informazioni sulla chiave di sessione. Il client e il server scambiano numeri casuali e un numero speciale denominato Pre-Master Secret. Questi numeri vengono combinati con dati aggiuntivi che consentono al client e al server di creare il segreto condiviso, denominato Master Secret. Il segreto master viene usato dal client e dal server per generare il segreto MAC di scrittura, ovvero la chiave di sessione usata per l'hashing e la chiave di scrittura, ovvero la chiave di sessione usata per la crittografia.  
    
88. TLS Handshaking – Procedura: 1. Il client invia un messaggio "Client hello" al server, insieme al valore casuale del client e ai pacchetti di crittografia supportati. 2. Il server risponde inviando un messaggio "Server hello" al client, insieme al valore casuale del server. 3. Il server invia il certificato al client per l'autenticazione e può richiedere un certificato dal client. Il server invia il messaggio "Server hello done". 4. Se il server ha richiesto un certificato dal client, il client lo invia. 5. Il client crea un segreto pre-master casuale e lo crittografa con la chiave pubblica dal certificato del server, inviando il segreto pre-master crittografato al server. 6. Il server riceve il segreto pre-master. Il server e il client generano le chiavi master secret e sessione in base al segreto pre-master. 7. Il client invia una notifica "Modifica spec di crittografia" al server per indicare che il client inizierà a usare le nuove chiavi di sessione per l'hashing e la crittografia dei messaggi. Il client invia anche un messaggio "Client completato". 8. Il server riceve "Cambia spec di crittografia" e commuta lo stato di sicurezza del livello record alla crittografia simmetrica usando le chiavi di sessione. Il server invia un messaggio "Server completato" al client. 9. Il client e il server possono ora scambiare i dati dell'applicazione tramite il canale protetto stabilito. Tutti i messaggi inviati dal client al server e dal server al client vengono crittografati usando la chiave di sessione.  
    
89. Responder Tools.py che sfrutta i protocolli abilitati di default sui sistemi Windows NBT-NS (NetBIOS Name Service) e LLMNR (Local Link Multicast Name Resolution) , il cui scopo è dare un alternativa al servizio DNS in caso in cui il SO non riesca a risolvere dei domini tramite server DNS o il suo host locale. Risoluzione DNS priorità: Memoria, /etc/hosts/ LLMNR o NBT-NB, server DNS. I due protocolli Inviano una richiesta in broadcast (UDP), il responder fa spoofing e si finge l'host cercato e invierà l'hash NTLMv1/v2 o LMv2. L'Hash può essere crackato, oppure utilizzato per accedere direttamente ad altri sistemi della rete Il responder utilizza SMB per condividere la shell con magari l'errore durante il tentativo di inserimento delle credenziali della vittima. Ottenuto l'hash NTLM, si cracka o si tenta di utilizzarlo in vari strumenti senza l'utilizzo della password crackata ma unicamente con l'hash NTLM(attacchi Pass The Hash). Responder ha una suite che si chiama MultiRelay.py, che cerca di autenticarsi alle share di rete utilizzando hash NTLM attraverso SMB.  
    
90. Multirelay Tools Multirelay.py utilizzato assieme al responder, che cerca attraverso un hash di un utente con privilegi di amministratore di sistema di autenticarsi tramite SMB su sistemi che condividono lo stesso utente e credenziali, se non presente il SMB Signing (attacco definitivo SMB Relay). Le credenziali da Administrator, mi consentono di autenticarmi alla macchina target come Amministratore locale, da qui posso fare il dump degli hash delle password locali, e provare a fare pivot(saltare) su altri dispositivi della rete, installare malware etc. Altre funzionalità che possono essere utilizzate con Multiray sono: Mimikatz (utilizzato per recupero delle credenziali dalla memoria), Meterpreter (scanner SMB all'interno della rete).  
    
91. SMB Signing: SMB signing è una funzionalità di sicurezza implementata nel protocollo di rete SMB, utilizzato per la condivisione di file, stampanti e altre risorse in un ambiente di rete. È progettata per garantire l’integrità e l’autenticità delle comunicazioni SMB tra un client e un server. Ogni pacchetto SMB inviato è firmato digitalmente dal mittente e verificato dal destinatario. Ciò impedisce la manipolazione o l’alterazione dei dati SMB durante la trasmissione. 
    

L’utilizzo di SMB signing offre diversi vantaggi in termini di sicurezza: la firma digitale, ad esempio, consente di verificare che i dati non siano stati modificati o compromessi durante la trasmissione. C’è poi l’autenticazione che garantisce l’identità del mittente dei pacchetti SMB. Con SMB signing è inoltre possibile prevenire attacchi MITM (man-in-the-middle). 

La funzionalità richiede un’attivazione sia sul client che sul server. In questo senso, l’iniziativa presentata da Pyle mira ad estenderne l’adozione su vasta scala in tempi relativamente brevi. 

Il client inserisce un hash dell’intero messaggio nel campo della firma nell’intestazione SMB. Se qualcuno modifica il messaggio in transito sulla rete, l’hash non corrisponderà e SMB saprà che qualcuno ha manomesso i dati. La conferma dell’identità di mittente e destinatario evita la fattibilità degli attacchi NTLM relay.  

92. NTLM Relay Attack: Attacco ad inoltro. Provo ad entrare es. In un ufficio, inoltro il messaggio che ricevo dal server di autenticazione sulla mia smart card alla smart card di un utente reale e utilizzo quella risposta per reinoltrarla al server originario.  Gli NTLM relay attack sono piuttosto noti e comuni: avevamo spiegato con possono essere utilizzati per diventare amministratori di dominio senza averne titolo. Gli attacchi sfruttano la mancanza di autenticazione lato server nel protocollo NTLM (NT LAN Manager), introdotto da Microsoft negli anni ’90. Gli attacchi NTLM relay possono essere particolarmente pericolosi perché consentono agli attaccanti di sfruttare le debolezze del protocollo e l’assenza di autenticazione per compromettere le credenziali degli utenti senza nemmeno dover rompere direttamente le password. Questo tipo di attacco è spesso utilizzato per ottenere accesso non autorizzato alle risorse di rete, come server di file o applicazioni, o per ottenere ulteriori informazioni utili per ulteriori attacchi.  
    

Per mitigare gli attacchi NTLM relay si possono adottare diverse contromisure. Oltre al passaggio all’autenticazione basata su Kerberos, comunque non immune a vulnerabilità di sicurezza, risolvibili mediante l’installazione di apposite patch, l’abilitazione della funzionalità SMB signing risulta cruciale.  

93. NTLM E' una suite di protocolli di sicurezza Microsoft che forniscono autenticazione, integrità e confidenzialità agli utenti. E' il successore di LM (Lan Manager)  NTLM è un protocollo challenge-response (sfida-risposta) che utilizza tre messaggi per autenticare un client all'interno di un ambiente orientato alla connessione e permette messaggi aggiuntivi se è richiesta integrità.  NTLM utilizza uno o entrambi i valori di password hashed, che sono entrambi memorizzati nel server (o nel domain controller) e che sono equivalenti alla password. Questo significa che se si riesce ad ottenere un hash password dal server, è possibile autenticarsi senza conoscere la password vera. I valori di password sono l'LM hash (una funzione di hashing di autenticazione basata su DES applicata ai primi 14 caratteri della password convertita al charset 8-bit della lingua) e l'NT hash (ovvero l'MD4 Little endian della password). Entrambi i valori hash sono di 16 bytes (128 bits).  Es. Hash LM/NTLM Administrator:500:aad3b435b51404eeaad3b435b51404ee:30xxxxxxxxxxxxxxxxxxxxxxxxx:::  C'e' il nome : SID (500 e' sempre amministratore locale). la prima parte, che comincia con aad3 e' l'hash LM storicamente, si usava LM, ma era intrinsecamente debole xche l'fbi voleva cosi e aveva costretto microsoft. Ora si usa nt, che non e' schifoso come LM ma non e' cosi duro da craccare....infatti nei moderni hash, la parte LM inizia sempre con aaad3, perche' e' l'hash della password VUOTA   
    
94. LM Sebbene sia basato sul DES, un cifrario a blocchi ben noto e studiato, l'LM hash può essere violato molto facilmente a causa di due debolezze nella sua implementazione. La prima è che le password più lunghe di 7 caratteri sono divise in due ed ogni metà è trattata separatamente. La seconda è che tutte le lettere minuscole della password sono convertite in maiuscolo prima del calcolo dell'hash. L'LM hash funziona nel seguente modo. 
    
    1. La password dell'utente viene convertita da stringa OEM a tutto maiuscolo. 
        
    2. La password viene anche troncata dopo 14 byte. 
        
    3. La password viene a sua volta divisa in due metà da 7 byte. 
        
    4. Questi valori sono usati per creare due chiavi DES, una per ogni blocco da 7 byte, convertendo i sette byte a un flusso di bit e aggiungendo un bit zero alla fine di ogni sette bit. Questo genera i 64 bit necessari per ogni chiave DES. 
        
    5. Ognuna di queste di chiavi è usata per cifrare con il DES la stringa costante in ASCII “KGS!@#$%”, trasformandola in due valori da 8 byte. 
        
    6. Questi due valori sono concatenati per formare un valore da 16 byte, il quale è l'LM hash.   
        
95. NTLM  Hashing della password sono salvate all'interno dei servizi SAM (Security Account Manager), è inutile usare salt, in quanto appunto da qualche parte devo salvarlo ed è facilmente recuperabile all'interno di un sistema di rete, mentre su un applicativo posso salvarlo in maniera piu indipendente e imprevedibile.  
    
96. Kerberos Kerberos è un protocollo di rete per l'autenticazione forte che permette a diversi terminali di comunicare su una rete informatica insicura provando la propria identità mediante l'utilizzo di tecniche di crittografia simmetrica. Kerberos previene attacchi quali l'intercettazione e i replay attack ed assicura l'integrità dei dati.  - Utente: Autenticazione di base Un utente inserisce username e password sul client.  - Client: Autenticazione AS 1. Il client manda un messaggio non crittato all'AS richiedendo i servizi per l'utente. ("L'utente XYZ vorrebbe richiedere dei servizi"). Né la chiave segreta né la password vengono inviate all'AS. 2. L'AS controlla se il client è nel suo database. Se lo è invia due messaggi al client: 
    

Messaggio A: Chiave di sessione client-TGS crittata usando la chiave segreta dell'utente. 

Messaggio B: Ticket-Granting Ticket (che include l'identificativo del client, l'indirizzo di rete, il tempo di validità del ticket e la chiave di sessione client-TGS). Il Ticket-Granting Ticket è crittato utilizzando la chiave segreta di TGS. 3.Quando il client riceve i messaggi A e B, decritta il messaggio A ottenendo la chiave di sessione client-TGS. Questa chiave è utilizzata per le successive comunicazioni con TGS. (Nota: il client non può decrittare il Messaggio B, che è stato crittato con la chiave segreta di TGS). A questo punto il client possiede i mezzi per autenticarsi presso TGS.  - Client: Autenticazione TGS 

Quando richiede dei servizi, il client invia i seguenti due messaggi a TGS: Messaggio C: composto dal Ticket-Granting Ticket (mandatogli dal AS nel messaggio B) e dall'identificativo del servizio richiesto Messaggio D: autenticatore (Authenticator) (che è formato da identificativo del client e timestamp), crittato usando la chiave di sessione client—TGS. Ricevendo i messaggi C e D, TGS decritta il messaggio C con la propria chiave e dal messaggio estrae la chiave di sessione client—TGS che utilizza per decrittare il messaggio D (autenticatore). A questo punto invia i seguenti due messaggi al client: Messaggio E: Ticket client-server (che include l'identificativo del client, l'indirizzo di rete del client, il periodo di validità e la chiave di sessione client-server) crittato utilizzando la chiave segreta del server che offre il servizio. Messaggio F: Chiave di sessione client-server crittato usando la chiave di sessione client-TGS. 

 - Client: Autenticazione SS 

1. Ricevendo i messaggi E e F dal TGS, il client può autenticarsi presso il SS. Il client si connette al SS e invia i seguenti due messaggi: Messaggio E: Ticket client-server crittato usando la chiave segreta di SS. Messaggio G: un nuovo autenticatore, che include l'identificativo del client, il timestamp ed è crittato usando la chiave di sessione client-server. 

2. Il server decritta il ticket usando la sua chiave segreta e invia il seguente messaggio al client per confermare la propria identità e la volontà di fornire il servizio al client: Messaggio H: il timestamp trovato nell'autenticatore incrementato di uno, crittato utilizzando la chiave di sessione client-server. 

3. Il client decritta la conferma usando la chiave di sessione client-server e controlla che il timestamp sia correttamente aggiornato. Se lo è, il client può considerare affidabile il server e iniziare a effettuare le richieste di servizio. 

4. Il server fornisce i servizi al client.   

97. Kerberoasting: Il controller di dominio risponde con un ticket di servizio criptato con la chiave segreta dell’account di servizio. L’aggressore può così inondare il server Kerberos con richieste TGS (Ticket Granting Service), estrarre i ticket dalla memoria e poi intentare un password cracking offline. L’algoritmo di hashing RC4 è ormai superato e vulnerabile: quando esso viene usato al posto di AES (vedere più avanti), il malintenzionato può estrapolare le credenziali dell’account di servizio con grande facilità (senza bisogno di generare ulteriori richieste) e ottenere accesso illimitato a tutti i sistemi e a tutte le risorse a cui l’account compromesso ha accesso. L’attaccante è a questo punto in grado di aumentare i suoi privilegi molto rapidamente e di effettuare movimenti laterali all’interno del sistema informatico dell’azienda. Kerberoasting è un attacco che può essere messo in atto nella fase post-exploitation: è cioè necessario che l’aggressore abbia già guadagnato in qualche modo l’accesso alla rete aziendale disponendo di un’utenza di dominio valida. Questo aspetto rende chiaro, ancora una volta, come il problema della sicurezza dell’infrastruttura IT vada esaminato e trattato nel suo complesso, non “a compartimenti stagni”. Mercuri evidenzia come sia potenzialmente esposta all’attacco Kerberoasting la stragrande maggioranza delle aziende, perché il 99% di esse utilizza Active Directory nella propria infrastruttura.  
    
98. Impersonificazione per accedere alle macchine in Remote Desktop Protocolli: E' possibile utilizzare un token dalla lista di persone che hanno fatto accesso al tuo sistema per poter creare una utenza admin con id e password di cui siamo a conoscenza e successivamente utilizzarle per effettuare query per cercare lista di id e password di utenti.  
    
99. list_tokens –u Per recuperare la lista dei token di utenti che hanno effettuato l'accesso ad un sistema, e con il quale è possibile   
    
100. Token kerberos Che ci sono in memoria, possiamo prendere i token recuperati da list_tokens, possiamo impersonificarlo, e posso aggiungere ad es. un amministratore di dominio per creare la password utile per poterla riutilizzare, all'interno del programma crackmapexec, cercando con quell'aministratore di dominio. Essendo un account di dominio è possibile che abbia visibilità su tutti gli utenti di dominio all'interno del gruppo, quindi cerco directory/share di rete da poter raggiungere utilizzando smbclient. Se trovo qualcosa navigo le shell per trovare file di configurazioni da poter utilizzar per attacchi con payload Metasploit automatizzati es. utilizzando metasploit.  
    
101. LSA: Local Security Authority (LSA) è un componente di Windows che gestisce l’autenticazione e i privilegi degli account utente e dei processi che accedono alle risorse del sistema. LSA gestisce le credenziali, inclusi i nomi utente e le password, e controlla l’accesso alle risorse di sistema come file, cartelle, stampanti e reti.   
    
102. LSASS - Local Security Authority Subsystem Service  lsass.exeè il processo responsabile dell'applicazione della politica di sicurezza sui sistemi Windows. Quando un utente tenta di accedere al sistema, questo processo verifica il tentativo di accesso e crea token di accesso in base ai livelli di autorizzazione dell'utente. LSASS è anche responsabile delle modifiche alla password dell'account utente. Tutti gli eventi associati a questo processo (tentativi di accesso/disconnessione, ecc.) vengono registrati nel registro di sicurezza di Windows. LSASS è un obiettivo di altissimo valore poiché esistono diversi strumenti per estrarre sia le credenziali in chiaro che quelle con hash archiviate in memoria da questo processo.  
    
103. SAM Security Account Manager, è un database che memorizza le varie password dei sistemi operativi Windows. Utilizza password in hash LM, o NTLM, è possibile che il SAM sia a sua volta criptato. Il Security Account Manager ( SAM ) è un file di database [1] in Windows XP, Windows Vista, Windows 7, 8.1, 10 e 11 che memorizza le password degli utenti. Può essere utilizzato per autenticare utenti locali e remoti. A partire da Windows 2000 SP4, Active Directory autentica gli utenti remoti. SAM utilizza misure crittografiche per impedire agli utenti non autenticati di accedere al sistema. Ogni utente di dominio può accedere al SAM per vedere le password, quindi se diventi amministratore di dominio, puoi vedere tutti gli hash delle password Dal responder, posso estrapolare degli account di amministrazione, e posso utilizzarli per passarli ad crackmapexec indicando di cercare all'interno del SAM.  Le password utente vengono memorizzate in un formato con hash in un hive del Registro di sistema come hash LM o come hash NTLM . Questo file può essere trovato in %SystemRoot%/system32/config/SAM ed è montato HKLM/SAMe SYSTEM per visualizzarlo sono richiesti i privilegi.  Nel tentativo di migliorare la sicurezza del database SAM contro il cracking del software offline, Microsoft ha introdotto la funzione SYSKEY in Windows NT 4.0. Quando SYSKEY è abilitato, la copia su disco del file SAM è parzialmente crittografata, in modo che i valori hash delle password per tutti gli account locali archiviati nel SAM siano crittografati con una chiave (di solito indicata anche come "SYSKEY".   
    
104. Enterprise Admins Il gruppo Enterprise Admins (EA) si trova nel dominio radice della foresta e, per impostazione predefinita, è membro del gruppo Administrators predefinito in ogni dominio della foresta. L'account amministratore predefinito nel dominio radice della foresta è l'unico membro predefinito del gruppo EA.  
    
105. Utente Locale Gli account utente locali sono definiti localmente in un dispositivo e possono essere assegnati diritti e autorizzazioni solo nel dispositivo. Gli account utente locali sono entità di sicurezza usate per proteggere e gestire l'accesso alle risorse in un dispositivo, per servizi o utenti.  
    
106. Utente locale predefinito Gli account utente locali predefiniti sono account predefiniti creati automaticamente quando viene installato il sistema operativo. Gli account utente locali predefiniti non possono essere rimossi o eliminati e non forniscono l'accesso alle risorse di rete.  Gli account utente locali predefiniti vengono usati per gestire l'accesso alle risorse del dispositivo locale in base ai diritti e alle autorizzazioni assegnati all'account.  
    
107. Amministratore Locale L'account amministratore locale predefinito è un account utente per l'amministrazione del sistema. Ogni computer ha un account amministratore (SID S-1-5-domain-500, nome visualizzato Amministratore). L'account amministratore è il primo account creato durante l'installazione di Windows.  
    
108. Amministratore di Dominio  
    
109. Guest L'account Guest consente agli utenti occasionali o occasionali, che non dispongono di un account nel computer, di accedere temporaneamente al server locale o al computer client con diritti utente limitati. Per impostazione predefinita, l'account Guest è disabilitato e ha una password vuota. Poiché l'account guest può fornire l'accesso anonimo, viene considerato un rischio per la sicurezza. Per questo motivo, è consigliabile lasciare disabilitato l'account Guest, a meno che non sia necessario usarlo. Per impostazione predefinita, l'account guest è l'unico membro del gruppo SID S-1-5-32-546Guest predefinito , che consente a un utente di accedere a un dispositivo.   
    
110. Mimikatz Tools E' una funzionalità di MultiRelay, per il recupero delle credenziali di Windows. E' un programma che permette di estrarre password, hash, PIN, ticket Kerberos dalla memoria.  
    
111. Meterpreter Tools Meterpreter è un payload di attacco Metasploit che fornisce una shell interattiva da cui un utente malintenzionato può esplorare la macchina bersaglio ed eseguire il codice. Meterpreter viene distribuito utilizzando l'iniezione di DLL in memoria (non salva nulla su disco, quindi evita di essere intercettato). Il Payload Meterpreter si inserisce all'interno di un processo in memoria e non va a creare nuovi processi, dal quale al max può migrare ad altri processi. Scanner SMB, utile una volta che si ha una shell sull'host compromesso per trovare altri potenziali bersagli.  
    
112. DLL   
    
113. Meterpreter + Trojan Interno Utilizzato per bypassare i controlli degli antivirus e poter lanciare meterpreter e altri tools che potrebbero essere rilevati  
    
114. Meterpreter vs CrackmapExec Meterpreter una volta entrato in una shell cerca di trovare altri potenziali bersagli. CrackMapExec esegue scansioni partendo da credenziali per trovare una shell  
    
115. CrackMapExec Tools CrackMapExec, noto come CME è uno strumento post sfruttamento per automatizzare la valutazione della sicurezza delle reti di Active Directory. CrackMapExec genera un server SMBExec che lo aiuta a raccogliere le credenziali che possono essere utilizzate per il movimento laterale e l'escalation dei privilegi. Un avversario che ottiene l'accesso come amministratore può accedere a sistemi e dati sensibili o persino ottenere il controllo dell'intero dominio. Ottenendo l'accesso a un account amministratore, un hacker può eseguire comandi e scaricare informazioni da una postazione remota utilizzando il protocollo SMB. Es. crackmapexec smb ips -u 'Acquadro' -p 'Luglio2023' --shares  
    
116. GetUsersSPNs.py Tools GetUserSPNs.py può essere utilizzato per ottenere un hash della password per gli account utente che dispongono di un SPN (nome dell'entità servizio). Se su un account utente è impostato un SPN, è possibile richiedere un ticket di servizio per questo account e tentare di violarlo per recuperare la password dell'utente. Questo attacco si chiama . Questo script può essere utilizzato anche per Kerberoast senza preauthentication.  
    
117. MSFVenom MSFVenom è un Metasploit payload (è una combinazione di Msfpayload e Msfencod)  
    
118. WPAD  Protocollo che rileva automaticamente i proxy Web. Anche i browser utilizzano il protocollo WPAD.  
    
119. APK Extractor:  Estrarre APK da un app installata su Android  
    
120. Clutch:  Estrarre APK da app installata IOS  
    
121. Jadx-GUI Apro Jadx-GUI ed importo l'APK. L'APK contiene file .dex, decompilati in .class e .jar  
    
122. Crack di password: Bruteforce, Attacchi a dizionario, Rainbow Table (set di hash password). Strumenti utili  
    
123. Administrative Share: Le share amministrative sono condivisioni di rete nascoste create dalla famiglia di sistemi operativi Windows NT che consentono agli amministratori di sistema di avere accesso remoto a ogni volume del disco su un sistema connesso alla rete. Queste condivisioni potrebbero non essere eliminate definitivamente ma potrebbero essere disabilitate. Le condivisioni amministrative non sono accessibili agli utenti senza privilegi amministrativi. (es. C$ - Default Drive Share, ADMIN$ - Remote Admin, IPC$ - Remote IPC sono directory in share, posso sfruttarla per cambiare directory utilizzando la tilde). net share per vedere la net sharata  
    
124. Medusa:  Tools utilizzato per automatizzare attacchi ssh utilizzando password predefinite (es. medusa -M smbnt -m GROUP:domain -u asd -p asd -h 192.168.1.18) medusa -M ssh -u root -P diz -H 22.txt -T 10 -t 10  
    
125. sva-smb.py: Tools utilizzato per automatizzare i tentativi di montare share ed ottenere accesso condiviso a file, stampanti, shell, che restituisce informazioni sulle share a cui puoi accedere ed indica i privilegi delle rispettive share directory. (es. python 2 sva.smb.py - 445.txt (macchine che vuoi scannare) -U oliveto -P Roberta5 -W lawer)  
    
126. Proxychains: Tools che forza tutte le connessioni TCP sul comando successivo, ad utilizzare un proxy like TOR or SOCKS5. Crea una sandbox (es. Proxychains bash, crea una sandbox nel quale tutti i comandi inseriti sulla bash utilizzano il SOCKS Proxy tunnel) (proxychains.conf  - In questo file è possibile configurare i serverproxy e la modalità di esecuzione del programma).  
    
127. TOR: E' un software, una sorta di Proxy Integrato. Tor protegge gli utenti dall'analisi del traffico attraverso una rete di router (detti anche onion router), gestiti da volontari, che permettono il traffico anonimo in uscita e la realizzazione di servizi anonimi nascosti. Lo scopo di Tor è quello di rendere difficile l'analisi del traffico e proteggere così la privacy, la riservatezza delle comunicazioni, l'accessibilità dei servizi. Il funzionamento della rete Tor è concettualmente semplice: i dati che appartengono ad una qualsiasi comunicazione non transitano direttamente dal client al server, ma passano attraverso i server Tor che agiscono da router costruendo un circuito virtuale crittografato a strati (per analogia con onion, termine in inglese che in italiano significa cipolla).§  
    
128. CVE: Common Vulnerability Exposure  
    
129. SOCKS / SOCKS5 – Socket Secure: Protocollo che permette la comunicazione tra pacchetti client/server attraverso un proxy (server SOCKS). Viene creato quindi un tunnel SOCKS all'interno del quale passa tutto il traffico  Mi conetto in ssh con socks pre creare un canale privato tra un host ed un server/host.  Un server SOCKS è un particolare tipo di proxy che permette di effettuare connessioni TCP dirette (e, dalla versione 5, di veicolare traffico UDP oltre che TCP) tra computer su due reti IP differenti nei casi in cui un instradamento diretto (routing) non sia disponibile.  Es. ssh -D 9050 ubuntu@<IPaddressofTarget>  SSH command used to perform a dynamic port forward on port 9050 and establishes an SSH tunnel with the target. This is part of setting up a SOCKS proxy  
    
    - I punti di forza del protocollo SOCKS sono l'estrema semplicità di implementazione (sia dal lato client che dal lato server) e la completa indipendenza dal protocollo da veicolare attraverso di esso.  
        
    - Storicamente SOCKS è stato usato come punto di contatto tra due LAN oppure tra una LAN e una WAN (come ad esempio Internet). Recentemente è più comune incontrare reti direttamente connesse ad Internet o connesse attraverso un proxy HTTP.  
        
130. Man in the middle: Ci si mette in mezzo ad una connessione e sniffo pacchetti  
    
131. Eavesdropping: Tipo di attacco man in the middle.  
    
132. Sniffing: Intercettazione passiva dei dati in transito  
    
133. UART: Lo UART o Universal Asynchronous Receiver-Transmitter è un dispositivo hardware, di uso generale o dedicato, che converte flussi di bit di dati da un formato parallelo a un formato seriale asincrono o viceversa. Gli USART, hanno il compito di gestire le comunicazioni delle interfacce seriali RS-232. Definisce un protocollo, o un insieme di regole, per lo scambio di dati seriali tra due dispositivi. Il protocollo UART è molto semplice e utilizza solo due fili fra il trasmettitore e il ricevitore per trasmettere e ricevere in entrambe le direzioni. UART sta per ricevitore / trasmettitore asincrono universale ed è un semplice protocollo a due fili per lo scambio di dati seriali. La velocità di trasmissione è la velocità con cui le informazioni vengono trasferite a un canale di comunicazione. Nel contesto della porta seriale, il baud rate impostato fungerà da numero massimo di bit al secondo da trasferire.  
    
134. Minicom: Tools utilizzato per sfruttare ed interagire attraverso il servizio UART. Solitamente è necessario configurare il baud rate, che gestisce la velocità di ritrasmissione da un interfaccia UART TX all'interfaccia UART RX.  
    
135. IOT Step: Devo trovare le porte UART per localizzare i piedini. Se trovo i piedini devo trovare anche la terra. Per trovare una terra utilizzo il multimetro, mettendo i due cavi su metalli e vedo se c'è il suono, che mi indica appunto che è una terra quel piedino.  Cerco se uno di quei piedini è un StdOut o StdIn o Alimentazione come? Uso il multimetro settato a 3 V (o 20V), e vedo se c'è oscillazione o meno. Se c'è oscillazione significa che quel piedino è in lettura sulla parte hardware, devo verificare che la parte software è abilitata, in modo da ottenere una scrittura (dal piedino) ed una lettura (dal device verso il router). Uso mimicom ed un cavo USB usando le entry ground(terra), read, write su stdout, stdin per vedere se durante il boot loader sono abilitato in scrittura/lettura. Durante il boot il kernel del Sistema Operativo, viene recuperato dal disco e inserito all'interno della RAM permettendone l'esecuzione da parte del processore e il conseguente avvio del sistema.  
    
136. Certificate Pinning: Il certificate pinning è un meccanismo di sicurezza che consente di verificare che un canale di comunicazione basato su protocollo HTTPS sia sicuro. Vedremo, infatti, come sia piuttosto semplice intercettare una comunicazione instaurata da un'applicazione mobile a meno che questa non implementi tale meccanismo di sicurezza. Quando un client si connette ad un server tramite protocollo HTTPS verifica che il certificato HTTPS, fornito dal server, sia valido per il dominio contattato. Per far ciò i dispositivi (mobile e desktop) hanno preinstallati una lista di certificati attendibili riconosciuti a livello mondiale. Un certificato, viene ritenuto valido, se fa parte della lista (CA), oppure se è stato firmato a sua volta con un certificato attendibile, quindi se è stato firmato da una CA, oppure se è stato autofirmato ed inserito nei certificati di autentiticità. Sull'APP all'interno dell'APK nel file res/xml/network-security-config.xml, dovrebbe essere presente l'hash della chiave pubblica del certificato con cui l'APP lato client prova a validare la chiave privata del server durante il TLS Handshake. Attraverso Frida, si cerca di mockare i controlli delle classi e funzioni che effettuano il certificate pinning (es. Android Library -  OkHttp with CertificatePinner class e IOS NSURLConnectionDelegate using NSURLConnection).  
    
137. Frida: Framework utilizzato per bypassare il controllo sul certificate pinning sulla parte mobile Android e IOS.  E' necessario pertanto installare il Frida Server su Android e successivamente lanciare Objection, ossia l'exploit incluso all'interno di Frida per il disable SSL.  
    
138. OpenSSL OpenSSL è una libreria software open source ampiamente utilizzata per generare e gestire certificati. OpenSSL è consigliato per garantire la compatibilità con lo sviluppo e il supporto. Utilizzando OpenSSL è possibile generare le chiavi private e pubbliche, i certificati e le richieste di firma dei certificati da inviare a un'autorità di certificazione. OpenSSL è un progetto open source e può essere utilizzato gratuitamente. Utilizzata in concomitanza per creare un certificato autofirmarlo.  
    
139. Cyberchef Tools Online per la codifica, conversione di stringhe  
    
140. Fuzzing Il fuzzing è una tecnica automatizzata di collaudo del software che prevede l'immissione di dati non validi, imprevisti o casuali come input di un programma tramite appositi programmi detti fuzzer  
    
141. Prisma Cloud Una piattaforma di sicurezza cloud-native, progettata per proteggere tutti gli aspetti dell'utilizzo del cloud  
    
142. DirBuster/GoBuster/Dirb/Ffuf Tools utilizzato per fare bruteforce e ricercare files e directories in a web server  
    
143. Strings vs Grep Strings è un programma nei sistemi operativi Unix , Plan 9 , Inferno e simili a Unix che trova e stampa le stringhe di caratteri stampabili nei file. I file possono essere normali file di testo o file binari come eseguibili. Può essere utilizzato su file oggetto e core dump . strings è utile principalmente per determinare il contenuto di file non di testo.  
    
144. Cobian11: Tools per il backup di server  
    
145. Calibre: Tools open source per ibook   
    
146. HxD: HxD è un editor/tools esadecimale freeware, un editor di dischi e un editor di memoria sviluppato da Maël Hörz per Windows. Può aprire file più grandi di 4 GiB e aprire e modificare il contenuto non elaborato delle unità disco, nonché visualizzare e modificare la memoria utilizzata dai processi in esecuzione.  
    
147. Thunderbird Thunderbird è un'applicazione/tools aperta e gratuita per la gestione di posta elettronica, feed di news, chat e calendario, facile da configurare e personalizzare.  
    
148. Binwalk: Tools per l'analisi del firmware, utilizzato anche per unzip del firmware (binwalk –e)  
    
149. ViewState: Il ViewState è la tecnica utilizzata da ASP.NET per tenere traccia dello stato dei controlli presenti in una Web form, ad esempio il testo inserito in una casella oppure le CheckBox selezionate. Quando si esegue il submit di una form, i valori dei suoi controlli sono codificati all’interno di una stringa memorizzata in un campo nascosto chiamato __VIEWSTATE. Questo accorgimento si rende necessario perché HTTP è un protocollo stateless (senza stato), ovvero non mantiene informazioni sullo stato di una pagina tra una visita e l’altra. Con il ViewState, invece, è possibile trasferire lo stato dei controlli dal server al client e viceversa: in altre parole, il server, leggendo il ViewState di una pagina, è in grado di ripristinare, ad esempio, il valore corrente di tutti i campi di input, così come erano stati impostati sul client, senza bisogno che sia il programmatore a farlo via codice.  
    
150. Open Redirection: Quando all'interno di un'API che vado a richiamare, vado ad effettuare una redirection interna ad un altro host, utilizzato dei campi recuperabili dal Request Body o Header . E' una sorta di Server Site Request Forgery, il valore che associo ad una variabile viene utilizzato per re-indirizzarmi da qualche altra parte.  Posso sfruttare anche l'header Refearer che magari viene utilizzata per dei check  Header - Open Redirect 
    

X-Host: [https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com](https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com/) X-Forwarded-Server: [https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com](https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com/) X-HTTP-Host-Override: [https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com](https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com/) Forwarded: [https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com](https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com/) Location: [https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com](https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com/) Referer: [https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com](https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com/) X-Original-URL: [https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com](https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com/) X-Rewrite-URL: [https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com](https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com/) Origin: [https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com](https://n6uhpuedqp9j0y5ra1p7ao03xu3lrcf1.oastify.com/) X-Rewrite-URL: X-Origin-URL:  

151. Skeat Leak: Tools SKIT Interno centralizzato ma non piu aggiornato per reperire tutti i vari leak da tutti i database.  
    
152. DNS Reverse Per fare l'inverse DNS si cerca di recuperare dal root server i record presenti con il query type PRT, avremo pertanto un record con name: IP e value: nomeHost In alternativa al DNS Reverse, è possibile utilizzare un tools interno inquisitor/res ip2hosts.sh reverseIp (scp 192.168.7.23:/root/work/lawer/inquisitor/inquisitor.out.*). E' possibile anche utilizzare "Bind" per fare Reverse DNS cercando per IP  
    
153. Inquisitor Tools interno che fa da reverse DNS, a partire da alcuni IP, prova a recuperare tutti i domini associati. E' lento non lo fermare, lancia un docker se fermo il processo sono cazzi quindi usa tmux altrimenti il processo.  
    
154. Password Spraying: Il password spray (o attacco di password spray) avviene quando l'aggressore usa password comuni per tentare di accedere a più account presenti su uno stesso dominio.  
    
155. ARM:  Processori ARM (appartenenti alla famiglia dei microprocessori RISC) Grazie alle sue caratteristiche di basso consumo elettrico, rapportato alle prestazioni, l'architettura ARM domina il settore dei dispositivi mobili dove il risparmio energetico delle batterie è fondamentale.  I processori ARM vengono utilizzati in cellulari, tablet, lettori multimediali, console portatili, PDA e periferiche per computer (come router, hard disk di rete ecc).   
    
156. Task hijacking  Se alcuni parametri non sono valorizzati e Android <10, è possibile che un'altra applicazione in esecuzione in parallelo alla mia app vulnerabile possa intercettare il traffico nel momento in cui si esegue un task specifico.  
    

157. Task Affinity  E' utilizzato per effettuare task Hijacking, sostanzialmente mi indica l'id del task, quindi se io non lo vado a modificare è sfruttabile l'anomalia in quanto sulla mia APP malevola utilizzerò lo stesso id associato al taskAffinity.  
    
158. IPS: Sono integrati all'interno del firewall, mentre gli IDS sono strumenti a parte che bisogna integrare (es. Darktrace)  
    
159. Nessus: Tools di scansione automatizzato utilizzato per ricercare vulnerbilità (Nessus interno sulla 7.23)  
    
160. VirtualHosting All'interno di un virtualhosting ho sempre una macchina al cui interno ho ulteriori virtualizzatori. Quando faccio la richiesta all'IP, utilizo dei file di configurazione della macchina per capire dove devo essere indirizzato, nel caso nell'header host non è specificato. All'interno del 'document/root' (apache/site-enables) posso settare in presenza di virtual host delle regole di default.  
    
161. Server configuration Solitamente all'interno del server è presnete un file /etc/apache2/apache2.config, nel quale sono presneti delle regole e la configurazione delle tipologie di file che possono essere eseguite. Es.  LoadModule php_module /usr/lib/apache2/modules/libphp.so AddType application/x-httpd-php .php  Tali configurazioni possono essere modificate con regole specifiche all'interno di directory. Per Apache in ogni directory è possibile inserire un file .htaccess per overridare le configurazioni. Sui server IIS, il file per le configurazioni utilizzato è web.config.  
    
162. Routing - Gateway host: Configurazione che permette ad un host di veicolare il traffico come fosse un gateway facendo forward del traffico -> proc/sys/net/ipv4/ipv4/ip_forward  
    
163. Pwnagotchi: Pwnagotchi è un dispositivo che ci aiuta a crackare le reti Wi-Fi; con un Raspberry Pi Zero W  
    
164. RaspberryPi: Computer a scheda singola. E' un mini PC per la realizzazione di progetti hardware, con cui creare sistemi più o meno avanzati: ecco quali sono i migliori da acquistare. Raspberry Pi è un mini computer, un dispositivo hardware completo racchiuso in una singola board abbinato a una piattaforma di programmazione.   
    
165. Red Teaming Metodologia: Responder -> Crack -> Admin Locale -> Hash Locale -> Altri PC  
    
166. Luak di rete:  Deve essere disattivato luack di rete che impedisce di inviare comandi anche se sei amministratore, c'è il wak di rete.  
    
167. net user /domain:  Comando che indica a quale dominio appartieni (puoi usare anche il system administrator dallo start di windows)  
    
168. Risoluzione DNS – Step: Memoria -> etc/hosts/ LLMNR o failover su NBT-NS / DNS   
    
169. SSH – Locale ssh -L 3389: IP :Porta  -D   SSH con porta locale, ossia reindirizzo statico il traffico sul mio localhost 3389  
    
170. Port Forwarding Locale Local port forwarding utilizzato per il tunneling delle connessioni locali a una porta su un server remoto.  
    
171. Port forwarding remoto: Utilizzato per il tunneling di connessioni remote a una porta su un server locale [](mailto:user@example.com) 
    
172. Port Forwarding Dinamico Instrada il traffico tramite proxy SOCKS.  Port forwarding dinamico utilizzato per creare un proxy TCP tramite un host remoto.  
    
173. Host header poisoning: Avvelenamento dell'header, per creare una vulnerabilità. Es. Open Redirection. Modifico l'header della request che viene utilizzata dalla response per fare Open Redirection e sfrutto la vulnerabilità.  
    
174. Wdigest: Tools to extract passwords in cleartext from the memory of compromised devices when testing for security vulnerabilities  
    
175. Lsassy: Python library to remotely extract credentials on a set of hosts. This blog post explains how it works.   
    
176. Ostorlab: Tools per scann automatizzato Mobile  
    
177. MobSF: Tools per scann automatizzato Mobile   
    
178. Vulnerabilità Mobile diffuse: Verifico se ci sono vulenrbailita con lo scan, solitamente trovo API di google in chiaro, che possono non avere il blocco per APP + codice APP e potrebbero essere utilizzate da chiunque. Aiza la parte iniziale della key, che è in chiaro nell'apk   
    
179. OWASP Top 10: 1.  Broken Access Control 2.  Cryptographic Failures 3.  Injection 4.  Insecure Design 5.  Security Misconfiugration 6.  Vulnerable and OutDated Components 7.  Identification and Authentication Failures 8.  Software and Data Integrity Failures 9.  Security Logging and Monitoring Failures 10. Server Side Request Forgery  
    
180. BufferOverFlow Quando, per errore o per malizia, vengono inviati più dati della capienza del buffer destinato a contenerli (che per errore, malizia o superficialità non è stato progettato a dovere), i dati extra vanno a sovrascrivere le variabili interne del programma, o il suo stesso stack; come conseguenza di ciò, a seconda di cosa è stato sovrascritto e con quali valori, il programma può dare risultati errati o imprevedibili, bloccarsi, o (se è un driver di sistema o lo stesso sistema operativo) bloccare il computer. Conoscendo molto bene il programma in questione, il sistema operativo e il tipo di computer su cui gira, si può precalcolare una serie di dati malevoli che inviati per provocare un buffer overflow consenta ad un malintenzionato di prendere il controllo del programma (e a volte, tramite questo, dell'intero computer). - Stack Buffer OverFlow: Questa è la forma più comune di attacco. L’approccio basato sullo stack si verifica quando un utente malintenzionato invia dati contenenti codice dannoso ad un’applicazione che li memorizza in uno stack buffer. Ciò sovrascrive i dati e concede il controllo dei trasferimenti all’attaccante. - Heap Buffer OverFlow: Un attacco basato su heap è più difficile da eseguire rispetto all’approccio basato su stack. Implica che l’attacco debba inondare lo spazio di memoria di un programma al di là di quello che utilizza per le operazioni di runtime. - Format String Attack: Questo avviene quando un’applicazione elabora i dati di input come un comando o non li convalida in modo efficace.Ciò consente all’attaccante di eseguire il codice leggere i dati nello stack o causare guasti nel programma minacciando, di conseguenza, la sicurezza e la stabilità del sistema.  
    
181. WPS – Wifi Protected Setup E' un maccanismo che permette di negoziare una connessione al richiedente mediante un pulsante e nfc  
    
182. WPA Protocollo di sicurezza per proteggere le reti wireless. Utilizza TKIP come tipologia di criptaggio  
    
183. WPA2 Protocollo di sicurezza per proteggere le reti wireless. Utilizza AES (criptaggio chiave simmetriche) come tipologia di criptaggio WPA2- Enterprise (per aziende) WPA2-Personal (WPA2-PSK) per reti domestiche. Le reti WPA2 possono essere compromesse tramite un attacco KRACK, che si verifica nel momento in cui una rete autentica la connessione di un dispositivo client. Durante la fase di "handshake" tra host e client, gli hacker possono accedere alla rete e sottrarre password e altri dati personali.  
    
184. Single sign-on Il single sign-on è la proprietà di un sistema di controllo d'accesso che consente ad un utente di effettuare un'unica autenticazione valida per più sistemi software o risorse informatiche alle quali è abilitato.  
    
185. HTTP 1.x vs HTTP 2.x Http 1.x invia le richieste con clear text, separati da un carattere di nuova riga. Http 2.x invia le richieste in binario in formato dizionario.
 
    
187. /etc/hosts Aggiungo la rotta DNS locale di tutti i sottodomini in /etc/hosts 159.65.81.40 academy.htb 159.65.81.40 archive.academy.htb 159.65.81.40 faculty.academy.htb 159.65.81.40 test.academy.htb

188. Access Token Impersonification

190. Incognito

191. UAC

193. Meterpreter

194. Kiwi

195. Modalità Kernel - Modalità Utente
196. Alternative Data Stream (ADS)
197. Unattended Files
198. Meterpreter
199. Kiwi
200. Pass the Hash
201. Kerberos
202. 



    
188. SSL_ERROR_RX_RECORD_TOO_LONG L’errore “SSL_ERROR_RX_RECORD_TOO_LONG” indica che il server ha inviato un record SSL/TLS troppo lungo per essere gestito correttamente dal client. Ecco una guida completa per risolvere questo problema: 
    
    1. [Verifica la data e l’ora del tuo dispositivo: Se la data o l’ora del tuo dispositivo sono errate, potrebbe causare problemi di certificato1](https://moltocontent.it/come-risolvere-lerrore-ssl_error_rx_record_too_long/). 
        
    2. Cancella la cronologia e la cache del browser: A volte, i dati memorizzati nella cronologia e nella cache possono causare errori di connessione. [Prova a cancellare la cronologia di navigazione e la cache del tuo browser](https://moltocontent.it/come-risolvere-lerrore-ssl_error_rx_record_too_long/)[2](https://kinsta.com/it/knowledgebase/ssl_error_rx_record_too_long/). 
        
    3. [Verifica la configurazione della porta di accesso al server: Assicurati che la porta di accesso al server sia configurata correttamente](https://moltocontent.it/come-risolvere-lerrore-ssl_error_rx_record_too_long/)[2](https://kinsta.com/it/knowledgebase/ssl_error_rx_record_too_long/). 
        
    4. [Aggiorna il tuo browser: Verifica se è disponibile un aggiornamento per il tuo browser e installalo, poiché potrebbe risolvere il problema](https://moltocontent.it/come-risolvere-lerrore-ssl_error_rx_record_too_long/)[2](https://kinsta.com/it/knowledgebase/ssl_error_rx_record_too_long/). 
        
    5. [Verifica il tuo firewall o iptables: Assicurati che il tuo firewall o iptables consenta le connessioni in entrata sulla porta 443](https://moltocontent.it/come-risolvere-lerrore-ssl_error_rx_record_too_long/)[3](https://bing.com/search?q=SSL_ERROR_RX_RECORD_TOO_LONG+italiano). 
        
    6. Verifica la versione del Transport Layer Security (TLS): Assicurati che il tuo browser supporti una versione adeguata del TLS. [In passato, questo errore era comune con TLS 1.2, ma negli ultimi anni si è verificato anche con TLS 1.3](https://moltocontent.it/come-risolvere-lerrore-ssl_error_rx_record_too_long/)[2](https://kinsta.com/it/knowledgebase/ssl_error_rx_record_too_long/). 
        
    7. [Contatta l’amministratore del sito web: Se il problema persiste, potrebbe essere necessario contattare l’amministratore del sito web per verificare la configurazione del certificato SSL](https://moltocontent.it/come-risolvere-lerrore-ssl_error_rx_record_too_long/)[2](https://kinsta.com/it/knowledgebase/ssl_error_rx_record_too_long/). 
        

Spero che queste soluzioni ti aiutino a risolvere l’errore e a navigare senza problemi! 🌐


```